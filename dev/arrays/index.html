<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Array Types · SuiteSparseGraphBLAS.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SuiteSparseGraphBLAS.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li class="is-active"><a class="tocitem" href>Array Types</a><ul class="internal"><li><a class="tocitem" href="#GBMatrix"><span>GBMatrix</span></a></li><li><a class="tocitem" href="#GBVector"><span>GBVector</span></a></li><li class="toplevel"><a class="tocitem" href="#Indexing"><span>Indexing</span></a></li><li class="toplevel"><a class="tocitem" href="#Transpose"><span>Transpose</span></a></li><li class="toplevel"><a class="tocitem" href="#Special-GBArray-Types"><span>Special <code>GBArray</code> Types</span></a></li></ul></li><li><a class="tocitem" href="../operations/">Operations</a></li><li><span class="tocitem">Operators</span><ul><li><a class="tocitem" href="../operators/">Operators</a></li><li><a class="tocitem" href="../unaryops/">Unary Operators</a></li><li><a class="tocitem" href="../binaryops/">Binary Operators</a></li><li><a class="tocitem" href="../monoids/">Monoids</a></li><li><a class="tocitem" href="../semirings/">Semirings</a></li><li><a class="tocitem" href="../selectops/">Index Operators</a></li></ul></li><li><a class="tocitem" href="../utilities/">Utilities</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Array Types</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Array Types</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaSparse/SuiteSparseGraphBLAS.jl/blob/master/docs/src/arrays.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Array-Types"><a class="docs-heading-anchor" href="#Array-Types">Array Types</a><a id="Array-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Array-Types" title="Permalink"></a></h1><p>There are two primary array types in SuiteSparseGraphBLAS.jl: <a href="#SuiteSparseGraphBLAS.GBVector"><code>GBVector</code></a> and <a href="#SuiteSparseGraphBLAS.GBMatrix"><code>GBMatrix</code></a>, as well as a few specialized versions of those array types. The full type hierarchy is:</p><pre><code class="nohighlight hljs">AbstractGBArray{T, F, O, N} &lt;: AbstractSparseArray{Union{T, F}, N}
 ├ N = 2 ─ AbstractGBMatrix{T, F} 
 │   ├─ GBMatrix{T, F, RuntimeOrder()}
 │   ├─ OrientedGBMatrix{T, F, O}
 │   └─ GBShallowMatrix{T, F, ColMajor()}
 └ N = 1, O = ColMajor() ─ AbstractGBVector{T, F}
     ├─ GBVector{T, F}
     └─ GBShallowVector{T, F}</code></pre><p>The <code>T</code> parameter is the element type of the array, <code>N</code> is the dimensionality, <code>F</code> is the type of the fill value (often <code>Nothing</code> or <code>T</code>), and <code>O</code> is the storage order. The <code>OrientedGBMatrix</code> restricts the orientation to the parameter <code>O</code> to either <code>ByRow()</code> or <code>ByCol()</code>. </p><p>All of these types attempt to implement most of the <code>AbstractArray</code> interface, and the relevant parts of the <code>SparseArrays</code> interface.</p><h2 id="GBMatrix"><a class="docs-heading-anchor" href="#GBMatrix">GBMatrix</a><a id="GBMatrix-1"></a><a class="docs-heading-anchor-permalink" href="#GBMatrix" title="Permalink"></a></h2><p>The <code>GBMatrix</code> is an opaque sparse matrix structure, which adapts to the sparsity of a matrix by changing the implementation internally. There are 4 different internal representations, all stored in either row or column orientation:</p><ol><li><em><strong>Dense</strong></em> - Equivalent to a Julia <code>Matrix</code>, except it may be stored in <code>RowMajor()</code> order.</li><li><em><strong>Bitmap</strong></em> - 2 dense arrays, one storing booleans in the pattern of the matrix, the other storing the values.</li><li><em><strong>Sparse Compressed</strong></em> - <a href="http://netlib.org/linalg/html_templates/node92.html#SECTION00931200000000000000">Compressed Sparse Column (CSC)</a> or <a href="http://netlib.org/linalg/html_templates/node91.html">Compressed Sparse Row(CSR)</a></li><li><em><strong>Doubly Compressed</strong></em> or <strong>Hypersparse</strong> - Doubly Compressed Sparse Column (DCSC or Hypersparse CSC) and Doubly Compressed Sparse Row (DCSR or Hypersparse CSR). See this paper for more information: <a href="https://people.eecs.berkeley.edu/~aydin/hypersparse-ipdps08.pdf">pdf</a>.</li></ol><p>Additionally, when the stored values in a <code>GBMatrix</code> are uniform the value array may be stored in the <em><strong>iso</strong></em> version of one of the formats above. Rather than storing the full value array, an iso <code>GBMatrix</code> will only store the single scalar to improve performance. This is useful for matrices like the unweighted adjacency matrix, where all stored values may be <code>true</code>. </p><p>Users should rarely need to directly interact with the underlying storage format, SuiteSparse:GraphBLAS will automatically convert between them as necessary.</p><h3 id="Construction"><a class="docs-heading-anchor" href="#Construction">Construction</a><a id="Construction-1"></a><a class="docs-heading-anchor-permalink" href="#Construction" title="Permalink"></a></h3><p>There are several methods to construct GBArrays. Shown here are empty construction, conversion from a dense matrix and a sparse matrix, and coordinate form with uniform or <em>iso</em> coefficients. </p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; x = GBMatrix{Bool}(20_000_000, 50_000)</code><code class="nohighlight hljs ansi" style="display:block;">20000000x50000 GraphBLAS bool matrix, hypersparse by row
  no entries, memory: 280 bytes</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; x = GBMatrix([[1,2] [3,4]])</code><code class="nohighlight hljs ansi" style="display:block;">2x2 GraphBLAS int64_t matrix, full by col
  4 entries, memory: 288 bytes

    (1,1)   1
    (2,1)   2
    (1,2)   3
    (2,2)   4</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; x = GBMatrix(sprand(100, 100, 0.5); fill = 0.0)</code><code class="nohighlight hljs ansi" style="display:block;">100x100 GraphBLAS double matrix, bitmap by col
  5053 entries, memory: 144.2 KB

    (1,1)    0.781193
    (6,1)    0.33842
    (10,1)    0.26279
    (14,1)    0.76916
    (15,1)    0.353062
    (16,1)    0.490285
    (18,1)    0.431404
    (21,1)    0.968448
    (23,1)    0.606948
    (24,1)    0.65189
    (25,1)    0.154272
    (28,1)    0.450289
    (29,1)    0.547213
    (30,1)    0.824719
    (31,1)    0.283462
    (32,1)    0.724819
    (34,1)    0.816564
    (35,1)    0.320139
    (39,1)    0.66774
    (43,1)    0.990313
    (44,1)    0.0793472
    (48,1)    0.409504
    (49,1)    0.219193
    (50,1)    0.776099
    (54,1)    0.166965
    (55,1)    0.877835
    (56,1)    0.822444
    (57,1)    0.218034
    (58,1)    0.557012
    ...</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; x = GBMatrix(
           rand(1:50_000, 5000), rand(1:500_000, 5000), 1, 500_000, 500_000
       )</code><code class="nohighlight hljs ansi" style="display:block;">500000x500000 GraphBLAS int64_t matrix, hypersparse by row
  5000 entries, memory: 192.3 KB
  iso value:   1

    (4,217836)   1
    (4,335464)   1
    (24,74198)   1
    (33,206611)   1
    (42,50241)   1
    (73,430489)   1
    (94,182277)   1
    (129,312164)   1
    (133,301042)   1
    (166,162105)   1
    (166,490706)   1
    (170,208179)   1
    (178,90454)   1
    (178,376913)   1
    (195,172534)   1
    (205,299347)   1
    (224,434503)   1
    (229,244835)   1
    (231,343177)   1
    (239,279998)   1
    (241,436984)   1
    (254,15390)   1
    (265,269039)   1
    (268,289017)   1
    (269,84445)   1
    (274,64839)   1
    (274,104326)   1
    (276,138328)   1
    (280,274039)   1
    ...</code></pre><article class="docstring"><header><a class="docstring-binding" id="SuiteSparseGraphBLAS.GBMatrix" href="#SuiteSparseGraphBLAS.GBMatrix"><code>SuiteSparseGraphBLAS.GBMatrix</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GBMatrix{T, F} &lt;: AbstractSparseArray{T, UInt64, 2}</code></pre><p>Two-dimensional GraphBLAS array with elements of type <code>T</code>. <code>F</code> is the type of the fill-value,  which is typically <code>Missing</code> or <code>T</code>.  Internal representation is specified as opaque, but in this implementation is stored as one of  the following in either row or column orientation:</p><pre><code class="nohighlight hljs">1. Dense
2. Bitmap
3. Sparse Compressed
4. Hypersparse</code></pre><p>The storage type is automatically determined by the library.</p><p>#Signatures</p><pre><code class="nohighlight hljs">GBMatrix{T, F}(nrows::Integer, ncols::Integer; fill = defaultfill(F))
GBMatrix{T}(nrows::Integer, ncols::Integer; fill = defaultfill(T))
GBMatrix(I::AbstractVector, J::AbstractVector, X::AbstractVector{T}, dims...; fill=defaultfill(T), combine=+)
GBMatrix(I::AbstractVector, J::AbstractVector, x::T, dims...; fill=defaultfill(T), combine=+)
GBMatrix(A::Union{&lt;:AbstractGBArray, &lt;:AbstractMatrix}; fill = defaultfill(eltype(A)))</code></pre><p>All constructors, no matter their input, may specify an element type <code>T</code> as well as a fill type <code>F</code>, conversions are handled internally. These parameters will be inferred in most cases.</p><p><code>GBMatrix</code> construction from an existing AbstractArray will maintain the storage order of the original, typically <code>ColMajor()</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSparse/SuiteSparseGraphBLAS.jl/blob/ce89efca856aa1afe65c5913423eb87ac4239f87/src/types.jl#L875-L904">source</a></section></article><h2 id="GBVector"><a class="docs-heading-anchor" href="#GBVector">GBVector</a><a id="GBVector-1"></a><a class="docs-heading-anchor-permalink" href="#GBVector" title="Permalink"></a></h2><p>A <code>GBVector</code> is the one-dimensional equivalent of the <code>GBMatrix</code>, and internally a <code>GBVector</code> is represented in exactly the same fashion. However, they are always column-oriented. </p><h3 id="Construction-2"><a class="docs-heading-anchor" href="#Construction-2">Construction</a><a class="docs-heading-anchor-permalink" href="#Construction-2" title="Permalink"></a></h3><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; v = GBVector{ComplexF32}(100)</code><code class="nohighlight hljs ansi" style="display:block;">100x1 GraphBLAS float complex matrix, sparse by col
  no entries, memory: 272 bytes</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; v = GBMatrix(rand(ComplexF64, 3); fill = nothing)</code><code class="nohighlight hljs ansi" style="display:block;">3x1 GraphBLAS double complex matrix, full by col
  3 entries, memory: 304 bytes

    (1,1)    0.427852 + 0.168292i
    (2,1)    0.528501 + 0.0910631i
    (3,1)    0.181877 + 0.330798i</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; v = GBVector(sprand(Bool, 100_000_000, 0.001))</code><code class="nohighlight hljs ansi" style="display:block;">100000000x1 GraphBLAS bool matrix, sparse by col
  100184 entries, memory: 880.8 KB

    (1120,1)   1
    (1808,1)   1
    (1905,1)   1
    (3534,1)   1
    (3628,1)   1
    (3656,1)   1
    (3751,1)   1
    (4914,1)   1
    (5594,1)   1
    (5771,1)   1
    (7171,1)   1
    (8515,1)   1
    (9160,1)   1
    (9236,1)   1
    (9442,1)   1
    (10393,1)   1
    (10901,1)   1
    (11564,1)   1
    (12001,1)   1
    (18317,1)   1
    (18781,1)   1
    (19348,1)   1
    (20061,1)   1
    (20208,1)   1
    (24436,1)   1
    (25212,1)   1
    (30870,1)   1
    (31688,1)   1
    (31775,1)   1
    ...</code></pre><article class="docstring"><header><a class="docstring-binding" id="SuiteSparseGraphBLAS.GBVector" href="#SuiteSparseGraphBLAS.GBVector"><code>SuiteSparseGraphBLAS.GBVector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GBVector{T, F} &lt;: AbstractSparseArray{T, UInt64, 1}</code></pre><p>One-dimensional GraphBLAS array with elements of type T. <code>F</code> is the type of the fill-value,  which is typically <code>Missing</code> or <code>T</code>.  Internal representation is specified as opaque, but may be either a dense vector, bitmap vector, or  compressed sparse vector.</p><p>See also: <a href="#SuiteSparseGraphBLAS.GBMatrix"><code>GBMatrix</code></a>.</p><p><strong>Construction Signatures</strong></p><pre><code class="nohighlight hljs">GBVector{T, F}(n::Integer; fill = defaultfill(F))
GBVector{T}(n::Integer; fill = defaultfill(T))
GBVector(I::AbstractVector, X::AbstractVector{T}, n; fill=defaultfill(T), combine=+)
GBVector(I::AbstractVector, x::T, n; fill=defaultfill(T), combine=+)
GBVector(v::Union{&lt;:AbstractGBVector, &lt;:AbstractVector}; fill = defaultfill(eltype(v)))</code></pre><p>All constructors, no matter their input, may specify parameters for  element type <code>T</code> as well as a fill type <code>F</code>, conversions are handled internally. These parameters will be inferred in most cases.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSparse/SuiteSparseGraphBLAS.jl/blob/ce89efca856aa1afe65c5913423eb87ac4239f87/src/types.jl#L835-L856">source</a></section></article><h1 id="Indexing"><a class="docs-heading-anchor" href="#Indexing">Indexing</a><a id="Indexing-1"></a><a class="docs-heading-anchor-permalink" href="#Indexing" title="Permalink"></a></h1><p>The usual AbstractArray and SparseArray indexing capabilities are available. Including indexing by scalars, vectors, and ranges.</p><div class="admonition is-danger"><header class="admonition-header">Indexing Structural Zeros</header><div class="admonition-body"><p>When indexing a <code>SparseMatrixCSC</code> from <code>SparseArrays</code> a structural, or implicit, zero will be returned as <code>zero(T)</code> where <code>T</code> is the element type of the matrix.</p><p>When indexing a GBArray structural zeros default to <code>nothing</code>. While this is a significant departure from the <code>SparseMatrixCSC</code> it more closely matches the GraphBLAS spec, and enables the consuming method to determine the value of implicit zeros in the presence of explicit zeros. </p><p>For instance with an element type of <code>Float64</code> you may want the implicit zero to be <code>0.0</code>, <code>-∞</code> or <code>+∞</code> depending on your algorithm. In addition, for graph algorithms there may be a distinction between an implicit zero, indicating the lack of an edge between two vertices in an adjacency matrix, and an explicit zero where the edge exists but has a <code>0</code> weight.</p><p>However, many functions outside of GraphBLAS will throw an error if they receive <code>nothing</code> from an indexing operation. To accomodate these functions the user may set the fill value for an <code>AbstractGBArray</code> on construction and with <a href="../utilities/#SuiteSparseGraphBLAS.setfill"><code>setfill</code></a> and <a href="../utilities/#SuiteSparseGraphBLAS.setfill!"><code>setfill!</code></a>.</p></div></div><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; A = GBMatrix([1,1,2,2,3,4,4,5,6,7,7,7], [2,4,5,7,6,1,3,6,3,3,4,5], [1:12...])</code><code class="nohighlight hljs ansi" style="display:block;">7x7 GraphBLAS int64_t matrix, bitmap by row
  12 entries, memory: 832 bytes

    (1,2)   1
    (1,4)   2
    (2,5)   3
    (2,7)   4
    (3,6)   5
    (4,1)   6
    (4,3)   7
    (5,6)   8
    (6,3)   9
    (7,3)   10
    (7,4)   11
    (7,5)   12</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; SparseMatrixCSC(A)</code><code class="nohighlight hljs ansi" style="display:block;">7×7 SparseMatrixCSC{Int64, Int64} with 12 stored entries:
 ⋅  1   ⋅   2   ⋅  ⋅  ⋅
 ⋅  ⋅   ⋅   ⋅   3  ⋅  4
 ⋅  ⋅   ⋅   ⋅   ⋅  5  ⋅
 6  ⋅   7   ⋅   ⋅  ⋅  ⋅
 ⋅  ⋅   ⋅   ⋅   ⋅  8  ⋅
 ⋅  ⋅   9   ⋅   ⋅  ⋅  ⋅
 ⋅  ⋅  10  11  12  ⋅  ⋅</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; A[4]</code><code class="nohighlight hljs ansi" style="display:block;">6</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; A[1,2]</code><code class="nohighlight hljs ansi" style="display:block;">1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; A[[1,3,5,7], :]</code><code class="nohighlight hljs ansi" style="display:block;">4x7 GraphBLAS int64_t matrix, bitmap by row
  7 entries, memory: 544 bytes

    (1,2)   1
    (1,4)   2
    (2,6)   5
    (3,6)   8
    (4,3)   10
    (4,4)   11
    (4,5)   12</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; A[1:2:7, :]</code><code class="nohighlight hljs ansi" style="display:block;">4x7 GraphBLAS int64_t matrix, bitmap by row
  7 entries, memory: 544 bytes

    (1,2)   1
    (1,4)   2
    (2,6)   5
    (3,6)   8
    (4,3)   10
    (4,4)   11
    (4,5)   12</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; A[:,:]</code><code class="nohighlight hljs ansi" style="display:block;">7x7 GraphBLAS int64_t matrix, bitmap by row
  12 entries, memory: 832 bytes

    (1,2)   1
    (1,4)   2
    (2,5)   3
    (2,7)   4
    (3,6)   5
    (4,1)   6
    (4,3)   7
    (5,6)   8
    (6,3)   9
    (7,3)   10
    (7,4)   11
    (7,5)   12</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; A[:, 5]</code><code class="nohighlight hljs ansi" style="display:block;">7x1 GraphBLAS int64_t matrix, bitmap by col
  2 entries, memory: 328 bytes

    (2,1)   3
    (7,1)   12</code></pre><p>The functionality illustrated above extends to <code>GBVector</code> as well.</p><h1 id="Transpose"><a class="docs-heading-anchor" href="#Transpose">Transpose</a><a id="Transpose-1"></a><a class="docs-heading-anchor-permalink" href="#Transpose" title="Permalink"></a></h1><p>The lazy Julia <code>transpose</code> is available, and the adjoint operator <code>&#39;</code> is also overloaded to be equivalent for non-<code>Complex</code> types.</p><h1 id="Special-GBArray-Types"><a class="docs-heading-anchor" href="#Special-GBArray-Types">Special <code>GBArray</code> Types</a><a id="Special-GBArray-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Special-GBArray-Types" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="SuiteSparseGraphBLAS.GBMatrixR" href="#SuiteSparseGraphBLAS.GBMatrixR"><code>SuiteSparseGraphBLAS.GBMatrixR</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">OrientedGBMatrix{T, F, O} &lt;: AbstractSparseArray{T, UInt64, 2}</code></pre><p>Two-dimensional GraphBLAS array with elements of type <code>T</code>. <code>F</code> is the type of the fill-value,  which is typically <code>Missing</code> or <code>T</code>.  Exactly the same as <a href="#SuiteSparseGraphBLAS.GBMatrix"><code>GBMatrix</code></a>, except the memory orientation is static: either <code>StorageOrders.RowMajor()</code> (default) or <code>StorageOrders.ColMajor()</code>.</p><p>The aliases <code>GBMatrixC</code> and <code>GBMatrixR</code> are the preferred construction methods.</p><p>#Signatures</p><pre><code class="nohighlight hljs">GBMatrix[R | C]{T, F}(nrows::Integer, ncols::Integer; fill = defaultfill(F))
GBMatrix[R | C]{T}(nrows::Integer, ncols::Integer; fill = defaultfill(T))
GBMatrix[R | C](I::AbstractVector, J::AbstractVector, X::AbstractVector{T}, dims...; fill=defaultfill(T), combine=+)
GBMatrix[R | C](I::AbstractVector, J::AbstractVector, x::T, dims...; fill=defaultfill(T), combine=+)
GBMatrix[R | C](A::Union{&lt;:AbstractGBArray, &lt;:AbstractMatrix}; fill = defaultfill(eltype(A)))</code></pre><p>All constructors, no matter their input, may specify an element type <code>T</code> as well as a fill type <code>F</code>, conversions are handled internally. These parameters will be inferred in most cases.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSparse/SuiteSparseGraphBLAS.jl/blob/ce89efca856aa1afe65c5913423eb87ac4239f87/src/types.jl#L981">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SuiteSparseGraphBLAS.GBMatrixC" href="#SuiteSparseGraphBLAS.GBMatrixC"><code>SuiteSparseGraphBLAS.GBMatrixC</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">OrientedGBMatrix{T, F, O} &lt;: AbstractSparseArray{T, UInt64, 2}</code></pre><p>Two-dimensional GraphBLAS array with elements of type <code>T</code>. <code>F</code> is the type of the fill-value,  which is typically <code>Missing</code> or <code>T</code>.  Exactly the same as <a href="#SuiteSparseGraphBLAS.GBMatrix"><code>GBMatrix</code></a>, except the memory orientation is static: either <code>StorageOrders.RowMajor()</code> (default) or <code>StorageOrders.ColMajor()</code>.</p><p>The aliases <code>GBMatrixC</code> and <code>GBMatrixR</code> are the preferred construction methods.</p><p>#Signatures</p><pre><code class="nohighlight hljs">GBMatrix[R | C]{T, F}(nrows::Integer, ncols::Integer; fill = defaultfill(F))
GBMatrix[R | C]{T}(nrows::Integer, ncols::Integer; fill = defaultfill(T))
GBMatrix[R | C](I::AbstractVector, J::AbstractVector, X::AbstractVector{T}, dims...; fill=defaultfill(T), combine=+)
GBMatrix[R | C](I::AbstractVector, J::AbstractVector, x::T, dims...; fill=defaultfill(T), combine=+)
GBMatrix[R | C](A::Union{&lt;:AbstractGBArray, &lt;:AbstractMatrix}; fill = defaultfill(eltype(A)))</code></pre><p>All constructors, no matter their input, may specify an element type <code>T</code> as well as a fill type <code>F</code>, conversions are handled internally. These parameters will be inferred in most cases.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSparse/SuiteSparseGraphBLAS.jl/blob/ce89efca856aa1afe65c5913423eb87ac4239f87/src/types.jl#L980">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SuiteSparseGraphBLAS.GBShallowMatrix" href="#SuiteSparseGraphBLAS.GBShallowMatrix"><code>SuiteSparseGraphBLAS.GBShallowMatrix</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GBShallowMatrix{T, F, O, P, B, A} &lt;: AbstractSparseArray{T, UInt64, 2}</code></pre><p>Shallow GraphBLAS matrix type wrapping a Julia-resident array. Currently supported only for <code>Matrix</code></p><p>The primary constructor for this type is the <a href="@ref"><code>pack</code></a> function, although it may also be constructed directly via <code>GBShallowMatrix(A::Matrix)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSparse/SuiteSparseGraphBLAS.jl/blob/ce89efca856aa1afe65c5913423eb87ac4239f87/src/types.jl#L1014-L1021">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SuiteSparseGraphBLAS.GBShallowVector" href="#SuiteSparseGraphBLAS.GBShallowVector"><code>SuiteSparseGraphBLAS.GBShallowVector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GBShallowVector{T, F, P, B, A} &lt;: AbstractSparseArray{T, UInt64, 1}</code></pre><p>Shallow GraphBLAS vector type wrapping a Julia-resident vector. Currently supported only for <code>Vector</code></p><p>The primary constructor for this type is the <a href="@ref"><code>pack</code></a> function, although it may also be constructed directly via <code>GBShallowVector(A::Vector)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSparse/SuiteSparseGraphBLAS.jl/blob/ce89efca856aa1afe65c5913423eb87ac4239f87/src/types.jl#L992-L999">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="SuiteSparseGraphBLAS.GBScalar" href="#SuiteSparseGraphBLAS.GBScalar"><code>SuiteSparseGraphBLAS.GBScalar</code></a> — <span class="docstring-category">Type</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaSparse/SuiteSparseGraphBLAS.jl/blob/ce89efca856aa1afe65c5913423eb87ac4239f87/src/types.jl#L331">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Introduction</a><a class="docs-footer-nextpage" href="../operations/">Operations »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Tuesday 22 November 2022 22:49">Tuesday 22 November 2022</span>. Using Julia version 1.8.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
