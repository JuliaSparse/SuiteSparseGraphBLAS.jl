<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Introduction · SuiteSparseGraphBLAS.jl</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><script src="../copy.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>SuiteSparseGraphBLAS.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Introduction</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Installation"><span>Installation</span></a></li><li class="toplevel"><a class="tocitem" href="#Introduction"><span>Introduction</span></a></li><li class="toplevel"><a class="tocitem" href="#GraphBLAS-Concepts"><span>GraphBLAS Concepts</span></a></li><li><a class="tocitem" href="#GBArrays"><span>GBArrays</span></a></li><li><a class="tocitem" href="#GraphBLAS-Operations"><span>GraphBLAS Operations</span></a></li><li><a class="tocitem" href="#GraphBLAS-Operators"><span>GraphBLAS Operators</span></a></li><li><a class="tocitem" href="#Example"><span>Example</span></a></li></ul></li><li><a class="tocitem" href="arrays/">Arrays</a></li><li><a class="tocitem" href="operations/">Operations</a></li><li><span class="tocitem">Operators</span><ul><li><a class="tocitem" href="operators/">Basics</a></li><li><a class="tocitem" href="unaryops/">Unary Operators</a></li><li><a class="tocitem" href="binaryops/">Binary Operators</a></li><li><a class="tocitem" href="monoids/">Monoids</a></li><li><a class="tocitem" href="semirings/">Semirings</a></li><li><a class="tocitem" href="selectops/">Select Operators</a></li><li><a class="tocitem" href="udfs/">User Defined Operators</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Introduction</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Introduction</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaSparse/SuiteSparseGraphBLAS.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="SuiteSparseGraphBLAS.jl"><a class="docs-heading-anchor" href="#SuiteSparseGraphBLAS.jl">SuiteSparseGraphBLAS.jl</a><a id="SuiteSparseGraphBLAS.jl-1"></a><a class="docs-heading-anchor-permalink" href="#SuiteSparseGraphBLAS.jl" title="Permalink"></a></h1><p>SuiteSparseGraphBLAS.jl is a package for sparse linear algebra on arbitrary semirings, with a particular focus on graph computations. It aims to provide a Julian wrapper over Tim Davis&#39; SuiteSparse reference implementation of the GraphBLAS C specification.</p><h1 id="Installation"><a class="docs-heading-anchor" href="#Installation">Installation</a><a id="Installation-1"></a><a class="docs-heading-anchor-permalink" href="#Installation" title="Permalink"></a></h1><p>Install using the Julia package manager in the REPL:</p><pre><code class="nohighlight hljs">] add SuiteSparseGraphBLAS</code></pre><p>or with <code>Pkg</code></p><pre><code class="nohighlight hljs">using Pkg
Pkg.add(&quot;SuiteSparseGraphBLAS&quot;)</code></pre><p>The SuiteSparse:GraphBLAS binary is installed automatically as <code>SSGraphBLAS_jll</code>.</p><p>Then in the REPL or script <code>using SuiteSparseGraphBLAS</code> will import the package.</p><h1 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h1><p>GraphBLAS harnesses the well-understood duality between graphs and matrices. Specifically a graph can be represented by its <a href="https://en.wikipedia.org/wiki/Adjacency_matrix">adjacency matrix</a>, <a href="https://en.wikipedia.org/wiki/Incidence_matrix">incidence matrix</a>, or one of the many variations on those formats.  With this matrix representation in hand we have a method to operate on the graph using linear algebra operations on the matrix.</p><p>Below is an example of the adjacency matrix of a directed graph, and finding the neighbors of a single vertex using basic matrix-vector multiplication on the arithemtic semiring.</p><p><img src="assets/AdjacencyBFS.png" alt="BFS and Adjacency Matrix"/></p><h1 id="GraphBLAS-Concepts"><a class="docs-heading-anchor" href="#GraphBLAS-Concepts">GraphBLAS Concepts</a><a id="GraphBLAS-Concepts-1"></a><a class="docs-heading-anchor-permalink" href="#GraphBLAS-Concepts" title="Permalink"></a></h1><p>The three primary components of GraphBLAS are: matrices, operators, and operations. Operators include monoids, binary operators, and semirings. Operations include the typical linear algebraic operations like matrix multiplication as well as indexing operations.</p><h2 id="GBArrays"><a class="docs-heading-anchor" href="#GBArrays">GBArrays</a><a id="GBArrays-1"></a><a class="docs-heading-anchor-permalink" href="#GBArrays" title="Permalink"></a></h2><p>SuiteSparseGraphBLAS.jl provides <code>GBVector</code> and <code>GBMatrix</code> array types which are subtypes of <code>SparseArrays.AbstractSparseVector</code> and <code>SparseArrays.AbstractSparseMatrix</code> respectively.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; GBVector{Float64}(13)</code><code class="nohighlight hljs ansi" style="display:block;">
  13x1 GraphBLAS double matrix, sparse by col
  no entries, memory: 272 bytes</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; GBMatrix{ComplexF64}(1000, 1000)</code><code class="nohighlight hljs ansi" style="display:block;">
  1000x1000 GraphBLAS double complex matrix, hypersparse by row
  no entries, memory: 280 bytes</code></pre><p>GraphBLAS array types are opaque to the user in order to allow the library author to choose the best storage format. SuiteSparse:GraphBLAS takes advantage of this by storing matrices in one of four formats: dense, bitmap, sparse-compressed, or hypersparse-compressed; and in either row or column major orientation.</p><div class="admonition is-warning"><header class="admonition-header">Default Orientation</header><div class="admonition-body"><p>The default orientation of a <code>GBMatrix</code> is by-row, the opposite of Julia arrays, for greater speed in certain operations. However, a <code>GBMatrix</code> constructed from a <code>SparseMatrixCSC</code> or  <code>Matrix</code> will be stored by-column. The orientation of a <code>GBMatrix</code> can be modified using <code>gbset(A, :format, :byrow)</code> or <code>gbset(A, :format, :bycol)</code>.</p></div></div><p>The matrix and vector in the graphic above can be constructed as follows:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; A = GBMatrix([1,1,2,2,3,4,4,5,6,7,7,7], [2,4,5,7,6,1,3,6,3,3,4,5], [1:12...])</code><code class="nohighlight hljs ansi" style="display:block;">
  7x7 GraphBLAS int64_t matrix, bitmap by row
  12 entries, memory: 832 bytes

    (1,2)   1
    (1,4)   2
    (2,5)   3
    (2,7)   4
    (3,6)   5
    (4,1)   6
    (4,3)   7
    (5,6)   8
    (6,3)   9
    (7,3)   10
    (7,4)   11
    (7,5)   12</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; v = GBVector([4], [10])</code><code class="nohighlight hljs ansi" style="display:block;">
  4x1 GraphBLAS int64_t matrix, bitmap by col
  1 entry, memory: 272 bytes
  iso value:   10

    (4,1)   10</code></pre><h2 id="GraphBLAS-Operations"><a class="docs-heading-anchor" href="#GraphBLAS-Operations">GraphBLAS Operations</a><a id="GraphBLAS-Operations-1"></a><a class="docs-heading-anchor-permalink" href="#GraphBLAS-Operations" title="Permalink"></a></h2><p>The complete documentation of supported operations can be found in <a href="operations/#Operations">Operations</a>. GraphBLAS operations are, where possible, methods of existing Julia functions  listed in the third column.</p><table><tr><th style="text-align: left">GraphBLAS</th><th style="text-align: center">Operation</th><th style="text-align: right">Julia</th></tr><tr><td style="text-align: left"><code>mxm</code>, <code>mxv</code>, <code>vxm</code></td><td style="text-align: center"><span>$\bf C \langle M \rangle = C \odot AB$</span></td><td style="text-align: right"><code>mul[!]</code> or <code>*</code></td></tr><tr><td style="text-align: left"><code>eWiseMult</code></td><td style="text-align: center"><span>$\bf C \langle M \rangle = C \odot (A \otimes B)$</span></td><td style="text-align: right"><code>emul[!]</code> or <code>.</code> broadcasting</td></tr><tr><td style="text-align: left"><code>eWiseAdd</code></td><td style="text-align: center"><span>$\bf C \langle M \rangle = C \odot (A \oplus  B)$</span></td><td style="text-align: right"><code>eadd[!]</code></td></tr><tr><td style="text-align: left"><code>extract</code></td><td style="text-align: center"><span>$\bf C \langle M \rangle = C \odot A(I,J)$</span></td><td style="text-align: right"><code>extract[!]</code>, <code>getindex</code> or <code>A[i...]</code></td></tr><tr><td style="text-align: left"><code>subassign</code></td><td style="text-align: center"><span>$\bf C (I,J) \langle M \rangle = C(I,J) \odot A$</span></td><td style="text-align: right"><code>subassign[!]</code>, <code>setindex!</code> or <code>A[i...]=3.5</code></td></tr><tr><td style="text-align: left"><code>assign</code></td><td style="text-align: center"><span>$\bf C \langle M \rangle (I,J) = C(I,J) \odot A$</span></td><td style="text-align: right"><code>assign[!]</code></td></tr><tr><td style="text-align: left"><code>apply</code></td><td style="text-align: center"><span>${\bf C \langle M \rangle = C \odot} f{\bf (A)}$</span></td><td style="text-align: right"><code>map[!]</code> or <code>.</code> broadcasting</td></tr><tr><td style="text-align: left"></td><td style="text-align: center"><span>${\bf C \langle M \rangle = C \odot} f({\bf A},y)$</span></td><td style="text-align: right"></td></tr><tr><td style="text-align: left"></td><td style="text-align: center"><span>${\bf C \langle M \rangle = C \odot} f(x,{\bf A})$</span></td><td style="text-align: right"></td></tr><tr><td style="text-align: left"><code>select</code></td><td style="text-align: center"><span>${\bf C \langle M \rangle = C \odot} f({\bf A},k)$</span></td><td style="text-align: right"><code>select[!]</code></td></tr><tr><td style="text-align: left"><code>reduce</code></td><td style="text-align: center"><span>${\bf w \langle m \rangle = w \odot} [{\oplus}_j {\bf A}(:,j)]$</span></td><td style="text-align: right"><code>reduce[!]</code></td></tr><tr><td style="text-align: left"></td><td style="text-align: center"><span>$s = s \odot [{\oplus}_{ij}  {\bf A}(i,j)]$</span></td><td style="text-align: right"></td></tr><tr><td style="text-align: left"><code>transpose</code></td><td style="text-align: center"><span>$\bf C \langle M \rangle = C \odot A^{\sf T}$</span></td><td style="text-align: right"><code>gbtranspose[!]</code>, lazy: <code>transpose</code>, <code>&#39;</code></td></tr><tr><td style="text-align: left"><code>kronecker</code></td><td style="text-align: center"><span>$\bf C \langle M \rangle = C \odot \text{kron}(A, B)$</span></td><td style="text-align: right"><code>kron[!]</code></td></tr></table><p>where <span>$\bf M$</span> is a <code>GBArray</code> mask, <span>$\odot$</span> is a binary operator for accumulating into <span>$\bf C$</span>, and <span>$\otimes$</span> and <span>$\oplus$</span> are a binary operation and commutative monoid respectively. </p><h2 id="GraphBLAS-Operators"><a class="docs-heading-anchor" href="#GraphBLAS-Operators">GraphBLAS Operators</a><a id="GraphBLAS-Operators-1"></a><a class="docs-heading-anchor-permalink" href="#GraphBLAS-Operators" title="Permalink"></a></h2><p>A GraphBLAS operator is a unary or binary function, the commutative monoid form of a binary function, or a semiring, made up of a binary op and a commutative monoid. SuiteSparse:GraphBLAS ships with many of the common unary and binary operators as built-ins, along with monoids and semirings built commonly used in graph algorithms.  In most cases these operators can be used with familiar Julia syntax and functions, which then map to objects found in the submodules below:</p><ul><li><code>UnaryOps</code> such as <code>SIN</code>, <code>SQRT</code>, <code>ABS</code></li><li><code>BinaryOps</code> such as <code>GE</code>, <code>MAX</code>, <code>POW</code>, <code>FIRSTJ</code></li><li><code>Monoids</code> such as <code>PLUS_MONOID</code>, <code>LXOR_MONOID</code></li><li><code>Semirings</code> such as <code>PLUS_TIMES</code> (the arithmetic semiring), <code>MAX_PLUS</code> (a tropical semiring), <code>PLUS_PLUS</code>, ...</li></ul><p>The above objects should, in almost all cases, be used by instead passing the equivalent functions, <code>sin</code> for <code>SIN</code>, <code>+</code> for <code>PLUS_MONOID</code> etc.</p><p>A user may choose to call a function in multiple different forms: <code>A .+ B</code>, <code>eadd(A, B, +)</code>, or <code>eadd(A, B, BinaryOps.PLUS)</code>. </p><p>Functions which only accept monoids like <code>reduce</code> will automatically find the correct monoid, so a call to <code>reduce(+, A)</code>, will lower to <code>reduce(Monoids.PLUS_MONOID, A)</code>.</p><p>Matrix multiplication, which accepts a semiring, can be called with either <code>*(max, +)(A, B)</code>, <code>mul(A, B, (max, +))</code>, or <code>mul(A, B, Semirings.MAX_PLUS)</code>. </p><div class="admonition is-warning"><header class="admonition-header">Performance of User Defined Functions</header><div class="admonition-body"><p>Operators which are not already built-in are automatically constructed using function pointers when called.  Note, however, that their performance is significantly degraded compared to built-in operators, and where possible user code should avoid this capability.</p></div></div><h2 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h2><p>Here is an example of two different methods of triangle counting with GraphBLAS. The methods are drawn from the LAGraph <a href="https://github.com/GraphBLAS/LAGraph">repo</a>.</p><p>Input <code>A</code> must be a square, symmetric matrix with any element type. We&#39;ll test it using the matrix from the GBArray section above, which has two triangles in its undirected form.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; function cohen(A)
         U = select(triu, A)
         L = select(tril, A)
         return reduce(+, mul(L, U, (+, pair); mask=A)) ÷ 2
       end</code><code class="nohighlight hljs ansi" style="display:block;">cohen (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; function sandia(A)
         L = select(tril, A)
         return reduce(+, mul(L, L, (+, pair); mask=L))
       end</code><code class="nohighlight hljs ansi" style="display:block;">sandia (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; M = eadd(A, A&#39;, +) #Make undirected/symmetric</code><code class="nohighlight hljs ansi" style="display:block;">
  7x7 GraphBLAS int64_t matrix, bitmap by row
  20 entries, memory: 832 bytes

    (1,2)   1
    (1,4)   8
    (2,1)   1
    (2,5)   3
    (2,7)   4
    (3,4)   7
    (3,6)   14
    (3,7)   10
    (4,1)   8
    (4,3)   7
    (4,7)   11
    (5,2)   3
    (5,6)   8
    (5,7)   12
    (6,3)   14
    (6,5)   8
    (7,2)   4
    (7,3)   10
    (7,4)   11
    (7,5)   12</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; cohen(M)</code><code class="nohighlight hljs ansi" style="display:block;">2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; sandia(M)</code><code class="nohighlight hljs ansi" style="display:block;">2</code></pre></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="arrays/">Arrays »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.12 on <span class="colophon-date" title="Tuesday 25 January 2022 11:34">Tuesday 25 January 2022</span>. Using Julia version 1.7.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
