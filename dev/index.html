<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Introduction · SuiteSparseGraphBLAS.jl</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>SuiteSparseGraphBLAS.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Introduction</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Installation"><span>Installation</span></a></li><li class="toplevel"><a class="tocitem" href="#Introduction"><span>Introduction</span></a></li><li><a class="tocitem" href="#GBArrays"><span>GBArrays</span></a></li><li><a class="tocitem" href="#GraphBLAS-Operations"><span>GraphBLAS Operations</span></a></li><li><a class="tocitem" href="#GraphBLAS-Operators"><span>GraphBLAS Operators</span></a></li><li><a class="tocitem" href="#Example"><span>Example</span></a></li><li class="toplevel"><a class="tocitem" href="#Citing"><span>Citing</span></a></li></ul></li><li><a class="tocitem" href="arrays/">Array Types</a></li><li><a class="tocitem" href="operations/">Operations</a></li><li><span class="tocitem">Operators</span><ul><li><a class="tocitem" href="operators/">Operators</a></li><li><a class="tocitem" href="unaryops/">Unary Operators</a></li><li><a class="tocitem" href="binaryops/">Binary Operators</a></li><li><a class="tocitem" href="monoids/">Monoids</a></li><li><a class="tocitem" href="semirings/">Semirings</a></li><li><a class="tocitem" href="selectops/">Select Operators</a></li></ul></li><li><a class="tocitem" href="utilities/">Utilities</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Introduction</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Introduction</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaSparse/SuiteSparseGraphBLAS.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="SuiteSparseGraphBLAS.jl"><a class="docs-heading-anchor" href="#SuiteSparseGraphBLAS.jl">SuiteSparseGraphBLAS.jl</a><a id="SuiteSparseGraphBLAS.jl-1"></a><a class="docs-heading-anchor-permalink" href="#SuiteSparseGraphBLAS.jl" title="Permalink"></a></h1><p>Fast sparse linear algebra is an essential part of the scientific computing toolkit. Outside of the usual applications, like differential equations, sparse linear algebra provides an elegant way to express graph algorithms on adjacency and incidence matrices. The GraphBLAS standard specifies a set of operations for computing sparse matrix graph algorithm in a vein similar to the BLAS or LAPACK standards.</p><p>SuiteSparseGraphBLAS.jl is a blazing fast package for shared memory sparse matrix operations which wraps Tim Davis&#39; SuiteSparse:GraphBLAS. If you use this package in your research please see <a href="#Citing">Citing</a>.</p><h1 id="Installation"><a class="docs-heading-anchor" href="#Installation">Installation</a><a id="Installation-1"></a><a class="docs-heading-anchor-permalink" href="#Installation" title="Permalink"></a></h1><p>Install using the Julia package manager in the REPL:</p><pre><code class="nohighlight hljs">] add SuiteSparseGraphBLAS</code></pre><p>or with <code>Pkg</code></p><pre><code class="nohighlight hljs">using Pkg
Pkg.add(&quot;SuiteSparseGraphBLAS&quot;)</code></pre><p>The SuiteSparse:GraphBLAS binary, SSGraphBLAS_jll.jl, is installed automatically.</p><p>Then in the REPL or script <code>using SuiteSparseGraphBLAS</code> will make the package available for use.</p><h1 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h1><p>GraphBLAS harnesses the well-understood duality between graphs and matrices. Specifically a graph can be represented by the <a href="https://en.wikipedia.org/wiki/Adjacency_matrix">adjacency matrix</a> and/or <a href="https://en.wikipedia.org/wiki/Incidence_matrix">incidence matrix</a>, or one of the many variations on those formats.  With this matrix representation in hand we have a method to operate on the graph with linear algebra.</p><p>One important algorithm that maps well to linear algebra is Breadth First Search (BFS).  A simple BFS is just a matrix-vector multiplication, where <code>A</code> is the adjacency matrix and <code>v</code> is the set of source nodes, as illustrated below.</p><p><img src="assets/AdjacencyBFS.png" alt="BFS and Adjacency Matrix"/></p><h2 id="GBArrays"><a class="docs-heading-anchor" href="#GBArrays">GBArrays</a><a id="GBArrays-1"></a><a class="docs-heading-anchor-permalink" href="#GBArrays" title="Permalink"></a></h2><p>The core SuiteSparseGraphBLAS.jl array types are <code>GBVector</code> and <code>GBMatrix</code> which are subtypes <code>SparseArrays.AbstractSparseVector</code> and <code>SparseArrays.AbstractSparseMatrix</code> respectively.</p><div class="admonition is-info"><header class="admonition-header">GBArray</header><div class="admonition-body"><p>These docs will often refer to the <code>GBArray</code> type, which is the union of <code>AbstractGBVector</code>, <code>AbstractGBMatrix</code> and their lazy Transpose objects.</p></div></div><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; # create a size 13 empty sparse vector with Float64 elements.
       v = GBVector{Float64}(13)</code><code class="nohighlight hljs ansi" style="display:block;">13x1 GraphBLAS double matrix, sparse by col
  no entries, memory: 272 bytes</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; # create a 1000 x 1000 empty sparse matrix with ComplexF64 elements.
       A = GBMatrix{ComplexF64}(1000, 1000)</code><code class="nohighlight hljs ansi" style="display:block;">1000x1000 GraphBLAS double complex matrix, hypersparse by row
  no entries, memory: 280 bytes</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; A[1,5] === nothing</code><code class="nohighlight hljs ansi" style="display:block;">false</code></pre><p>Here we can already see several differences compared to <code>SparseArrays.SparseMatrixCSC</code>.</p><p>The first is that <code>A</code> is stored in <code>hypersparse</code> format, and by row.</p><p><code>GBArrays</code> are (technically) opaque to the user in order to allow the library author to choose the best storage format.<br/>GraphBLAS takes advantage of this by storing matrices in one of four formats: <code>dense</code>, <code>bitmap</code>, <code>sparse-compressed</code>, or <code>hypersparse-compressed</code>; and in either <code>row</code> or <code>column</code> major orientation.<br/>Different matrices may be better suited to storage in one of those formats, and certain operations may perform differently on <code>row</code> or <code>column</code> major matrices.</p><div class="admonition is-warning"><header class="admonition-header">Default Orientation</header><div class="admonition-body"><p>The default orientation of a <code>GBMatrix</code> is by-row, the opposite of Julia arrays. However, a <code>GBMatrix</code> constructed from a <code>SparseMatrixCSC</code> or  <code>Matrix</code> will be stored by-column.<br/>The orientation of a <code>GBMatrix</code> can be modified using <code>setstorageorder!(A, RowMajor())</code> or <code>setstorageorder!(A, ColMajor())</code>, and queried by <code>StorageOrders.storageorder(A)</code></p></div></div><p>Information about storage formats, orientation, conversion, construction and more can be found in <a href="@ref">Arrays</a>.</p><p>The second difference is that a <code>GBArray</code> doesn&#39;t assume the fill-in value of a sparse array.<br/>Since <code>A[1,5]</code> isn&#39;t stored in the matrix (it&#39;s been &quot;compressed&quot; out), we return <code>nothing</code>.<br/> This better matches the GraphBLAS spec, where <code>NO_VALUE</code> is returned, rather than <code>zero(eltype(A))</code>. This is better suited to graph algorithms where returning <code>zero(eltype(A))</code> might imply the presence of an edge with weight <code>zero</code>.<br/>However this behavior can be changed with the <a href="utilities/#SuiteSparseGraphBLAS.setfill!"><code>setfill!</code></a> and <a href="utilities/#SuiteSparseGraphBLAS.setfill"><code>setfill</code></a> functions.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; A[1, 1] === nothing</code><code class="nohighlight hljs ansi" style="display:block;">false</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; B = setfill(A, 0) # no-copy alias</code><code class="nohighlight hljs ansi" style="display:block;">1000x1000 GraphBLAS double complex matrix, hypersparse by row
  no entries, memory: 280 bytes</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; B[1, 1]</code><code class="nohighlight hljs ansi" style="display:block;">0.0 + 0.0im</code></pre><p>An empty matrix and vector won&#39;t do us much good, so let&#39;s see how to construct the matrix and vector from the graphic above. Both <code>A</code> and <code>v</code> below are constructed from coordinate format or COO.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; A = GBMatrix([1,1,2,2,3,4,4,5,6,7,7,7], [2,4,5,7,6,1,3,6,3,3,4,5], [1:12...])</code><code class="nohighlight hljs ansi" style="display:block;">7x7 GraphBLAS int64_t matrix, bitmap by row
  12 entries, memory: 832 bytes

    (1,2)   1
    (1,4)   2
    (2,5)   3
    (2,7)   4
    (3,6)   5
    (4,1)   6
    (4,3)   7
    (5,6)   8
    (6,3)   9
    (7,3)   10
    (7,4)   11
    (7,5)   12</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; v = GBVector([4], [10])</code><code class="nohighlight hljs ansi" style="display:block;">4x1 GraphBLAS int64_t matrix, bitmap by col
  1 entry, memory: 272 bytes
  iso value:   10

    (4,1)   10</code></pre><h2 id="GraphBLAS-Operations"><a class="docs-heading-anchor" href="#GraphBLAS-Operations">GraphBLAS Operations</a><a id="GraphBLAS-Operations-1"></a><a class="docs-heading-anchor-permalink" href="#GraphBLAS-Operations" title="Permalink"></a></h2><p>The complete documentation of supported operations can be found in <a href="operations/#Operations">Operations</a>. GraphBLAS operations are, where possible, methods of existing Julia functions listed in the third column.</p><table><tr><th style="text-align: left">GraphBLAS</th><th style="text-align: center">Operation</th><th style="text-align: right">Julia</th></tr><tr><td style="text-align: left"><code>mxm</code>, <code>mxv</code>, <code>vxm</code></td><td style="text-align: center"><span>$\bf C \langle M \rangle = C \odot AB$</span></td><td style="text-align: right"><code>mul!</code> or <code>*</code></td></tr><tr><td style="text-align: left"><code>eWiseMult</code></td><td style="text-align: center"><span>$\bf C \langle M \rangle = C \odot (A \otimes B)$</span></td><td style="text-align: right"><code>emul[!]</code> or <code>.</code> broadcasting</td></tr><tr><td style="text-align: left"><code>eWiseAdd</code></td><td style="text-align: center"><span>$\bf C \langle M \rangle = C \odot (A \oplus  B)$</span></td><td style="text-align: right"><code>eadd[!]</code></td></tr><tr><td style="text-align: left"><code>extract</code></td><td style="text-align: center"><span>$\bf C \langle M \rangle = C \odot A(I,J)$</span></td><td style="text-align: right"><code>extract[!]</code>, <code>getindex</code></td></tr><tr><td style="text-align: left"><code>subassign</code></td><td style="text-align: center"><span>$\bf C (I,J) \langle M \rangle = C(I,J) \odot A$</span></td><td style="text-align: right"><code>subassign[!]</code> or <code>setindex!</code></td></tr><tr><td style="text-align: left"><code>assign</code></td><td style="text-align: center"><span>$\bf C \langle M \rangle (I,J) = C(I,J) \odot A$</span></td><td style="text-align: right"><code>assign[!]</code></td></tr><tr><td style="text-align: left"><code>apply</code></td><td style="text-align: center"><span>${\bf C \langle M \rangle = C \odot} f{\bf (A)}$</span></td><td style="text-align: right"><code>apply[!]</code>, <code>map[!]</code> or <code>.</code> broadcasting</td></tr><tr><td style="text-align: left"></td><td style="text-align: center"><span>${\bf C \langle M \rangle = C \odot} f({\bf A},y)$</span></td><td style="text-align: right"></td></tr><tr><td style="text-align: left"></td><td style="text-align: center"><span>${\bf C \langle M \rangle = C \odot} f(x,{\bf A})$</span></td><td style="text-align: right"></td></tr><tr><td style="text-align: left"><code>select</code></td><td style="text-align: center"><span>${\bf C \langle M \rangle = C \odot} f({\bf A},k)$</span></td><td style="text-align: right"><code>select[!]</code></td></tr><tr><td style="text-align: left"><code>reduce</code></td><td style="text-align: center"><span>${\bf w \langle m \rangle = w \odot} [{\oplus}_j {\bf A}(:,j)]$</span></td><td style="text-align: right"><code>reduce[!]</code></td></tr><tr><td style="text-align: left"></td><td style="text-align: center"><span>$s = s \odot [{\oplus}_{ij}  {\bf A}(i,j)]$</span></td><td style="text-align: right"></td></tr><tr><td style="text-align: left"><code>transpose</code></td><td style="text-align: center"><span>$\bf C \langle M \rangle = C \odot A^{\sf T}$</span></td><td style="text-align: right"><code>gbtranspose[!]</code>, lazy: <code>transpose</code>, <code>&#39;</code></td></tr><tr><td style="text-align: left"><code>kronecker</code></td><td style="text-align: center"><span>$\bf C \langle M \rangle = C \odot \text{kron}(A, B)$</span></td><td style="text-align: right"><code>kron[!]</code></td></tr></table><p>where <span>$\bf M$</span> is a <code>GBArray</code> mask, <span>$\odot$</span> is a binary operator for accumulating into <span>$\bf C$</span>, and <span>$\otimes$</span> and <span>$\oplus$</span> are a binary operation and commutative monoid respectively. <span>$f$</span> is either a unary or binary operator. </p><h2 id="GraphBLAS-Operators"><a class="docs-heading-anchor" href="#GraphBLAS-Operators">GraphBLAS Operators</a><a id="GraphBLAS-Operators-1"></a><a class="docs-heading-anchor-permalink" href="#GraphBLAS-Operators" title="Permalink"></a></h2><p>Many GraphBLAS operations take additional arguments called <em>operators</em>. In the table above operators are denoted by <span>$\odot$</span>, <span>$\otimes$</span>, and <span>$\oplus$</span> and <span>$f$</span>, and they behave similar to the function argument of <code>map</code>. A closer look at operators can be found in <a href="operators/#Operators">Operators</a></p><p>A GraphBLAS operator is a unary or binary function, the commutative monoid form of a binary function, or a semiring, made up of a binary op and a commutative monoid. SuiteSparse:GraphBLAS ships with many of the common unary and binary operators as built-ins, along with monoids and semirings built commonly used in graph algorithms.  These built-in operators are <em>fast</em>, and should be used where possible. However, users are also free to provide their own functions as operators when necessary.</p><p>SuiteSparseGraphBLAS.jl will <em>mostly</em> take care of operators behind the scenes, and in most cases users should pass in normal functions like <code>+</code> and <code>sin</code>. For example:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; emul(A, A, ^) # elementwise exponent</code><code class="nohighlight hljs ansi" style="display:block;">7x7 GraphBLAS int64_t matrix, bitmap by row
  12 entries, memory: 832 bytes

    (1,2)   1
    (1,4)   4
    (2,5)   27
    (2,7)   256
    (3,6)   3125
    (4,1)   46656
    (4,3)   823543
    (5,6)   16777216
    (6,3)   387420489
    (7,3)   10000000000
    (7,4)   285311670611
    (7,5)   8916100448256</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; map(sin, A)</code><code class="nohighlight hljs ansi" style="display:block;">7x7 GraphBLAS double matrix, bitmap by row
  12 entries, memory: 832 bytes

    (1,2)    0.841471
    (1,4)    0.909297
    (2,5)    0.14112
    (2,7)    -0.756802
    (3,6)    -0.958924
    (4,1)    -0.279415
    (4,3)    0.656987
    (5,6)    0.989358
    (6,3)    0.412118
    (7,3)    -0.544021
    (7,4)    -0.99999
    (7,5)    -0.536573</code></pre><p>Broadcasting functionality is also supported, <code>A .^ A</code> will lower to <code>emul(A, A, ^)</code>, and <code>sin.(A)</code> will lower to <code>map(sin, A)</code>.</p><p>Matrix multiplication, which accepts a semiring, can be called with either <code>*(max, +)(A, B)</code> or <code>*(A, B, (max, +))</code>.</p><p>We can also use functions that are not already built into SuiteSparseGraphBLAS.jl:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; M = GBMatrix([[1,2] [3,4]])</code><code class="nohighlight hljs ansi" style="display:block;">2x2 GraphBLAS int64_t matrix, full by col
  4 entries, memory: 288 bytes

    (1,1)   1
    (2,1)   2
    (1,2)   3
    (2,2)   4</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; increment(x) = x + 1</code><code class="nohighlight hljs ansi" style="display:block;">increment (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; map(increment, M)</code><code class="nohighlight hljs ansi" style="display:block;">2x2 GraphBLAS int64_t matrix, full by col
  4 entries, memory: 288 bytes

    (1,1)   2
    (2,1)   3
    (1,2)   4
    (2,2)   5</code></pre><p>Unfortunately this has a couple problems. The first is that it&#39;s slow.<br/>Compared to <code>A .+ 1</code> which lowers to <code>apply(+, A, 1)</code> the <code>map</code> call above is ~2.5x slower due to function pointer overhead.</p><div class="admonition is-warning"><header class="admonition-header">Performance of User Defined Functions</header><div class="admonition-body"><p>Operators which are not already built-in are automatically constructed using function pointers when called.  Note, however, that their performance is significantly degraded compared to built-in operators, and where possible user code should avoid this capability. See <a href="operators/#Operators">Operators</a>.</p></div></div><h2 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h2><p>Here is a quick example of two different methods of triangle counting with GraphBLAS. The methods are drawn from the LAGraph <a href="https://github.com/GraphBLAS/LAGraph">repo</a>.</p><p>Input <code>A</code> must be a square, symmetric matrix with any element type. We&#39;ll test it using the matrix from the GBArray section above, which has two triangles in its undirected form.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using SuiteSparseGraphBLAS: pair</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; function cohen(A)
         U = select(triu, A)
         L = select(tril, A)
         return reduce(+, *(L, U, (+, pair); mask=A)) ÷ 2
       end</code><code class="nohighlight hljs ansi" style="display:block;">cohen (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; function sandia(A)
         L = select(tril, A)
         return reduce(+, *(L, L, (+, pair); mask=L))
       end</code><code class="nohighlight hljs ansi" style="display:block;">sandia (generic function with 1 method)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; M = eadd(A, A&#39;, +) #Make undirected/symmetric</code><code class="nohighlight hljs ansi" style="display:block;">7x7 GraphBLAS int64_t matrix, bitmap by row
  20 entries, memory: 832 bytes

    (1,2)   1
    (1,4)   8
    (2,1)   1
    (2,5)   3
    (2,7)   4
    (3,4)   7
    (3,6)   14
    (3,7)   10
    (4,1)   8
    (4,3)   7
    (4,7)   11
    (5,2)   3
    (5,6)   8
    (5,7)   12
    (6,3)   14
    (6,5)   8
    (7,2)   4
    (7,3)   10
    (7,4)   11
    (7,5)   12</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; cohen(M)</code><code class="nohighlight hljs ansi" style="display:block;">2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; sandia(M)</code><code class="nohighlight hljs ansi" style="display:block;">2</code></pre><h1 id="Citing"><a class="docs-heading-anchor" href="#Citing">Citing</a><a id="Citing-1"></a><a class="docs-heading-anchor-permalink" href="#Citing" title="Permalink"></a></h1><p>Please cite the following papers if you use SuiteSparseGraphBLAS.jl in your work:</p><p><a href="https://doi.org/10.1145/3322125">pdf</a>:</p><pre><code class="language-bibtex hljs">    @article{10.1145/3322125,
    author = {Davis, Timothy A.},
    title = {Algorithm 1000: SuiteSparse:GraphBLAS: Graph Algorithms in the Language of Sparse Linear Algebra},
    year = {2019},
    issue_date = {December 2019},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    volume = {45},
    number = {4},
    issn = {0098-3500},
    url = {https://doi.org/10.1145/3322125},
    doi = {10.1145/3322125},
    journal = {ACM Trans. Math. Softw.},
    month = {dec},
    articleno = {44},
    numpages = {25},
    keywords = {GraphBLAS, Graph algorithms, sparse matrices}
    }</code></pre><p><a href="https://github.com/DrTimothyAldenDavis/GraphBLAS/blob/stable/Doc/toms_parallel_grb2.pdf">pdf</a>:</p><pre><code class="language-bibtex hljs">    @article{GraphBLAS7,
    author = {Davis, Timothy A.},
    title = {Algorithm 10xx: SuiteSparse:GraphBLAS: Graph Algorithms in the Language of Sparse Linear Algebra},
    year = {2022},
    journal = {ACM Trans. Math. Softw.},
    month = {(under revision)},
    note={See GraphBLAS/Doc/toms_parallel_grb2.pdf},
    keywords = {GraphBLAS, Graph algorithms, sparse matrices}
}</code></pre><p><a href="https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9622789&amp;casa_token=VPmmUD8cdFcAAAAA:NYSm3tdjrBwF53rJxo9PqVRWzXY41hE6l1MoKpBqqZC0WESFPGx6PtN1SjVf8M4x01vfPrqU&amp;tag=1">pdf</a>:</p><pre><code class="language-bibtex hljs">@inproceedings{9622789,
author={Pelletier, Michel and Kimmerer, Will and Davis, Timothy A. and Mattson, Timothy G.},
booktitle={2021 IEEE High Performance Extreme Computing Conference (HPEC)},
title={The GraphBLAS in Julia and Python: the PageRank and Triangle Centralities},
year={2021},
pages={1-7},
doi={10.1109/HPEC49654.2021.9622789},
ISSN={2643-1971},
month={Sep.}
}</code></pre></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="arrays/">Array Types »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Saturday 12 November 2022 07:14">Saturday 12 November 2022</span>. Using Julia version 1.8.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
