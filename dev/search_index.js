var documenterSearchIndex = {"docs":
[{"location":"binaryops/#Binary-Operators","page":"Binary Operators","title":"Binary Operators","text":"","category":"section"},{"location":"binaryops/","page":"Binary Operators","title":"Binary Operators","text":"Binary operators are defined on three domains D_1 times D_2 rightarrow D_3. However, the vast majority of binary operators are defined on a single domain.","category":"page"},{"location":"binaryops/","page":"Binary Operators","title":"Binary Operators","text":"BinaryOps are in almost every GraphBLAS operation. They are the primary op argument for emul, eadd, and apply. BinaryOps which are also monoids may be used in reduce. And every GraphBLAS operation which takes an accum keyword argument accepts a BinaryOp.","category":"page"},{"location":"binaryops/","page":"Binary Operators","title":"Binary Operators","text":"In 99% of cases you should pass Julia functions, which will be mapped to built-in operators, or used to create a new user-defined operator.","category":"page"},{"location":"binaryops/","page":"Binary Operators","title":"Binary Operators","text":"using SuiteSparseGraphBLAS\n\nx = GBMatrix([[1,2] [3,4]])\n\nx .+ x\neadd(x, x, +)\n\nx .^ x\nemul(x, x, ^)\n\nx2 = Float64.(x)\neadd!(x2, x, x, +; accum=/)","category":"page"},{"location":"binaryops/","page":"Binary Operators","title":"Binary Operators","text":"Internally functions are lowered like this:","category":"page"},{"location":"binaryops/","page":"Binary Operators","title":"Binary Operators","text":"using SuiteSparseGraphBLAS\n\nop = BinaryOp(+)\n\ntypedop = op(Int64, Int64)\n\neadd(GBVector([1,2]), GBVector([3,4]), typedop)","category":"page"},{"location":"binaryops/#Built-Ins","page":"Binary Operators","title":"Built-Ins","text":"","category":"section"},{"location":"binaryops/","page":"Binary Operators","title":"Binary Operators","text":"All built-in binary operators can be found below:","category":"page"},{"location":"binaryops/","page":"Binary Operators","title":"Binary Operators","text":"Julia Function GraphBLAS Name Notes\nfirst FIRST first(x, y) = x\nsecond SECOND second(x, y) = y\nany ANY any(x, y) = 1 if x or y are stored values\npair PAIR any(x, y) = 1 if x and y are stored values\n+ PLUS \n- MINUS \nrminus RMINUS \n* TIMES \n/ DIV \n\\ RDIV \n^ POW \niseq ISEQ iseq(x::T, y::T) = T(x == y)\nisne ISNE isne(x::T, y::T) = T(x != y)\nmin MIN \nmax MAX \nisgt ISGT isgt(x::T, y::T) = T(x > y)\nislt ISLT islt(x::T, y::T) = T(x < y)\nisge ISGE isge(x::T, y::T) = T(x >= y)\nisle ISLE isle(x::T, y::T) = T(x <= y)\n∨ LOR \n∧ LAND \nlxor LXOR \n== EQ \n!= NE \n> GT \n< LT \n>= GE \n<= LE \nxnor LXNOR \natan ATAN2 \nhypot HYPOT \nfmod FMOD \nrem REMAINDER \nldexp LDEXP \ncopysign COPYSIGN \ncomplex CMPLX \n| BOR \n& BAND \n⊻ BXOR \nbget BGET \nbset BSET \nbclr BCLR \n>> BSHIFT \nfirsti0 FIRSTI firsti0(A[i,j], B[k,l]) = i - 1\nfirsti FIRSTI1 firsti(A[i,j], B[k,l]) = i\nfirstj0 FIRSTJ firstj0(A[i,j], B[k,l]) = j - 1\nfirstj FIRSTJ1 firstj(A[i,j], B[k,l]) = j\nsecondi0 SECONDI secondi0(A[i,j], B[k,l]) = k - 1\nsecondi SECONDI1 secondi(A[i,j], B[k,l]) = k\nsecondj0 SECONDJ secondj0(A[i,j], B[k,l]) = l - 1\nsecondj SECONDJ1 secondj(A[i,j], B[k,l]) = l","category":"page"},{"location":"semirings/#Semirings","page":"Semirings","title":"Semirings","text":"","category":"section"},{"location":"semirings/","page":"Semirings","title":"Semirings","text":"A semiring in GraphBLAS is a set of three domains D_1, D_2, and D_3, along with two binary operators and an identity element mathbb0. ","category":"page"},{"location":"semirings/","page":"Semirings","title":"Semirings","text":"The first operator, oplus or \"add\" is a commutative and associative monoid defined on D_3 times D_3 rightarrow D_3. The identity of the monoid is mathbb0. See Monoids for more information.","category":"page"},{"location":"semirings/","page":"Semirings","title":"Semirings","text":"The second, otimes or \"multiply\", is a binary operator defined on D_1 times D_2 rightarrow D_3. See Binary Operators for more information. ","category":"page"},{"location":"semirings/","page":"Semirings","title":"Semirings","text":"A semiring is denoted by a tuple (D_1 D_2 D_3 oplus otimes mathbb0). However in the vast majority of cases D_1 = D_2 = D_3 so this is often shortened to (oplus otimes).","category":"page"},{"location":"semirings/","page":"Semirings","title":"Semirings","text":"Semirings are used in a single GraphBLAS operation, mul!.","category":"page"},{"location":"semirings/#Passing-to-Functions","page":"Semirings","title":"Passing to Functions","text":"","category":"section"},{"location":"semirings/","page":"Semirings","title":"Semirings","text":"mul! and * are the only functions which accept semirings, and the best method to do so is a tuple of binary functions like *(A, B, (max, +)). An operator form is also available as *(min, +)(A, B).","category":"page"},{"location":"semirings/","page":"Semirings","title":"Semirings","text":"Semiring objects may be constructed in a similar fashion: Semiring(max, +).","category":"page"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"setfill\nsetfill!\nmask\nmask!\ngbset\nDescriptor\nSuiteSparseGraphBLAS.set_lib!\nempty!","category":"page"},{"location":"utilities/#SuiteSparseGraphBLAS.setfill","page":"Utilities","title":"SuiteSparseGraphBLAS.setfill","text":"setfill(A::AbstractGBArray{T, N, F}, x::F2)\n\nCreate a new AbstractGBArray with the same underlying data but a new fill x. The fill type of A and the type of x may be different.\n\n\n\n\n\n","category":"function"},{"location":"utilities/#SuiteSparseGraphBLAS.setfill!","page":"Utilities","title":"SuiteSparseGraphBLAS.setfill!","text":"setfill!(A::AbstractGBArray{T, N, F}, x::F)\n\nModify the fill value of A.  The fill type of A and the type of x must be the same.\n\n\n\n\n\n","category":"function"},{"location":"utilities/#SuiteSparseGraphBLAS.mask!","page":"Utilities","title":"SuiteSparseGraphBLAS.mask!","text":"mask!(C::GBArray, A::GBArray, mask::GBArray)\n\nApply a mask to matrix A, storing the results in C.\n\n\n\n\n\n","category":"function"},{"location":"utilities/#SuiteSparseGraphBLAS.gbset","page":"Utilities","title":"SuiteSparseGraphBLAS.gbset","text":"gbset(A::GBArray, option, value)\ngbset(option, value)\n\nSet an option either for a specific GBArray, or globally. The commonly used options are:     - :format = [RowMajor() | ColMajor()]: The global default or array specific     column major or row major ordering.     - :nthreads = [Integer]: The global number of OpenMP threads to use.     - :burble = [Bool]: Print diagnostic output.     - :sparsity_control = [:full | :bitmap | :sparse | :hypersparse]: Set the sparsity of a     single GBArray.\n\n\n\n\n\n","category":"function"},{"location":"utilities/#SuiteSparseGraphBLAS.Descriptor","page":"Utilities","title":"SuiteSparseGraphBLAS.Descriptor","text":"Descriptor\n\nContext object which may be optionally passed to many SuiteSparse:GraphBLAS functions.\n\nSee the SuiteSparse:GraphBLAS User Guide or the SuiteSparseGraphBLAS.jl docs for more information.\n\nOptions\n\nnthreads::Int = Sys.CPU_THREADS ÷ 2: Specify the maximum number of threads to be used by\n\na function, defaults to avoid hyperthreading, which is typically most performant.\n\nreplace_output: Clear the output array before assignment.\nstructural_mask::Bool: Utilize the structure of the mask argument, rather than its values.\ncomplement_mask::Bool: Values which are true in the complement of the mask will be kept.\n\n\n\n\n\n","category":"type"},{"location":"utilities/#SuiteSparseGraphBLAS.set_lib!","page":"Utilities","title":"SuiteSparseGraphBLAS.set_lib!","text":"set_lib!(path; export_prefs::Bool = false)\n\nSet the shared library path for SuiteSparse:GraphBLAS. Set to \"default\" to use the provided artifact.\n\n\n\n\n\n","category":"function"},{"location":"utilities/#Base.empty!","page":"Utilities","title":"Base.empty!","text":"empty!(v::GBVector)\nempty!(A::GBMatrix)\n\nClear all the entries from the GBArray. Does not modify the type or dimensions.\n\n\n\n\n\n","category":"function"},{"location":"performance/#Performance-Tips","page":"Performance Tips","title":"Performance Tips","text":"","category":"section"},{"location":"udfs/#User-Defined-Operators","page":"User Defined Operators","title":"User Defined Operators","text":"","category":"section"},{"location":"udfs/","page":"User Defined Operators","title":"User Defined Operators","text":"warning: Experimental\nThis is still a work in progress, and subject to change. Please open an issue if you find any problems!","category":"page"},{"location":"udfs/","page":"User Defined Operators","title":"User Defined Operators","text":"GraphBLAS supports users to supply functions as operators. Constructors exported are:","category":"page"},{"location":"udfs/","page":"User Defined Operators","title":"User Defined Operators","text":"UnaryOp(name::String, fn::Function, [type | types | ztype, xtype | ztypes, xtypes])\nBinaryOp(name::String, fn::Function, [type | types | ztype, xtype | ztypes, xtypes])\nMonoid(name::String, binop::Union{AbstractBinaryOp, GrB_BinaryOp}, id::T, terminal::T = nothing): all types must be the same.\nSemiring(name::String, add::[GrB_Monoid | AbstractMonoid], mul::[GrB_BinaryOp | AbstractBinaryOp])","category":"page"},{"location":"udfs/","page":"User Defined Operators","title":"User Defined Operators","text":"GrB_ prefixed arguments are typed operators, such as the result of UnaryOps.COS[Float64]. Type arguments may be single types or vectors of types. If no type is supplied to UnaryOp or BinaryOp they will default to constructing typed operators for all the built-in primitive types.","category":"page"},{"location":"udfs/","page":"User Defined Operators","title":"User Defined Operators","text":"The fn arguments to UnaryOp and BinaryOp must have one or two arguments respectively.","category":"page"},{"location":"udfs/","page":"User Defined Operators","title":"User Defined Operators","text":"danger: Performance\nDue to the nature of the underlying C library user-defined operators may be significantly slower than their built-in counterparts. When possible use the built-in operators, or combinations of them.","category":"page"},{"location":"udfs/","page":"User Defined Operators","title":"User Defined Operators","text":"note: Where to Find User-Defined Operators\nThe constructors for an operator add that operator to the submodule for that operator type. For instance UnaryOp(minus, -, Int64, Int64) will add UnaryOps.minus.","category":"page"},{"location":"selectops/#Select-Operators","page":"Select Operators","title":"Select Operators","text":"","category":"section"},{"location":"selectops/","page":"Select Operators","title":"Select Operators","text":"A SelectOp is effectively a binary or unary operation which is able to access the location of an element as well as its value. They define predicates for use with the select function.","category":"page"},{"location":"selectops/","page":"Select Operators","title":"Select Operators","text":"Applying select with a SelectOp will always return a result with the same type and shape as its argument.","category":"page"},{"location":"selectops/#Built-Ins","page":"Select Operators","title":"Built-Ins","text":"","category":"section"},{"location":"selectops/","page":"Select Operators","title":"Select Operators","text":"Built-in SelectOps can be found in the SelectOps submodule. However users should pass the equivalent Julia function when possible.","category":"page"},{"location":"selectops/","page":"Select Operators","title":"Select Operators","text":"SuiteSparseGraphBLAS.TRIL\nSuiteSparseGraphBLAS.TRIU\nSuiteSparseGraphBLAS.DIAG\nSuiteSparseGraphBLAS.OFFDIAG\nSuiteSparseGraphBLAS.NONZERO\nSuiteSparseGraphBLAS.NE\nSuiteSparseGraphBLAS.EQ\nSuiteSparseGraphBLAS.GT\nSuiteSparseGraphBLAS.GE\nSuiteSparseGraphBLAS.LT\nSuiteSparseGraphBLAS.LE","category":"page"},{"location":"selectops/#SuiteSparseGraphBLAS.TRIL","page":"Select Operators","title":"SuiteSparseGraphBLAS.TRIL","text":"select(SuiteSparseGraphBLAS.TRIL, A, k=0)\nselect(tril, A, k=0)\n\nSelect the entries on or below the kth diagonal of A.\n\nSee also: LinearAlgebra.tril\n\n\n\n\n\n","category":"constant"},{"location":"selectops/#SuiteSparseGraphBLAS.TRIU","page":"Select Operators","title":"SuiteSparseGraphBLAS.TRIU","text":"select(SuiteSparseGraphBLAS.TRIU, A, k=0)\nselect(triu, A, k=0)\n\nSelect the entries on or above the kth diagonal of A.\n\nSee also: LinearAlgebra.triu\n\n\n\n\n\n","category":"constant"},{"location":"selectops/#SuiteSparseGraphBLAS.DIAG","page":"Select Operators","title":"SuiteSparseGraphBLAS.DIAG","text":"select(DIAG, A, k=0)\n\nSelect the entries on the kth diagonal of A.\n\nSee also: LinearAlgebra.diag\n\n\n\n\n\n","category":"constant"},{"location":"selectops/#SuiteSparseGraphBLAS.OFFDIAG","page":"Select Operators","title":"SuiteSparseGraphBLAS.OFFDIAG","text":"select(OFFDIAG, A, k=0)\n\nSelect the entries not on the kth diagonal of A.\n\n\n\n\n\n","category":"constant"},{"location":"selectops/#SuiteSparseGraphBLAS.NONZERO","page":"Select Operators","title":"SuiteSparseGraphBLAS.NONZERO","text":"select(NONZERO, A)\nselect(nonzeros, A)\n\nSelect all entries in A with nonzero value.\n\n\n\n\n\n","category":"constant"},{"location":"selectops/#SuiteSparseGraphBLAS.NE","page":"Select Operators","title":"SuiteSparseGraphBLAS.NE","text":"select(NE, A, k)\nselect(!=, A, k)\n\nSelect all entries not equal to k.\n\n\n\n\n\n","category":"constant"},{"location":"selectops/#SuiteSparseGraphBLAS.EQ","page":"Select Operators","title":"SuiteSparseGraphBLAS.EQ","text":"select(EQ, A, k)\nselect(==, A, k)\n\nSelect all entries equal to k.\n\n\n\n\n\n","category":"constant"},{"location":"selectops/#SuiteSparseGraphBLAS.GT","page":"Select Operators","title":"SuiteSparseGraphBLAS.GT","text":"select(GT, A, k)\nselect(>, A, k)\n\nSelect all entries greater than k.\n\n\n\n\n\n","category":"constant"},{"location":"selectops/#SuiteSparseGraphBLAS.GE","page":"Select Operators","title":"SuiteSparseGraphBLAS.GE","text":"select(GE, A, k)\nselect(>=, A, k)\n\nSelect all entries greater than or equal to k.\n\n\n\n\n\n","category":"constant"},{"location":"selectops/#SuiteSparseGraphBLAS.LT","page":"Select Operators","title":"SuiteSparseGraphBLAS.LT","text":"select(LT, A, k)\nselect(<, A, k)\n\nSelect all entries less than k.\n\n\n\n\n\n","category":"constant"},{"location":"selectops/#SuiteSparseGraphBLAS.LE","page":"Select Operators","title":"SuiteSparseGraphBLAS.LE","text":"select(LE, A, k)\nselect(<=, A, k)\n\nSelect all entries less than or equal to k.\n\n\n\n\n\n","category":"constant"},{"location":"monoids/#Monoids","page":"Monoids","title":"Monoids","text":"","category":"section"},{"location":"monoids/","page":"Monoids","title":"Monoids","text":"A monoid is made up of a set or domain T and a binary operator z = f(x y) operating on the same domain, T times T rightarrow T. This binary operator must be associative, that is f(a f(b c)) = f(f(a b) c) is always true. Associativity is important for operations like reduce and the multiplication step of mul!.","category":"page"},{"location":"monoids/","page":"Monoids","title":"Monoids","text":"The operator is also be equipped with an identity such that f(x 0) = f(0 x) = x. Some monoids are equipped with a terminal or annihilator such that z = f(z x) forall x.","category":"page"},{"location":"monoids/","page":"Monoids","title":"Monoids","text":"Monoids are used primarily in the reduce(@ref) operation. Their other use is as a component of semirings in the mul! operation.","category":"page"},{"location":"monoids/#Built-Ins","page":"Monoids","title":"Built-Ins","text":"","category":"section"},{"location":"monoids/","page":"Monoids","title":"Monoids","text":"Julia Function GraphBLAS Name Notes\nmax MAX_MONOID identity: typemax, terminal: typemin\nmin MIN_MONOID identity: typemin, terminal: typemax\n+ PLUS_MONOID identity: zero\n* TIMES_MONOID identity: one, terminal: zero (terminal only for non-Float types)\nany ANY_MONOID identity, terminal: any value in domain\n& BAND_MONOID identity: typemax, terminal: zero\n| BOR_MONOID identity: zero, terminal: typemax\n⊻ BXOR_MONOID identity: zero\nlxor LXOR_MONOID identity: false\n== LXNOR_MONOID identity: true\n∨ LOR_MONOID identity: false, term: true\n∧ LAND_MONOID identity: true, term: false\n  \n  \n  ","category":"page"},{"location":"unaryops/#Unary-Operators","page":"Unary Operators","title":"Unary Operators","text":"","category":"section"},{"location":"unaryops/","page":"Unary Operators","title":"Unary Operators","text":"UnaryOps are fairly straightforward z = f(x) and their meaning should be clear from the name in most cases. ","category":"page"},{"location":"unaryops/","page":"Unary Operators","title":"Unary Operators","text":"UnaryOps are used only in the map and apply functions.","category":"page"},{"location":"unaryops/","page":"Unary Operators","title":"Unary Operators","text":"using SuiteSparseGraphBLAS\n\nx = GBVector([1.5, 0, pi])\n\ny = map(sin, x)\n\nmap(asin, y)","category":"page"},{"location":"unaryops/","page":"Unary Operators","title":"Unary Operators","text":"Internally functions are lowered like this:","category":"page"},{"location":"unaryops/","page":"Unary Operators","title":"Unary Operators","text":"using SuiteSparseGraphBLAS\n\nop = UnaryOp(sin)\n\ntypedop = op(Float64)\n\nmap(typedop, GBVector([1.5, 0, pi]))","category":"page"},{"location":"unaryops/#Built-Ins","page":"Unary Operators","title":"Built-Ins","text":"","category":"section"},{"location":"unaryops/","page":"Unary Operators","title":"Unary Operators","text":"The following functions are built into SuiteSparse:GraphBLAS. They are, much faster than arbitrary Julia functions and should be used when possible.","category":"page"},{"location":"unaryops/","page":"Unary Operators","title":"Unary Operators","text":"Julia Function GraphBLAS Name Notes\nidentity IDENTITY \n- AINV \ninv MINV \none ONE \n! LNOT \nabs ABS \n~ BNOT \npositioni POSITIONI \npositionj POSITIONJ \nsqrt SQRT \nlog LOG \nexp EXP \nlog10 LOG10 \nlog2 LOG2 \nexp2 EXP2 \nexpm1 EXPM1 \nlog1p LOG1P \nsin SIN \ncos COS \ntan TAN \nasin ASIN \nacos ACOS \natan ATAN \nsinh SINH \ncosh COSH \ntanh TANH \nasinh ASINH \nacosh ACOSH \natanh ATANH \nsign SIGNUM \nceil CEIL \nfloor FLOOR \nround ROUND \ntrunc TRUNC \nSpecialFunctions.lgamma LGAMMA \nSpecialFunctions.gamma TGAMMA \nerf ERF \nerfc ERFC \nfrexpx FREXPX \nfrexpe FREXPE \nisinf ISINF \nisnan ISNAN \nisfinite ISFINITE \nconj CONJ \nreal CREAL \nimag CIMAG \nangle CARG ","category":"page"},{"location":"arrays/#Array-Types","page":"Array Types","title":"Array Types","text":"","category":"section"},{"location":"arrays/","page":"Array Types","title":"Array Types","text":"There are two primary array types in SuiteSparseGraphBLAS.jl: GBVector and GBMatrix, as well as a few specialized versions of those array types. The full type hierarchy is:","category":"page"},{"location":"arrays/","page":"Array Types","title":"Array Types","text":"AbstractGBArray{T, N, F} <: AbstractSparseArray{T, N}\n ├ N = 2 ─ AbstractGBMatrix{T, F} \n │   ├─ GBMatrix{T, F}\n │   └─ OrientedGBMatrix{T, F, O}\n └ N = 1 ─ AbstractGBVector{T, F}\n     └─ GBVector{T, F}","category":"page"},{"location":"arrays/","page":"Array Types","title":"Array Types","text":"The T parameter is the element type of the array, N is the dimensionality, F is the type of the fill value (often Nothing or T). The OrientedGBMatrix restricts the orientation to the parameter O which is either ByRow() or ByCol(). ","category":"page"},{"location":"arrays/","page":"Array Types","title":"Array Types","text":"All of these types attempt to implement most of the AbstractArray interface, and the relevant parts of the SparseArrays interface.","category":"page"},{"location":"arrays/#GBMatrix","page":"Array Types","title":"GBMatrix","text":"","category":"section"},{"location":"arrays/","page":"Array Types","title":"Array Types","text":"The GBMatrix is an opaque sparse matrix structure, which adapts to the sparsity of a matrix by changing the implementation internally. There are 4 different internal representations, all stored in either row or column orientation:","category":"page"},{"location":"arrays/","page":"Array Types","title":"Array Types","text":"Dense - Equivalent to a Julia Matrix\nBitmap - 2 dense arrays, one storing booleans in the pattern of the matrix, the other storing the values.\nSparse Compressed - Compressed Sparse Column (CSC) or Compressed Sparse Row(CSR)\nDoubly Compressed or Hypersparse - Doubly Compressed Sparse Column (DCSC or Hypersparse CSC) and Doubly Compressed Sparse Row (DCSR or Hypersparse CSR). See this paper for more information: pdf.","category":"page"},{"location":"arrays/","page":"Array Types","title":"Array Types","text":"Additionally a when the stored values in a GBMatrix are uniform the value array may be stored in the iso version of one of the formats above. Rather than storing the full value array, an iso GBMatrix will only store the single scalar to improve performance. This is useful for matrices like the unweighted adjacency matrix, where all stored values may be true. ","category":"page"},{"location":"arrays/","page":"Array Types","title":"Array Types","text":"Users should never need to directly interact with the underlying storage format, SuiteSparse:GraphBLAS will automatically convert between them as necessary.","category":"page"},{"location":"arrays/#Construction","page":"Array Types","title":"Construction","text":"","category":"section"},{"location":"arrays/","page":"Array Types","title":"Array Types","text":"There are several methods to construct GBArrays. Shown here are empty construction, conversion from a dense matrix and a sparse matrix, and coordinate form with uniform or iso coefficients. ","category":"page"},{"location":"arrays/","page":"Array Types","title":"Array Types","text":"using SuiteSparseGraphBLAS\nusing SparseArrays","category":"page"},{"location":"arrays/","page":"Array Types","title":"Array Types","text":"x = GBMatrix{Bool}(20_000_000, 50_000)\nx = GBMatrix([[1,2] [3,4]])\nx = GBMatrix(sprand(100, 100, 0.5); fill = 0.0)\nx = GBMatrix(\n    rand(1:50_000, 5000), rand(1:500_000, 5000), 1; \n    ncols = 500_000, nrows = 500_000\n)","category":"page"},{"location":"arrays/","page":"Array Types","title":"Array Types","text":"GBMatrix\nSuiteSparseGraphBLAS.GBMatrix(::Matrix)","category":"page"},{"location":"arrays/#SuiteSparseGraphBLAS.GBMatrix","page":"Array Types","title":"SuiteSparseGraphBLAS.GBMatrix","text":"GBMatrix{T, F} <: AbstractSparseArray{T, UInt64, 2}\n\nTwo-dimensional GraphBLAS array with elements of type T. F is the type of the fill-value,  which is typically Nothing or T.  Internal representation is specified as opaque, but in this implementation is stored as one of  the following in either row or column orientation:\n\n1. Dense\n2. Bitmap\n3. Sparse Compressed\n4. Hypersparse\n\nThe storage type is automatically determined by the library.\n\n\n\n\n\n","category":"type"},{"location":"arrays/#SuiteSparseGraphBLAS.GBMatrix-Tuple{Matrix}","page":"Array Types","title":"SuiteSparseGraphBLAS.GBMatrix","text":"GBMatrix{T}(nrows, ncols; fill = nothing)\n\nCreate a GBMatrix of the specified size.\n\n\n\n\n\nGBMatrix(I, J, X; combine = +, nrows = maximum(I), ncols = maximum(J); fill = nothing)\n\nCreate an nrows x ncols GBMatrix M such that M[I[k], J[k]] = X[k]. The combine function defaults to | for booleans and + for nonbooleans.\n\n\n\n\n\nGBMatrix(I, J, x; nrows = maximum(I), ncols = maximum(J); fill = nothing)\n\nCreate an nrows x ncols GBMatrix M such that M[I[k], J[k]] = x. The resulting matrix is \"iso-valued\" such that it only stores x once rather than once for each index.\n\n\n\n\n\n","category":"method"},{"location":"arrays/#GBVector","page":"Array Types","title":"GBVector","text":"","category":"section"},{"location":"arrays/","page":"Array Types","title":"Array Types","text":"A GBVector is the one-dimensional equivalent of the GBMatrix, and internally a GBVector is represented in exactly the same fashion. However, they are always column-oriented. ","category":"page"},{"location":"arrays/#Construction-2","page":"Array Types","title":"Construction","text":"","category":"section"},{"location":"arrays/","page":"Array Types","title":"Array Types","text":"v = GBVector{ComplexF32}(100)\nv = GBMatrix(rand(ComplexF64, 3); fill = nothing)\nv = GBVector(sprand(Bool, 100_000_000, 0.001))","category":"page"},{"location":"arrays/","page":"Array Types","title":"Array Types","text":"GBVector\nSuiteSparseGraphBLAS.GBVector(::Vector)","category":"page"},{"location":"arrays/#SuiteSparseGraphBLAS.GBVector","page":"Array Types","title":"SuiteSparseGraphBLAS.GBVector","text":"GBVector{T, F} <: AbstractSparseArray{T, UInt64, 1}\n\nOne-dimensional GraphBLAS array with elements of type T. F is the type of the fill-value,  which is typically Nothing or T.  Internal representation is specified as opaque, but may be either a dense vector, bitmap vector, or  compressed sparse vector.\n\nSee also: GBMatrix.\n\n\n\n\n\n","category":"type"},{"location":"arrays/#SuiteSparseGraphBLAS.GBVector-Tuple{Vector}","page":"Array Types","title":"SuiteSparseGraphBLAS.GBVector","text":"GBVector{T}(n; fill = nothing)\n\n\n\n\n\nGBVector(I::AbstractVector, X::AbstractVector{T}; fill = nothing)\n\nCreate a GBVector from a vector of indices I and a vector of values X.\n\n\n\n\n\nGBVector(I, x; nrows = maximum(I) fill = nothing)\n\nCreate an GBVector v from coordinates I such that M[I] = x . The resulting vector is \"iso-valued\" such that it only stores x once rather than once for each index.\n\n\n\n\n\nGBVector(n, x; fill = nothing)\n\nCreate an n length dense GBVector v such that M[:] = x. The resulting vector is \"iso-valued\" such that it only stores x once rather than once for each index.\n\n\n\n\n\n","category":"method"},{"location":"arrays/#Indexing","page":"Array Types","title":"Indexing","text":"","category":"section"},{"location":"arrays/","page":"Array Types","title":"Array Types","text":"The usual AbstractArray and SparseArray indexing capabilities are available. Including indexing by scalars, vectors, and ranges.","category":"page"},{"location":"arrays/","page":"Array Types","title":"Array Types","text":"danger: Indexing Structural Zeros\nWhen indexing a SparseMatrixCSC from SparseArrays a structural, or implicit, zero will be returned as zero(T) where T is the element type of the matrix.When indexing a GBArray structural zeros default to nothing. While this is a significant departure from the SparseMatrixCSC it more closely matches the GraphBLAS spec, and enables the consuming method to determine the value of implicit zeros in the presence of explicit zeros. For instance with an element type of Float64 you may want the implicit zero to be 0.0, -∞ or +∞ depending on your algorithm. In addition, for graph algorithms there may be a distinction between an implicit zero, indicating the lack of an edge between two vertices in an adjacency matrix, and an explicit zero where the edge exists but has a 0 weight.However, many functions outside of GraphBLAS will throw an error if they receive nothing from an indexing operation. To accomodate these functions the user may set the fill value for an AbstractGBArray on construction and with setfill and setfill!.","category":"page"},{"location":"arrays/","page":"Array Types","title":"Array Types","text":"A = GBMatrix([1,1,2,2,3,4,4,5,6,7,7,7], [2,4,5,7,6,1,3,6,3,3,4,5], [1:12...])\nSparseMatrixCSC(A)\nA[4]\nA[1,2]\nA[[1,3,5,7], :]\nA[1:2:7, :]\nA[:,:]\nA[:, 5]","category":"page"},{"location":"arrays/","page":"Array Types","title":"Array Types","text":"The functionality illustrated above extends to GBVector as well.","category":"page"},{"location":"arrays/#Transpose","page":"Array Types","title":"Transpose","text":"","category":"section"},{"location":"arrays/","page":"Array Types","title":"Array Types","text":"The lazy Julia transpose is available, and the adjoint operator ' is also overloaded to be equivalent.","category":"page"},{"location":"arrays/","page":"Array Types","title":"Array Types","text":"danger: Adjoint vs Transpose\nThe adjoint operator ' currently transposes matrices rather than performing the conjugate transposition. In the future this will change to the eager adjoint for complex types, but currently you must do map(conj, A') to achieve this.","category":"page"},{"location":"operations/#Operations","page":"Operations","title":"Operations","text":"","category":"section"},{"location":"operations/","page":"Operations","title":"Operations","text":"GraphBLAS operations cover most of the typical linear algebra operations on arrays in Julia.","category":"page"},{"location":"operations/#Correspondence-of-GraphBLAS-C-functions-and-Julia-functions","page":"Operations","title":"Correspondence of GraphBLAS C functions and Julia functions","text":"","category":"section"},{"location":"operations/","page":"Operations","title":"Operations","text":"GraphBLAS Operation Julia\nmxm, mxv, vxm bf C langle M rangle = C odot AB mul! or *\neWiseMult bf C langle M rangle = C odot (A otimes B) emul[!] or . broadcasting\neWiseAdd bf C langle M rangle = C odot (A oplus  B) eadd[!]\nextract bf C langle M rangle = C odot A(IJ) extract[!], getindex\nsubassign bf C (IJ) langle M rangle = C(IJ) odot A subassign[!] or setindex!\nassign bf C langle M rangle (IJ) = C(IJ) odot A assign[!]\napply bf C langle M rangle = C odot fbf (A) apply[!], map[!] or . broadcasting\n bf C langle M rangle = C odot f(bf Ay) \n bf C langle M rangle = C odot f(xbf A) \nselect bf C langle M rangle = C odot f(bf Ak) select[!]\nreduce bf w langle m rangle = w odot oplus_j bf A(j) reduce[!]\n s = s odot oplus_ij  bf A(ij) \ntranspose bf C langle M rangle = C odot A^sf T gbtranspose[!], lazy: transpose, '\nkronecker bf C langle M rangle = C odot textkron(A B) kron[!]","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"where bf M is a GBArray mask, odot is a binary operator for accumulating into bf C, and otimes and oplus are binary operators or monoids. ","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"note: assign vs subassign\nsubassign is equivalent to assign except that the mask in subassign has the dimensions of bf C(IJ) vs the dimensions of C for assign. Elements outside of the mask will also never be modified by subassign. See the GraphBLAS User Guide for more details.","category":"page"},{"location":"operations/#Common-arguments","page":"Operations","title":"Common arguments","text":"","category":"section"},{"location":"operations/","page":"Operations","title":"Operations","text":"The operations typically accept one of the following types in the op argument.","category":"page"},{"location":"operations/#op-Function:","page":"Operations","title":"op - Function:","text":"","category":"section"},{"location":"operations/","page":"Operations","title":"Operations","text":"This argument determines oplus, otimes, or f in the table above as well as the semiring used in mul. See Operators for more information.","category":"page"},{"location":"operations/#desc-Descriptor:","page":"Operations","title":"desc - Descriptor:","text":"","category":"section"},{"location":"operations/","page":"Operations","title":"Operations","text":"The descriptor argument allows the user to modify the operation in some fashion. A new Descriptor can be created with default settings as: d = Descriptor(). The most common options are:","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"desc.[transpose_input1 | transpose_input2] == [true | false]:","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"Typically you should use Julia's built-in transpose functionality.","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"desc.complement_mask == [true | false]: ","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"If complement_mask is set the presence/truth value of the mask is complemented.","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"desc.structural_mask == [true | false]:","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"If structural_mask is set the presence of a value in the mask determines the presence of values in the output, rather than the actual value of the mask.","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"desc.replace_output == [true | false]:","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"If this option is set the operation will replace all values in the output matrix after the accumulation step.  If an index is found in the output matrix, but not in the results of the operation it will be set to nothing. ","category":"page"},{"location":"operations/#accum-Function:","page":"Operations","title":"accum - Function:","text":"","category":"section"},{"location":"operations/","page":"Operations","title":"Operations","text":"The accum keyword argument provides a binary operation to accumulate results into the result array.  The accumulation step is performed before masking.","category":"page"},{"location":"operations/#mask-GBArray:","page":"Operations","title":"mask - GBArray:","text":"","category":"section"},{"location":"operations/","page":"Operations","title":"Operations","text":"The mask keyword argument determines whether each index from the result of an operation appears in the output.  The mask may be structural, where the presence of a value indicates the mask is true, or valued where the value of the mask indicates its truth value.  The mask may also be complemented. These options are controlled by the desc argument.","category":"page"},{"location":"operations/#Operation-Documentation","page":"Operations","title":"Operation Documentation","text":"","category":"section"},{"location":"operations/","page":"Operations","title":"Operations","text":"All non-mutating operations below support a mutating form by adding an output array as the first argument as well as the ! function suffix. ","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"*\nemul\nemul!\neadd\neadd!\nextract\nsubassign!\nassign!\napply\nselect\nBase.reduce\ngbtranspose\nLinearAlgebra.kron\nmask","category":"page"},{"location":"operations/#Base.:*","page":"Operations","title":"Base.:*","text":"*(A::GBArray, B::GBArray, op=(+,*); kwargs...)::GBArray\n\nMultiply two GBArrays A and B using a semiring, which defaults to the arithmetic semiring +.*.\n\nEither operand may be transposed using ' or transpose(A) provided the dimensions match.\n\nThe mutating form, mul!(C, A, B, op; kwargs...) is identical except it stores the result in C::GBVecOrMat.\n\nThe operator syntax A * B can be used when the default semiring is desired, and *(max, +)(A, B) can be used otherwise.\n\nArguments\n\nA, B::GBArray: A GBVector or GBMatrix, possibly transposed.\nop::Union{Tuple{Function, Function}, AbstractSemiring}: the semiring used for matrix multiplication. May be passed as a tuple of functions, or an AbstractSemiring found in the Semirings submodule.\n\nKeywords\n\nmask::Union{Nothing, GBArray} = nothing: optional mask which determines the output pattern.\naccum::Union{Nothing, Function, AbstractBinaryOp} = nothing: optional binary accumulator   operation such that C[i,j] = accum(C[i,j], T[i,j]) where T is the result of this function before accum is applied.\ndesc::Union{Nothing, Descriptor}\n\nReturns\n\nGBArray: The output matrix whose eltype is determined by A and B or the semiring   if a type specific semiring is provided.\n\n\n\n\n\n","category":"function"},{"location":"operations/#SuiteSparseGraphBLAS.emul","page":"Operations","title":"SuiteSparseGraphBLAS.emul","text":"emul(A::GBArray, B::GBArray, op = *; kwargs...)::GBMatrix\n\nApply the binary operator op elementwise on the set intersection of A and B. When op = * this is equivalent to A .* B, however any binary operator may be substituted.\n\nThe pattern of the result is the set intersection of A and B. For a set union equivalent see eadd.\n\nArguments\n\nA, B::GBArray: A GBVector or GBMatrix, possibly transposed.\nop::Union{Function, AbstractBinaryOp, Monoid} = *: the binary operation which is   applied such that C[i,j] = op(A[i,j], B[i,j]) for all i,j present in both A and B.\n\nKeywords\n\nmask::Union{Nothing, GBVecOrMat} = nothing: optional mask.\naccum::Union{Nothing, AbstractBinaryOp} = nothing: binary accumulator operation   where C[i,j] = accum(C[i,j], T[i,j]) where T is the result of this function before accum is applied.\ndesc = nothing\n\nReturns\n\nGBVecOrMat: Output GBVector or GBMatrix whose eltype is determined by the eltype of   A and B or the binary operation if a type specific operation is provided.\n\n\n\n\n\n","category":"function"},{"location":"operations/#SuiteSparseGraphBLAS.emul!","page":"Operations","title":"SuiteSparseGraphBLAS.emul!","text":"emul!(C::GBArray, A::GBArray, B::GBArray, op = *; kwargs...)::GBArray\n\nApply the binary operator op elementwise on the set intersection of A and B. Store or accumulate the result into C. When op = * this is equivalent to A .* B, however any binary operator may be substituted.\n\nThe pattern of the result is the set intersection of A and B. For a set union equivalent see eadd!.\n\nArguments\n\nC::GBArray: the output vector or matrix.\nA, B::GBArray: A GBVector or GBMatrix, possibly transposed.\nop::Union{Function, AbstractBinaryOp, Monoid} = *: the binary operation which is   applied such that C[i,j] = op(A[i,j], B[i,j]) for all i,j present in both A and B.\n\nKeywords\n\nmask::Union{Nothing, GBVecOrMat} = nothing: optional mask.\naccum::Union{Nothing, Function, AbstractBinaryOp} = nothing: binary accumulator operation   such that C[i,j] = accum(C[i,j], T[i,j]) where T is the result of this function before   accum is applied.\ndesc::Union{Nothing, Descriptor} = nothing\n\n\n\n\n\n","category":"function"},{"location":"operations/#SuiteSparseGraphBLAS.eadd","page":"Operations","title":"SuiteSparseGraphBLAS.eadd","text":"eadd(A::GBArray, B::GBArray, op = +; kwargs...)::GBVecOrMat\n\nApply the binary operator op elementwise on the set union of A and B. When op = + this is equivalent to A .+ B, however any binary operation may be substituted.\n\nNote that the behavior of A[i,j] op B[i,j] may be unintuitive when one operand is an implicit zero. The explicit operand passes through the function. So A[i,j] op B[i,j] where B[i,j] is an implicit zero returns A[i,j] not A[i,j] op zero(T).\n\nFor a set intersection equivalent see emul.\n\nArguments\n\nA, B::GBArray: A GBVector or GBMatrix, possibly transposed.\nop::Union{Function, AbstractBinaryOp, Monoid} = +: the binary operation which is   applied such that C[i,j] = op(A[i,j], B[i,j]) for all i,j present in either A and B.\n\nKeywords\n\nmask::Union{Nothing, GBVecOrMat} = nothing: optional mask.\naccum::Union{Nothing, Function, AbstractBinaryOp} = nothing: binary accumulator operation   such that C[i,j] = accum(C[i,j], T[i,j]) where T is the result of this function before accum is applied.\ndesc::Union{Nothing, Descriptor} = nothing\n\n\n\n\n\n","category":"function"},{"location":"operations/#SuiteSparseGraphBLAS.eadd!","page":"Operations","title":"SuiteSparseGraphBLAS.eadd!","text":"eadd!(C::GBVecOrMat, A::GBArray, B::GBArray, op = +; kwargs...)::GBVecOrMat\n\nApply the binary operator op elementwise on the set union of A and B. Store or accumulate the result into C. When op = + this is equivalent to A .+ B, however any binary operation may be substituted.\n\nNote that the behavior of A[i,j] op B[i,j] may be unintuitive when one operand is an implicit zero. The explicit operand passes through the function. So A[i,j] op B[i,j] where B[i,j] is an implicit zero returns A[i,j] not A[i,j] op zero(T).\n\nFor a set intersection equivalent see emul!.\n\nArguments\n\nC::GBArray: the output vector or matrix.\nA, B::GBArray: A GBVector or GBMatrix, possibly transposed.\nop::Union{Function, AbstractBinaryOp, Monoid} = +: the binary operation which is   applied such that C[i,j] = op(A[i,j], B[i,j]) for all i,j present in either A and B.\n\nKeywords\n\nmask::Union{Nothing, GBVecOrMat} = nothing: optional mask.\naccum::Union{Nothing, Function, AbstractBinaryOp} = nothing: binary accumulator operation   such that C[i,j] = accum(C[i,j], T[i,j]) where T is the result of this function before accum is applied.\ndesc::Union{Nothing, Descriptor} = nothing\n\n\n\n\n\n","category":"function"},{"location":"operations/#SuiteSparseGraphBLAS.extract","page":"Operations","title":"SuiteSparseGraphBLAS.extract","text":"extract(A::GBMatOrTranspose, I, J; kwargs...)::GBMatrix\nextract(A::GBVector, I; kwargs...)::GBVector\n\nExtract a submatrix or subvector from A\n\nArguments\n\nA::GBArray: the array being indexed.\nI and J: A colon, scalar, vector, or range indexing A.\n\nKeywords\n\nmask::Union{Nothing, GBArray} = nothing: mask where   size(M) == (max(I), max(J)).\naccum::Union{Nothing, AbstractBinaryOp} = nothing: binary accumulator operation   where C[i,j] = accum(C[i,j], T[i,j]) where T is the result of this function before accum is applied.\ndesc::Descriptor = nothing\n\nReturns\n\nGBMatrix: the submatrix A[I, J].\n\nThrows\n\nGrB_DIMENSION_MISMATCH: If (max(I), max(J)) != size(mask).\n\n\n\n\n\n","category":"function"},{"location":"operations/#SuiteSparseGraphBLAS.subassign!","page":"Operations","title":"SuiteSparseGraphBLAS.subassign!","text":"subassign!(C::GBMatrix, A::GBMatrix, I, J; kwargs...)::GBMatrix\n\nAssign a submatrix of A to C. Equivalent to assign! except that size(mask) == size(A), whereas size(mask) == size(C) in assign!.\n\nArguments\n\nC::GBMatrix: the matrix being subassigned to where C[I,J] = A.\nA::GBMatrix: the matrix being assigned to a submatrix of C.\nI and J: A colon, scalar, vector, or range indexing C.\n\nKeywords\n\nmask::Union{Nothing, GBMatrix} = nothing: mask where   size(M) == size(A).\naccum::Union{Nothing, Function, AbstractBinaryOp} = nothing: binary accumulator operation   where C[i,j] = accum(C[i,j], T[i,j]) where T is the result of this function before accum is applied.\ndesc::Union{Nothing, Descriptor} = nothing\n\nReturns\n\nGBMatrix: The input matrix A.\n\nThrows\n\nGrB_DIMENSION_MISMATCH: If size(A) != (max(I), max(J)) or size(A) != size(mask).\n\n\n\n\n\nsubassign(w::GBVector, u::GBVector, I; kwargs...)::GBVector\n\nAssign a subvector of w to u. Return u. Equivalent to the matrix definition.\n\n\n\n\n\n","category":"function"},{"location":"operations/#SuiteSparseGraphBLAS.assign!","page":"Operations","title":"SuiteSparseGraphBLAS.assign!","text":"assign!(C::GBMatrix, A::GBMatrix, I, J; kwargs...)::GBMatrix\n\nAssign a submatrix of A to C. Equivalent to subassign! except that size(mask) == size(C), whereas size(mask) == size(A) insubassign!`.\n\nArguments\n\nC::GBMatrix: the matrix being subassigned to where C[I,J] = A.\nA::GBMatrix: the matrix being assigned to a submatrix of C.\nI and J: A colon, scalar, vector, or range indexing C.\n\nKeywords\n\nmask::Union{Nothing, GBMatrix} = nothing: mask where   size(M) == size(C).\naccum::Union{Nothing, Function, AbstractBinaryOp} = nothing: binary accumulator operation   where C[i,j] = accum(C[i,j], T[i,j]) where T is the result of this function before accum is applied.\ndesc::Union{Nothing, Descriptor} = nothing\n\nReturns\n\nGBMatrix: The input matrix A.\n\nThrows\n\nGrB_DIMENSION_MISMATCH: If size(A) != (max(I), max(J)) or size(C) != size(mask).\n\n\n\n\n\nassign(w::GBVector, u::GBVector, I; kwargs...)::GBVector\n\nAssign a subvector of w to u. Return u. Equivalent to the matrix definition.\n\n\n\n\n\n","category":"function"},{"location":"operations/#SuiteSparseGraphBLAS.apply","page":"Operations","title":"SuiteSparseGraphBLAS.apply","text":"apply(op::Union{Function, AbstractUnaryOp}, A::GBArray; kwargs...)::GBArray\napply(op::Union{Function, AbstractBinaryOp}, A::GBArray, x; kwargs...)::GBArray\napply(op::Union{Function, AbstractBinaryOp}, x, A::GBArray, kwargs...)::GBArray\n\nTransform a GBArray by applying op to each element. Equivalent to Base.map except for the additional x argument for mapping with a scalar.\n\nUnaryOps and single argument functions apply elementwise in the usual fashion. BinaryOps and two argument functions require the additional argument x which is      substituted as the first or second operand of op depending on its position.\n\nArguments\n\nop::Union{Function, AbstractUnaryOp, AbstractBinaryOp}\nA::GBArray\nx: Position dependent argument to binary operators.\n\nKeywords\n\nmask::Union{Nothing, GBVecOrMat} = nothing: optional mask.\naccum::Union{Nothing, AbstractBinaryOp} = nothing: binary accumulator operation   where C[i,j] = accum(C[i,j], T[i,j]) where T is the result of this function before accum is applied.\ndesc::Union{Nothing, Descriptor} = nothing\n\n\n\n\n\n","category":"function"},{"location":"operations/#SuiteSparseGraphBLAS.select","page":"Operations","title":"SuiteSparseGraphBLAS.select","text":"select(op::Union{Function, SelectUnion}, A::GBArray; kwargs...)::GBArray\nselect(op::Union{Function, SelectUnion}, A::GBArray, thunk; kwargs...)::GBArray\n\nReturn a GBArray whose elements satisfy the predicate defined by op. Some SelectOps or functions may require an additional argument thunk, for use in     comparison operations such as C[i,j] = A[i,j] >= thunk ? A[i,j] : nothing, which is     performed by select(>, A, thunk).\n\nArguments\n\nop::Union{Function, SelectUnion}: A select operator from the SelectOps submodule.\nA::GBArray\nthunk::Union{GBScalar, nothing, valid_union}: Optional value used to evaluate op.\n\nKeywords\n\nmask::Union{Nothing, GBMatrix} = nothing: optional mask which determines the output   pattern.\naccum::Union{Nothing, AbstractBinaryOp} = nothing: optional binary accumulator   operation where C[i,j] = accum(C[i,j], T[i,j]) where T is the result of this function before accum is applied.\ndesc = nothing\n\nReturns\n\nGBArray: The output matrix whose eltype is determined by A and op.\n\n\n\n\n\n","category":"function"},{"location":"operations/#Base.reduce","page":"Operations","title":"Base.reduce","text":"reduce(op::Union{Function, AbstractMonoid}, A::GBMatrix, dims=:; kwargs...)\nreduce(op::Union{Function, AbstractMonoid}, v::GBVector; kwargs...)\n\nReduce A along dimensions of A with monoid op.\n\nArguments\n\nop: the reducer. This must map to an AbstractMonoid, not an AbstractBinaryOp.\nA::GBArray: GBVector or optionally transposed GBMatrix.\ndims = :: Optional dimensions for GBMatrix, may be 1, 2, or :.\n\nKeywords\n\ntypeout: Optional output type specification. Defaults to eltype(A).\ninit: Optional initial value.\nmask::Union{Nothing, GBMatrix} = nothing: optional mask.\naccum::Union{Nothing, AbstractBinaryOp} = nothing: binary accumulator operation   where C[i,j] = accum(C[i,j], T[i,j]) where T is the result of this function before accum is applied.\ndesc = nothing\n\n\n\n\n\n","category":"function"},{"location":"operations/#SuiteSparseGraphBLAS.gbtranspose","page":"Operations","title":"SuiteSparseGraphBLAS.gbtranspose","text":"gbtranspose(A::GBMatrix; kwargs...)::GBMatrix\n\nEagerly evaluated matrix transpose which returns the transposed matrix.\n\nKeywords\n\nmask::Union{Nothing, GBMatrix} = nothing: optional mask.\naccum::Union{Nothing, AbstractBinaryOp} = nothing: binary accumulator operation   where C[i,j] = accum(C[i,j], T[i,j]) where T is the result of this function before accum is applied.\ndesc::Union{Nothing, Descriptor} = nothing\n\nReturns\n\nC::GBMatrix: output matrix.\n\n\n\n\n\n","category":"function"},{"location":"operations/#Base.kron","page":"Operations","title":"Base.kron","text":"kron(A::GBMatrix, B::GBMatrix, op = BinaryOps.TIMES; kwargs...)::GBMatrix\n\nKronecker product of two matrices using op as the multiplication operator. Does not support GBVectors at this time.\n\nArguments\n\nA::GBMatrix: optionally transposed.\nB::GBMatrix: optionally transposed.\nop::MonoidBinaryOrRig = BinaryOps.TIMES: the binary operation which replaces the arithmetic   multiplication operation from the usual kron function.\n\nKeywords\n\nmask::Union{Nothing, GBMatrix} = nothing: optional mask.\naccum::Union{Nothing, AbstractBinaryOp} = nothing: binary accumulator operation   where C[i,j] = accum(C[i,j], T[i,j]) where T is the result of this function before accum is applied.\ndesc = nothing\n\n\n\n\n\n","category":"function"},{"location":"operations/#SuiteSparseGraphBLAS.mask","page":"Operations","title":"SuiteSparseGraphBLAS.mask","text":"mask(A::GBArray, mask::GBArray)\n\nApply a mask to matrix A.\n\n\n\n\n\n","category":"function"},{"location":"operations/#Order-of-Operations","page":"Operations","title":"Order of Operations","text":"","category":"section"},{"location":"operations/","page":"Operations","title":"Operations","text":"A GraphBLAS operation semantically occurs in the following order:","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"Calculate T = <operation>(args...)\nElementwise accumulate Z[i,j] = accum(C[i,j], T[i,j])\nOptionally masked assignment C[i,j] = mask[i,j] ? Z[i,j] : [nothing | C[i,j]]","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"If replace_output is set the option in step 3. is nothing, otherwise it is C[i,j].","category":"page"},{"location":"operators/#Operators","page":"Operators","title":"Operators","text":"","category":"section"},{"location":"operators/","page":"Operators","title":"Operators","text":"Operators are one of the basic objects of GraphBLAS. In Julia, however, users must only interact directly with operators on rare occasions, and should instead pass functions to GraphBLAS operations.","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"There are five operator types in SuiteSparseGraphBLAS. Four are defined for all GraphBLAS implementations: UnaryOp, BinaryOp, Monoid, and Semiring.  One is an extension to the v1.3 specification: SelectOp.","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"danger: Note\nOperators are not callable objects like functions. They do behave like functions when used as arguments to higher-order functions (operations in the language of GraphBLAS).","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"Typically operators are positional arguments in one of two places. For operations with a clear default operator they appear as the last positional argument:","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"emul(A, B, op::Union{BinaryOp, Function})\neadd(A, B, op::Union{BinaryOp, Function})\nkron(A, B, op::Union{BinaryOp, Function})\n*(A, B, op::Union{Semiring, Tuple{Function, Function}})","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"For other operations without a clear default operator they appear as the first argument:","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"apply(op::Union{UnaryOp, Function}, A)\nreduce(op::Union{BinaryOp, Function}, A)\nselect(op::Union{SelectOp, Function}, A)","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"note: Built-in vs User-defined operators\nGraphBLAS supports both built-in and user-defined operators. Built-in operators are precompiled C functions, while user-defined operators are function pointers to Julia functions. Built-in operators are typically much faster than user-defined ones. See the page for the particular operator type (unary, binary, select, etc.) for more information.","category":"page"},{"location":"operators/#UnaryOps,-BinaryOps,-Monoids,-and-Semirings","page":"Operators","title":"UnaryOps, BinaryOps, Monoids, and Semirings","text":"","category":"section"},{"location":"operators/","page":"Operators","title":"Operators","text":"Each operator is defined on a specific domain. For some this is the usual primitive datatypes like booleans, floats, and signed and unsigned integers of the typical sizes.","category":"page"},{"location":"operators/#Supported-Types","page":"Operators","title":"Supported Types","text":"","category":"section"},{"location":"operators/","page":"Operators","title":"Operators","text":"SuiteSparseGraphBLAS.jl natively supports the following types:","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"Booleans\nIntegers with sizes 8, 16, 32, 64\nUnsigned Integers with sizes 8, 16, 32, 64\nFloat32 and Float64\nComplexF32 and ComplexF64","category":"page"},{"location":"operators/#Lowering","page":"Operators","title":"Lowering","text":"","category":"section"},{"location":"operators/","page":"Operators","title":"Operators","text":"Operators are lowered from a Julia function to a container like BinaryOp or Semiring. After this they are lowered once again using the type to a TypedBinaryOp, TypedSemiring, etc. The TypedBinaryOp contains the reference to the C-side GraphBLAS operator. Typed operators, like TypedSemiring are constants, found in a submodule (SuiteSparseGraphBLAS.Semirings in the case of TypedSemirings).","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"using SuiteSparseGraphBLAS","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"b = BinaryOp(+)\nb(Int32)\n\ns = Semiring(max, +)\ns(Float64)","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"All operations should accept the function/tuple form, the Semiring{typeof(max), typeof(+)} form, or the TypedSemiring form. Unless you need to specifically cast the arguments to a specific type there is generally no need to use the latter two forms.","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"You can determine the the input and output types of a type-specific operator with the functions below:","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"xtype\nytype\nztype","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"Some examples of these functions are below.  Note the difference between ISGT which returns a result with the same type as the input, and GT which returns a Boolean.","category":"page"},{"location":"operators/","page":"Operators","title":"Operators","text":"xtype(Semirings.LOR_GT_UINT16)\nztype(Semirings.LOR_GT_FP64)\nxtype(BinaryOps.ISGT_INT8)\nztype(BinaryOps.ISGT_INT8)\nztype(BinaryOps.GT_INT8)","category":"page"},{"location":"operators/#SelectOps","page":"Operators","title":"SelectOps","text":"","category":"section"},{"location":"operators/","page":"Operators","title":"Operators","text":"The SelectOp is a SuiteSparse extension to the specification, although a similar construct is likely to be found in a future specification. Unlike the other operators there are no type-specific operators, and as such you cannot index into them with types to obtain a type-specific version.","category":"page"},{"location":"#SuiteSparseGraphBLAS.jl","page":"Introduction","title":"SuiteSparseGraphBLAS.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Fast sparse linear algebra is an essential part of the scientific computing toolkit. Outside of the usual applications, like differential equations, sparse linear algebra provides an elegant way to express graph algorithms on adjacency and incidence matrices. The GraphBLAS standard specifies a set of operations for computing sparse matrix graph algorithm in a vein similar to the BLAS or LAPACK standards.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"SuiteSparseGraphBLAS.jl is a blazing fast package for shared memory sparse matrix operations which wraps Tim Davis' SuiteSparse:GraphBLAS. If you use this package in your research please see Citing.","category":"page"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Install using the Julia package manager in the REPL:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"] add SuiteSparseGraphBLAS","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"or with Pkg","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using Pkg\nPkg.add(\"SuiteSparseGraphBLAS\")","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The SuiteSparse:GraphBLAS binary, SSGraphBLAS_jll.jl, is installed automatically.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Then in the REPL or script using SuiteSparseGraphBLAS will make the package available for use.","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"GraphBLAS harnesses the well-understood duality between graphs and matrices. Specifically a graph can be represented by the adjacency matrix and/or incidence matrix, or one of the many variations on those formats.  With this matrix representation in hand we have a method to operate on the graph with linear algebra.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"One important algorithm that maps well to linear algebra is Breadth First Search (BFS).  A simple BFS is just a matrix-vector multiplication, where A is the adjacency matrix and v is the set of source nodes, as illustrated below.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"(Image: BFS and Adjacency Matrix)","category":"page"},{"location":"#GBArrays","page":"Introduction","title":"GBArrays","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The core SuiteSparseGraphBLAS.jl array types are GBVector and GBMatrix which are subtypes SparseArrays.AbstractSparseVector and SparseArrays.AbstractSparseMatrix respectively. There are also several auxiliary array types that restrict one or more behaviors, like row or column orientation. More info on those types can be found ### HERE ###","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"note: GBArray\nThese docs will often refer to the GBArray type, which is the union of AbstractGBVector, AbstractGBMatrix and their lazy Transpose objects.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using SuiteSparseGraphBLAS\nusing SparseArrays","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"# create a size 13 empty sparse vector with Float64 elements.\nv = GBVector{Float64}(13) \n\n# create a 1000 x 1000 empty sparse matrix with ComplexF64 elements.\nA = GBMatrix{ComplexF64}(1000, 1000)\n\nA[1,5] === nothing","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Here we can already see several differences compared to SparseArrays.SparseMatrixCSC.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The first is that A is stored in hypersparse format, and by row.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"GBArrays are (technically) opaque to the user in order to allow the library author to choose the best storage format.\nGraphBLAS takes advantage of this by storing matrices in one of four formats: dense, bitmap, sparse-compressed, or hypersparse-compressed; and in either row or column major orientation.\nDifferent matrices may be better suited to storage in one of those formats, and certain operations may perform differently on row or column major matrices.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"warning: Default Orientation\nThe default orientation of a GBMatrix is by-row, the opposite of Julia arrays. However, a GBMatrix constructed from a SparseMatrixCSC or  Matrix will be stored by-column.\nThe orientation of a GBMatrix can be modified using gbset(A, :format, :byrow) or gbset(A, :format, :bycol), and queried by gbget(A, :format)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Information about storage formats, orientation, conversion, construction and more can be found in Arrays.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The second difference is that a GBArray doesn't assume the fill-in value of a sparse array.\nSince A[1,5] isn't stored in the matrix (it's been \"compressed\" out), we return nothing.\n This better matches the GraphBLAS spec, where NO_VALUE is returned, rather than zero(eltype(A)). This is better suited to graph algorithms where returning zero(eltype(A)) might imply the presence of an edge with weight zero.\nHowever this behavior can be changed with the setfill! and setfill functions.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"A[1, 1] === nothing\n\nB = setfill(A, 0) # no-copy alias\nB[1, 1]","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"An empty matrix and vector won't do us much good, so let's see how to construct the matrix and vector from the graphic above. Both A and v below are constructed from coordinate format or COO.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"A = GBMatrix([1,1,2,2,3,4,4,5,6,7,7,7], [2,4,5,7,6,1,3,6,3,3,4,5], [1:12...])\n\nv = GBVector([4], [10])","category":"page"},{"location":"#GraphBLAS-Operations","page":"Introduction","title":"GraphBLAS Operations","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The complete documentation of supported operations can be found in Operations. GraphBLAS operations are, where possible, methods of existing Julia functions listed in the third column.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"GraphBLAS Operation Julia\nmxm, mxv, vxm bf C langle M rangle = C odot AB mul! or *\neWiseMult bf C langle M rangle = C odot (A otimes B) emul[!] or . broadcasting\neWiseAdd bf C langle M rangle = C odot (A oplus  B) eadd[!]\nextract bf C langle M rangle = C odot A(IJ) extract[!], getindex\nsubassign bf C (IJ) langle M rangle = C(IJ) odot A subassign[!] or setindex!\nassign bf C langle M rangle (IJ) = C(IJ) odot A assign[!]\napply bf C langle M rangle = C odot fbf (A) apply[!], map[!] or . broadcasting\n bf C langle M rangle = C odot f(bf Ay) \n bf C langle M rangle = C odot f(xbf A) \nselect bf C langle M rangle = C odot f(bf Ak) select[!]\nreduce bf w langle m rangle = w odot oplus_j bf A(j) reduce[!]\n s = s odot oplus_ij  bf A(ij) \ntranspose bf C langle M rangle = C odot A^sf T gbtranspose[!], lazy: transpose, '\nkronecker bf C langle M rangle = C odot textkron(A B) kron[!]","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"where bf M is a GBArray mask, odot is a binary operator for accumulating into bf C, and otimes and oplus are a binary operation and commutative monoid respectively. f is either a unary or binary operator. ","category":"page"},{"location":"#GraphBLAS-Operators","page":"Introduction","title":"GraphBLAS Operators","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Many GraphBLAS operations take additional arguments called operators. In the table above operators are denoted by odot, otimes, and oplus and f, and they behave similar to the function argument of map. A closer look at operators can be found in Operators","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"A GraphBLAS operator is a unary or binary function, the commutative monoid form of a binary function, or a semiring, made up of a binary op and a commutative monoid. SuiteSparse:GraphBLAS ships with many of the common unary and binary operators as built-ins, along with monoids and semirings built commonly used in graph algorithms.  These built-in operators are fast, and should be used where possible. However, users are also free to provide their own functions as operators when necessary.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"SuiteSparseGraphBLAS.jl will mostly take care of operators behind the scenes, and in most cases users should pass in normal functions like + and sin. For example:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"emul(A, A, ^) # elementwise exponent\n\nmap(sin, A)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Broadcasting functionality is also supported, A .^ A will lower to emul(A, A, ^), and sin.(A) will lower to map(sin, A).","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Matrix multiplication, which accepts a semiring, can be called with either *(max, +)(A, B) or *(A, B, (max, +)).","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"We can also use functions that are not already built into SuiteSparseGraphBLAS.jl:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"M = GBMatrix([[1,2] [3,4]])\nincrement(x) = x + 1\nmap(increment, M)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Unfortunately this has a couple problems. The first is that it's slow.\nCompared to A .+ 1 which lowers to apply(+, A, 1) the map call above is ~2.5x slower due to function pointer overhead.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The second is that everytime we call map(increment, M) we will be re-creating the function pointer for increment matched to the type of M.\nTo avoid this the convenience macro @unop will provide a permanent constant which is used internally every time increment is called with a GraphBLAS operation. See Operators for more information.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"warning: Performance of User Defined Functions\nOperators which are not already built-in are automatically constructed using function pointers when called.  Note, however, that their performance is significantly degraded compared to built-in operators, and where possible user code should avoid this capability. See Operators.","category":"page"},{"location":"#Example","page":"Introduction","title":"Example","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Here is a quick example of two different methods of triangle counting with GraphBLAS. The methods are drawn from the LAGraph repo.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Input A must be a square, symmetric matrix with any element type. We'll test it using the matrix from the GBArray section above, which has two triangles in its undirected form.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using SuiteSparseGraphBLAS: pair\nfunction cohen(A)\n  U = select(triu, A)\n  L = select(tril, A)\n  return reduce(+, *(L, U, (+, pair); mask=A)) ÷ 2\nend\n\nfunction sandia(A)\n  L = select(tril, A)\n  return reduce(+, *(L, L, (+, pair); mask=L))\nend\n\nM = eadd(A, A', +) #Make undirected/symmetric\ncohen(M)\nsandia(M)","category":"page"},{"location":"#Citing","page":"Introduction","title":"Citing","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Please cite the following papers:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"pdf:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"    @article{10.1145/3322125,\n    author = {Davis, Timothy A.},\n    title = {Algorithm 1000: SuiteSparse:GraphBLAS: Graph Algorithms in the Language of Sparse Linear Algebra},\n    year = {2019},\n    issue_date = {December 2019},\n    publisher = {Association for Computing Machinery},\n    address = {New York, NY, USA},\n    volume = {45},\n    number = {4},\n    issn = {0098-3500},\n    url = {https://doi.org/10.1145/3322125},\n    doi = {10.1145/3322125},\n    journal = {ACM Trans. Math. Softw.},\n    month = {dec},\n    articleno = {44},\n    numpages = {25},\n    keywords = {GraphBLAS, Graph algorithms, sparse matrices}\n    }","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"pdf:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"    @article{GraphBLAS7,\n    author = {Davis, Timothy A.},\n    title = {Algorithm 10xx: SuiteSparse:GraphBLAS: Graph Algorithms in the Language of Sparse Linear Algebra},\n    year = {2022},\n    journal = {ACM Trans. Math. Softw.},\n    month = {(under revision)},\n    note={See GraphBLAS/Doc/toms_parallel_grb2.pdf},\n    keywords = {GraphBLAS, Graph algorithms, sparse matrices}\n}","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"pdf:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"@inproceedings{9622789,\nauthor={Pelletier, Michel and Kimmerer, Will and Davis, Timothy A. and Mattson, Timothy G.},\nbooktitle={2021 IEEE High Performance Extreme Computing Conference (HPEC)},\ntitle={The GraphBLAS in Julia and Python: the PageRank and Triangle Centralities},\nyear={2021},\npages={1-7},\ndoi={10.1109/HPEC49654.2021.9622789},\nISSN={2643-1971},\nmonth={Sep.}\n}","category":"page"}]
}
