var documenterSearchIndex = {"docs":
[{"location":"#SuiteSparseGraphBLAS.jl-1","page":"Home","title":"SuiteSparseGraphBLAS.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"SuiteSparseGraphBLAS.jl is a Julia wrapper for the SuiteSparse:GraphBLAS C library.","category":"page"},{"location":"context_methods/#Context-methods-1","page":"Context methods","title":"Context methods","text":"","category":"section"},{"location":"context_methods/#","page":"Context methods","title":"Context methods","text":"GrB_init\nGrB_finalize","category":"page"},{"location":"context_methods/#GraphBLASInterface.GrB_init","page":"Context methods","title":"GraphBLASInterface.GrB_init","text":"GrB_init(mode)\n\nGrB_init must called before any other GraphBLAS operation. GrB_init defines the mode that GraphBLAS will use: blocking or non-blocking. With blocking mode, all operations finish before returning to the user application. With non-blocking mode, operations can be left pending, and are computed only when needed.\n\n\n\n\n\n","category":"function"},{"location":"context_methods/#GraphBLASInterface.GrB_finalize","page":"Context methods","title":"GraphBLASInterface.GrB_finalize","text":"GrB_finalize()\n\nGrB_finalize must be called as the last GraphBLAS operation. GrB_finalize does not call GrB_wait; any pending computations are abandoned.\n\n\n\n\n\n","category":"function"},{"location":"matrix_and_vector_methods/#Matrix-functions-1","page":"Basic matrix & vector methods","title":"Matrix functions","text":"","category":"section"},{"location":"matrix_and_vector_methods/#","page":"Basic matrix & vector methods","title":"Basic matrix & vector methods","text":"GrB_Matrix_new\nGrB_Matrix_build\nGrB_Matrix_nrows\nGrB_Matrix_ncols\nGrB_Matrix_nvals\nGrB_Matrix_setElement\nGrB_Matrix_extractElement\nGrB_Matrix_extractTuples\nGrB_Matrix_dup\nGrB_Matrix_clear","category":"page"},{"location":"matrix_and_vector_methods/#GraphBLASInterface.GrB_Matrix_new","page":"Basic matrix & vector methods","title":"GraphBLASInterface.GrB_Matrix_new","text":"GrB_Matrix_new(A, type, nrows, ncols)\n\nInitialize a matrix with specified domain and dimensions.\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> MAT = GrB_Matrix{Int8}()\nGrB_Matrix{Int8}\n\njulia> GrB_Matrix_new(MAT, GrB_INT8, 4, 4)\nGrB_SUCCESS::GrB_Info = 0\n\n\n\n\n\n","category":"function"},{"location":"matrix_and_vector_methods/#GraphBLASInterface.GrB_Matrix_build","page":"Basic matrix & vector methods","title":"GraphBLASInterface.GrB_Matrix_build","text":"GrB_Matrix_build(C, I, J, X, nvals, dup)\n\nStore elements from tuples into a matrix.\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> MAT = GrB_Matrix{Int8}()\nGrB_Matrix{Int8}\n\njulia> GrB_Matrix_new(MAT, GrB_INT8, 4, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I = ZeroBasedIndex[1, 2, 2, 2, 3]; J = ZeroBasedIndex[1, 2, 1, 3, 3]; X = Int8[2, 3, 4, 5, 6]; n = 5;\n\njulia> GrB_Matrix_build(MAT, I, J, X, n, GrB_FIRST_INT8)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> @GxB_Matrix_fprint(MAT, GxB_COMPLETE)\n\nGraphBLAS matrix: MAT\nnrows: 4 ncols: 4 max # entries: 5\nformat: standard CSR vlen: 4 nvec_nonempty: 3 nvec: 4 plen: 4 vdim: 4\nhyper_ratio 0.0625\nGraphBLAS type:  int8_t size: 1\nnumber of entries: 5\nrow: 1 : 1 entries [0:0]\n    column 1: int8 2\nrow: 2 : 3 entries [1:3]\n    column 1: int8 4\n    column 2: int8 3\n    column 3: int8 5\nrow: 3 : 1 entries [4:4]\n    column 3: int8 6\n\n\n\n\n\n","category":"function"},{"location":"matrix_and_vector_methods/#GraphBLASInterface.GrB_Matrix_nrows","page":"Basic matrix & vector methods","title":"GraphBLASInterface.GrB_Matrix_nrows","text":"GrB_Matrix_nrows(A)\n\nReturn the number of rows in a matrix if successful. Else return GrB_Info error code.\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> MAT = GrB_Matrix{Int8}()\nGrB_Matrix{Int8}\n\njulia> GrB_Matrix_new(MAT, GrB_INT8, 4, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Matrix_nrows(MAT)\n0x0000000000000004\n\n\n\n\n\n","category":"function"},{"location":"matrix_and_vector_methods/#GraphBLASInterface.GrB_Matrix_ncols","page":"Basic matrix & vector methods","title":"GraphBLASInterface.GrB_Matrix_ncols","text":"GrB_Matrix_ncols(A)\n\nReturn the number of columns in a matrix if successful. Else return GrB_Info error code.\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> MAT = GrB_Matrix{Int8}()\nGrB_Matrix{Int8}\n\njulia> GrB_Matrix_new(MAT, GrB_INT8, 4, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Matrix_ncols(MAT)\n0x0000000000000004\n\n\n\n\n\n","category":"function"},{"location":"matrix_and_vector_methods/#GraphBLASInterface.GrB_Matrix_nvals","page":"Basic matrix & vector methods","title":"GraphBLASInterface.GrB_Matrix_nvals","text":"GrB_Matrix_nvals(A)\n\nReturn the number of stored elements in a matrix if successful. Else return GrB_Info error code..\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> MAT = GrB_Matrix{Int8}()\nGrB_Matrix{Int8}\n\njulia> GrB_Matrix_new(MAT, GrB_INT8, 4, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I = ZeroBasedIndex[1, 2, 2, 2, 3]; J = ZeroBasedIndex[1, 2, 1, 3, 3]; X = Int8[2, 3, 4, 5, 6]; n = 5;\n\njulia> GrB_Matrix_build(MAT, I, J, X, n, GrB_FIRST_INT8)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Matrix_nvals(MAT)\n0x0000000000000005\n\n\n\n\n\n","category":"function"},{"location":"matrix_and_vector_methods/#GraphBLASInterface.GrB_Matrix_setElement","page":"Basic matrix & vector methods","title":"GraphBLASInterface.GrB_Matrix_setElement","text":"GrB_Matrix_setElement(C, X, I, J)\n\nSet one element of a matrix to a given value, C[I][J] = X.\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> MAT = GrB_Matrix{Int8}()\nGrB_Matrix{Int8}\n\njulia> GrB_Matrix_new(MAT, GrB_INT8, 4, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I = ZeroBasedIndex[1, 2, 2, 2, 3]; J = ZeroBasedIndex[1, 2, 1, 3, 3]; X = Int8[2, 3, 4, 5, 6]; n = 5;\n\njulia> GrB_Matrix_build(MAT, I, J, X, n, GrB_FIRST_INT8)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Matrix_extractElement(MAT, ZeroBasedIndex(1), ZeroBasedIndex(1))\n2\n\njulia> GrB_Matrix_setElement(MAT, Int8(7), ZeroBasedIndex(1), ZeroBasedIndex(1))\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Matrix_extractElement(MAT, ZeroBasedIndex(1), ZeroBasedIndex(1))\n7\n\n\n\n\n\n","category":"function"},{"location":"matrix_and_vector_methods/#GraphBLASInterface.GrB_Matrix_extractElement","page":"Basic matrix & vector methods","title":"GraphBLASInterface.GrB_Matrix_extractElement","text":"GrB_Matrix_extractElement(A, row_index, col_index)\n\nReturn element of a matrix at a given index (A[rowindex][colindex]) if successful. Else return GrB_Info error code.\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> MAT = GrB_Matrix{Int8}()\nGrB_Matrix{Int8}\n\njulia> GrB_Matrix_new(MAT, GrB_INT8, 4, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I = ZeroBasedIndex[1, 2, 2, 2, 3]; J = ZeroBasedIndex[1, 2, 1, 3, 3]; X = Int8[2, 3, 4, 5, 6]; n = 5;\n\njulia> GrB_Matrix_build(MAT, I, J, X, n, GrB_FIRST_INT8)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Matrix_extractElement(MAT, ZeroBasedIndex(1), ZeroBasedIndex(1))\n2\n\n\n\n\n\n","category":"function"},{"location":"matrix_and_vector_methods/#GraphBLASInterface.GrB_Matrix_extractTuples","page":"Basic matrix & vector methods","title":"GraphBLASInterface.GrB_Matrix_extractTuples","text":"GrB_Matrix_extractTuples(A, [index_type])\n\nReturn tuples stored in a matrix if successful. Else return GrB_Info error code. Returns zero based indices by default.\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> MAT = GrB_Matrix{Int8}()\nGrB_Matrix{Int8}\n\njulia> GrB_Matrix_new(MAT, GrB_INT8, 4, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I = ZeroBasedIndex[1, 2, 2, 2, 3]; J = ZeroBasedIndex[1, 2, 1, 3, 3]; X = Int8[2, 3, 4, 5, 6]; n = 5;\n\njulia> GrB_Matrix_build(MAT, I, J, X, n, GrB_FIRST_INT8)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Matrix_extractTuples(MAT)\n(ZeroBasedIndex[ZeroBasedIndex(0x0000000000000001), ZeroBasedIndex(0x0000000000000002), ZeroBasedIndex(0x0000000000000002), ZeroBasedIndex(0x0000000000000002), ZeroBasedIndex(0x0000000000000003)], ZeroBasedIndex[ZeroBasedIndex(0x0000000000000001), ZeroBasedIndex(0x0000000000000001), ZeroBasedIndex(0x0000000000000002), ZeroBasedIndex(0x0000000000000003), ZeroBasedIndex(0x0000000000000003)], Int8[2, 4, 3, 5, 6])\n\n\n\n\n\n","category":"function"},{"location":"matrix_and_vector_methods/#GraphBLASInterface.GrB_Matrix_dup","page":"Basic matrix & vector methods","title":"GraphBLASInterface.GrB_Matrix_dup","text":"GrB_Matrix_dup(C, A)\n\nInitialize a new matrix with the same domain, dimensions, and contents as another matrix.\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> MAT = GrB_Matrix{Int8}()\nGrB_Matrix{Int8}\n\njulia> GrB_Matrix_new(MAT, GrB_INT8, 4, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I = ZeroBasedIndex[1, 2, 2, 2, 3]; J = ZeroBasedIndex[1, 2, 1, 3, 3]; X = Int8[2, 3, 4, 5, 6]; n = 5;\n\njulia> GrB_Matrix_build(MAT, I, J, X, n, GrB_FIRST_INT8)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> B = GrB_Matrix{Int8}()\nGrB_Matrix{Int8}\n\njulia> GrB_Matrix_dup(B, MAT)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> @GxB_Matrix_fprint(B, GxB_COMPLETE)\n\nGraphBLAS matrix: B\nnrows: 4 ncols: 4 max # entries: 5\nformat: standard CSR vlen: 4 nvec_nonempty: 3 nvec: 4 plen: 4 vdim: 4\nhyper_ratio 0.0625\nGraphBLAS type:  int8_t size: 1\nnumber of entries: 5\nrow: 1 : 1 entries [0:0]\n    column 1: int8 2\nrow: 2 : 3 entries [1:3]\n    column 1: int8 4\n    column 2: int8 3\n    column 3: int8 5\nrow: 3 : 1 entries [4:4]\n    column 3: int8 6\n\n\n\n\n\n","category":"function"},{"location":"matrix_and_vector_methods/#GraphBLASInterface.GrB_Matrix_clear","page":"Basic matrix & vector methods","title":"GraphBLASInterface.GrB_Matrix_clear","text":"GrB_Matrix_clear(A)\n\nRemove all elements from a matrix.\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> MAT = GrB_Matrix{Int8}()\nGrB_Matrix{Int8}\n\njulia> GrB_Matrix_new(MAT, GrB_INT8, 4, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I = ZeroBasedIndex[1, 2, 2, 2, 3]; J = ZeroBasedIndex[1, 2, 1, 3, 3]; X = Int8[2, 3, 4, 5, 6]; n = 5;\n\njulia> GrB_Matrix_build(MAT, I, J, X, n, GrB_FIRST_INT8)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Matrix_nvals(MAT)\n0x0000000000000005\n\njulia> GrB_Matrix_clear(MAT)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Matrix_nvals(MAT)\n0x0000000000000000\n\n\n\n\n\n","category":"function"},{"location":"matrix_and_vector_methods/#Vector-functions-1","page":"Basic matrix & vector methods","title":"Vector functions","text":"","category":"section"},{"location":"matrix_and_vector_methods/#","page":"Basic matrix & vector methods","title":"Basic matrix & vector methods","text":"GrB_Vector_new\nGrB_Vector_build\nGrB_Vector_size\nGrB_Vector_nvals\nGrB_Vector_setElement\nGrB_Vector_extractElement\nGrB_Vector_extractTuples\nGrB_Vector_dup\nGrB_Vector_clear","category":"page"},{"location":"matrix_and_vector_methods/#GraphBLASInterface.GrB_Vector_new","page":"Basic matrix & vector methods","title":"GraphBLASInterface.GrB_Vector_new","text":"GrB_Vector_new(v, type, n)\n\nInitialize a vector with specified domain and size.\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> V = GrB_Vector{Float64}()\nGrB_Vector{Float64}\n\njulia> GrB_Vector_new(V, GrB_FP64, 4)\nGrB_SUCCESS::GrB_Info = 0\n\n\n\n\n\n","category":"function"},{"location":"matrix_and_vector_methods/#GraphBLASInterface.GrB_Vector_build","page":"Basic matrix & vector methods","title":"GraphBLASInterface.GrB_Vector_build","text":"GrB_Vector_build(w, I, X, nvals, dup)\n\nStore elements from tuples into a vector.\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> V = GrB_Vector{Float64}()\nGrB_Vector{Float64}\n\njulia> GrB_Vector_new(V, GrB_FP64, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I = ZeroBasedIndex[0, 2, 3]; X = [2.1, 3.2, 4.4]; n = 3;\n\njulia> GrB_Vector_build(V, I, X, n, GrB_FIRST_FP64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> @GxB_Vector_fprint(V, GxB_COMPLETE)\n\nGraphBLAS vector: V\nnrows: 4 ncols: 1 max # entries: 3\nformat: standard CSC vlen: 4 nvec_nonempty: 1 nvec: 1 plen: 1 vdim: 1\nhyper_ratio 0.0625\nGraphBLAS type:  double size: 8\nnumber of entries: 3\ncolumn: 0 : 3 entries [0:2]\n    row 0: double 2.1\n    row 2: double 3.2\n    row 3: double 4.4\n\n\n\n\n\n","category":"function"},{"location":"matrix_and_vector_methods/#GraphBLASInterface.GrB_Vector_size","page":"Basic matrix & vector methods","title":"GraphBLASInterface.GrB_Vector_size","text":"GrB_Vector_size(v)\n\nReturn the size of a vector if successful. Else return GrB_Info error code.\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> V = GrB_Vector{Float64}()\nGrB_Vector{Float64}\n\njulia> GrB_Vector_new(V, GrB_FP64, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I = ZeroBasedIndex[0, 2, 3]; X = [2.1, 3.2, 4.4]; n = 3;\n\njulia> GrB_Vector_build(V, I, X, n, GrB_FIRST_FP64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Vector_size(V)\n0x0000000000000004\n\n\n\n\n\n","category":"function"},{"location":"matrix_and_vector_methods/#GraphBLASInterface.GrB_Vector_nvals","page":"Basic matrix & vector methods","title":"GraphBLASInterface.GrB_Vector_nvals","text":"GrB_Vector_nvals(v)\n\nReturn the number of stored elements in a vector if successful. Else return GrB_Info error code.\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> V = GrB_Vector{Float64}()\nGrB_Vector{Float64}\n\njulia> GrB_Vector_new(V, GrB_FP64, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I = [0, 2, 3]; X = [2.1, 3.2, 4.4]; n = 3;\n\njulia> GrB_Vector_build(V, I, X, n, GrB_FIRST_FP64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Vector_nvals(V)\n0x0000000000000003\n\n\n\n\n\n","category":"function"},{"location":"matrix_and_vector_methods/#GraphBLASInterface.GrB_Vector_setElement","page":"Basic matrix & vector methods","title":"GraphBLASInterface.GrB_Vector_setElement","text":"GrB_Vector_setElement(w, x, i)\n\nSet one element of a vector to a given value, w[i] = x.\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> V = GrB_Vector{Int64}()\nGrB_Vector{Int64}\n\njulia> GrB_Vector_new(V, GrB_INT64, 5)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I = ZeroBasedIndex[1, 2, 4]; X = [2, 32, 4]; n = 3;\n\njulia> GrB_Vector_build(V, I, X, n, GrB_FIRST_INT64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Vector_extractElement(V, ZeroBasedIndex(2))\n32\n\njulia> GrB_Vector_setElement(V, 7, ZeroBasedIndex(2))\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Vector_extractElement(V, ZeroBasedIndex(2))\n7\n\n\n\n\n\n","category":"function"},{"location":"matrix_and_vector_methods/#GraphBLASInterface.GrB_Vector_extractElement","page":"Basic matrix & vector methods","title":"GraphBLASInterface.GrB_Vector_extractElement","text":"GrB_Vector_extractElement(v, i)\n\nReturn element of a vector at a given index (v[i]) if successful. Else return GrB_Info error code.\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> V = GrB_Vector{Float64}()\nGrB_Vector{Float64}\n\njulia> GrB_Vector_new(V, GrB_FP64, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I = ZeroBasedIndex[0, 2, 3]; X = [2.1, 3.2, 4.4]; n = 3;\n\njulia> GrB_Vector_build(V, I, X, n, GrB_FIRST_FP64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Vector_extractElement(V, ZeroBasedIndex(2))\n3.2\n\n\n\n\n\n","category":"function"},{"location":"matrix_and_vector_methods/#GraphBLASInterface.GrB_Vector_extractTuples","page":"Basic matrix & vector methods","title":"GraphBLASInterface.GrB_Vector_extractTuples","text":"GrB_Vector_extractTuples(v, [index_type])\n\nReturn tuples stored in a vector if successful. Else return GrB_Info error code. Returns zero based indices by default.\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> V = GrB_Vector{Float64}()\nGrB_Vector{Float64}\n\njulia> GrB_Vector_new(V, GrB_FP64, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I = ZeroBasedIndex[0, 2, 3]; X = [2.1, 3.2, 4.4]; n = 3;\n\njulia> GrB_Vector_build(V, I, X, n, GrB_FIRST_FP64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Vector_extractTuples(V)\n(ZeroBasedIndex[ZeroBasedIndex(0x0000000000000000), ZeroBasedIndex(0x0000000000000002), ZeroBasedIndex(0x0000000000000003)], [2.1, 3.2, 4.4])\n\n\n\n\n\n","category":"function"},{"location":"matrix_and_vector_methods/#GraphBLASInterface.GrB_Vector_dup","page":"Basic matrix & vector methods","title":"GraphBLASInterface.GrB_Vector_dup","text":"GrB_Vector_dup(w, u)\n\nInitialize a vector with the same domain, size, and contents as another vector.\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> V = GrB_Vector{Int64}()\nGrB_Vector{Int64}\n\njulia> GrB_Vector_new(V, GrB_INT64, 5)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I = ZeroBasedIndex[1, 2, 4]; X = [2, 32, 4]; n = 3;\n\njulia> GrB_Vector_build(V, I, X, n, GrB_FIRST_INT64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> B = GrB_Vector{Int64}()\nGrB_Vector{Int64}\n\njulia> GrB_Vector_dup(B, V)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> @GxB_Vector_fprint(B, GxB_COMPLETE)\n\nGraphBLAS vector: B\nnrows: 5 ncols: 1 max # entries: 3\nformat: standard CSC vlen: 5 nvec_nonempty: 1 nvec: 1 plen: 1 vdim: 1\nhyper_ratio 0.0625\nGraphBLAS type:  int64_t size: 8\nnumber of entries: 3\ncolumn: 0 : 3 entries [0:2]\n    row 1: int64 2\n    row 2: int64 32\n    row 4: int64 4\n\n\n\n\n\n","category":"function"},{"location":"matrix_and_vector_methods/#GraphBLASInterface.GrB_Vector_clear","page":"Basic matrix & vector methods","title":"GraphBLASInterface.GrB_Vector_clear","text":"GrB_Vector_clear(v)\n\nRemove all the elements (tuples) from a vector.\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> V = GrB_Vector{Int64}()\nGrB_Vector{Int64}\n\njulia> GrB_Vector_new(V, GrB_INT64, 5)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I = ZeroBasedIndex[1, 2, 4]; X = [2, 32, 4]; n = 3;\n\njulia> GrB_Vector_build(V, I, X, n, GrB_FIRST_INT64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Vector_extractTuples(V)\n(ZeroBasedIndex[ZeroBasedIndex(0x0000000000000001), ZeroBasedIndex(0x0000000000000002), ZeroBasedIndex(0x0000000000000004)], [2, 32, 4])\n\njulia> GrB_Vector_clear(V)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Vector_extractTuples(V)\n(ZeroBasedIndex[], Int64[])\n\n\n\n\n\n","category":"function"},{"location":"algebra_methods/#Algebra-methods-1","page":"Operators & algebraic structures","title":"Algebra methods","text":"","category":"section"},{"location":"algebra_methods/#","page":"Operators & algebraic structures","title":"Operators & algebraic structures","text":"GrB_UnaryOp_new\nGrB_BinaryOp_new\nGrB_Monoid_new\nGrB_Semiring_new","category":"page"},{"location":"algebra_methods/#GraphBLASInterface.GrB_UnaryOp_new","page":"Operators & algebraic structures","title":"GraphBLASInterface.GrB_UnaryOp_new","text":"GrB_UnaryOp_new(op, fn, ztype, xtype)\n\nInitialize a GraphBLAS unary operator with a specified user-defined function and its types. The function should take a single value(x) & return an output(z), f(x) = z.\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> u = GrB_Vector{Int64}()\nGrB_Vector{Int64}\n\njulia> GrB_Vector_new(u, GrB_INT64, 3)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I = ZeroBasedIndex[0, 2]; X = [10, 20]; n = 2;\n\njulia> GrB_Vector_build(u, I, X, n, GrB_FIRST_INT64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> w = GrB_Vector{Int64}()\nGrB_Vector{Int64}\n\njulia> GrB_Vector_new(w, GrB_INT64, 3)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> function NEG(a)\n           return -a\n       end\nNEG (generic function with 1 method)\n\njulia> negative = GrB_UnaryOp()\nGrB_UnaryOp\n\njulia> GrB_UnaryOp_new(negative, NEG, GrB_INT64, GrB_INT64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_apply(w, GrB_NULL, GrB_NULL, negative, u, GrB_NULL)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> @GxB_fprint(w, GxB_COMPLETE)\n\nGraphBLAS vector: w \nnrows: 3 ncols: 1 max # entries: 2\nformat: standard CSC vlen: 3 nvec_nonempty: 1 nvec: 1 plen: 1 vdim: 1\nhyper_ratio 0.0625\nGraphBLAS type:  int64_t size: 8\nnumber of entries: 2 \ncolumn: 0 : 2 entries [0:1]\n    row 0: int64 -10\n    row 2: int64 -20\n\n\n\n\n\n","category":"function"},{"location":"algebra_methods/#GraphBLASInterface.GrB_BinaryOp_new","page":"Operators & algebraic structures","title":"GraphBLASInterface.GrB_BinaryOp_new","text":"GrB_BinaryOp_new(op, fn, ztype, xtype, ytype)\n\nInitialize a GraphBLAS binary operator with a specified user-defined function and its types. The function should take 2 values(x, y) & return an output(z), f(x, y) = z.\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> V = GrB_Vector{Float64}()\nGrB_Vector{Float64}\n\njulia> GrB_Vector_new(V, GrB_FP64, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I = ZeroBasedIndex[0, 0, 3, 3]; X = [2.1, 3.2, 4.5, 5.0]; n = 4;  # two values at position 0 and 3\n\njulia> dup = GrB_BinaryOp()  # dup is a binary operator which is applied when duplicate values for the same location are present in the vector\nGrB_BinaryOp\n\njulia> function ADD(b, c)\n           return b+c\n       end\nADD (generic function with 1 method)\n\njulia> GrB_BinaryOp_new(dup, ADD, GrB_FP64, GrB_FP64, GrB_FP64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Vector_build(V, I, X, n, dup)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> @GxB_Vector_fprint(V, GxB_COMPLETE) # the value stored at position 0 and 3 will be the sum of the duplicate values\n\nGraphBLAS vector: V\nnrows: 4 ncols: 1 max # entries: 2\nformat: standard CSC vlen: 4 nvec_nonempty: 1 nvec: 1 plen: 1 vdim: 1\nhyper_ratio 0.0625\nGraphBLAS type:  double size: 8\nnumber of entries: 2\ncolumn: 0 : 2 entries [0:1]\n    row 0: double 5.3\n    row 3: double 9.5\n\n\n\n\n\n","category":"function"},{"location":"algebra_methods/#GraphBLASInterface.GrB_Monoid_new","page":"Operators & algebraic structures","title":"GraphBLASInterface.GrB_Monoid_new","text":"GrB_Monoid_new(monoid, binary_op, identity)\n\nInitialize a GraphBLAS monoid with specified binary operator and identity value.\n\n\n\n\n\n","category":"function"},{"location":"algebra_methods/#GraphBLASInterface.GrB_Semiring_new","page":"Operators & algebraic structures","title":"GraphBLASInterface.GrB_Semiring_new","text":"GrB_Semiring_new(semiring, monoid, binary_op)\n\nInitialize a GraphBLAS semiring with specified monoid and binary operator.\n\n\n\n\n\n","category":"function"},{"location":"algebra_methods/#Built-in-algebraic-objects-1","page":"Operators & algebraic structures","title":"Built-in algebraic objects","text":"","category":"section"},{"location":"algebra_methods/#Unary-operators,-z-f(x)-1","page":"Operators & algebraic structures","title":"Unary operators, z = f(x)","text":"","category":"section"},{"location":"algebra_methods/#","page":"Operators & algebraic structures","title":"Operators & algebraic structures","text":"z and x have the same type. The suffix in the name is the type of x and z.\n\nz = x                z = -x            z = 1/x\nidentity             additive          multiplicative\n                     inverse           inverse\n\nGrB_IDENTITY_BOOL    GrB_AINV_BOOL     GrB_MINV_BOOL\nGrB_IDENTITY_INT8    GrB_AINV_INT8     GrB_MINV_INT8\nGrB_IDENTITY_UINT8   GrB_AINV_UINT8    GrB_MINV_UINT8\nGrB_IDENTITY_INT16   GrB_AINV_INT16    GrB_MINV_INT16\nGrB_IDENTITY_UINT16  GrB_AINV_UINT16   GrB_MINV_UINT16\nGrB_IDENTITY_INT32   GrB_AINV_INT32    GrB_MINV_INT32\nGrB_IDENTITY_UINT32  GrB_AINV_UINT32   GrB_MINV_UINT32\nGrB_IDENTITY_INT64   GrB_AINV_INT64    GrB_MINV_INT64\nGrB_IDENTITY_UINT64  GrB_AINV_UINT64   GrB_MINV_UINT64\nGrB_IDENTITY_FP32    GrB_AINV_FP32     GrB_MINV_FP32\nGrB_IDENTITY_FP64    GrB_AINV_FP64     GrB_MINV_FP64\n\nz = !x, where both z and x are boolean. \nThere is no suffix since z and x are only boolean.\n\nGrB_LNOT","category":"page"},{"location":"algebra_methods/#Binary-operators,-z-f(x,y)-1","page":"Operators & algebraic structures","title":"Binary operators, z = f(x,y)","text":"","category":"section"},{"location":"algebra_methods/#","page":"Operators & algebraic structures","title":"Operators & algebraic structures","text":"x,y,z all have the same type :\n\nz = x              z = y              z = min(x,y)       z = max (x,y)\n\nGrB_FIRST_BOOL     GrB_SECOND_BOOL    GrB_MIN_BOOL       GrB_MAX_BOOL\nGrB_FIRST_INT8     GrB_SECOND_INT8    GrB_MIN_INT8       GrB_MAX_INT8\nGrB_FIRST_UINT8    GrB_SECOND_UINT8   GrB_MIN_UINT8      GrB_MAX_UINT8\nGrB_FIRST_INT16    GrB_SECOND_INT16   GrB_MIN_INT16      GrB_MAX_INT16\nGrB_FIRST_UINT16   GrB_SECOND_UINT16  GrB_MIN_UINT16     GrB_MAX_UINT16\nGrB_FIRST_INT32    GrB_SECOND_INT32   GrB_MIN_INT32      GrB_MAX_INT32\nGrB_FIRST_UINT32   GrB_SECOND_UINT32  GrB_MIN_UINT32     GrB_MAX_UINT32\nGrB_FIRST_INT64    GrB_SECOND_INT64   GrB_MIN_INT64      GrB_MAX_INT64\nGrB_FIRST_UINT64   GrB_SECOND_UINT64  GrB_MIN_UINT64     GrB_MAX_UINT64\nGrB_FIRST_FP32     GrB_SECOND_FP32    GrB_MIN_FP32       GrB_MAX_FP32\nGrB_FIRST_FP64     GrB_SECOND_FP64    GrB_MIN_FP64       GrB_MAX_FP64\n\nz = x+y            z = x-y            z = x*y            z = x/y\n\nGrB_PLUS_BOOL      GrB_MINUS_BOOL     GrB_TIMES_BOOL     GrB_DIV_BOOL\nGrB_PLUS_INT8      GrB_MINUS_INT8     GrB_TIMES_INT8     GrB_DIV_INT8\nGrB_PLUS_UINT8     GrB_MINUS_UINT8    GrB_TIMES_UINT8    GrB_DIV_UINT8\nGrB_PLUS_INT16     GrB_MINUS_INT16    GrB_TIMES_INT16    GrB_DIV_INT16\nGrB_PLUS_UINT16    GrB_MINUS_UINT16   GrB_TIMES_UINT16   GrB_DIV_UINT16\nGrB_PLUS_INT32     GrB_MINUS_INT32    GrB_TIMES_INT32    GrB_DIV_INT32\nGrB_PLUS_UINT32    GrB_MINUS_UINT32   GrB_TIMES_UINT32   GrB_DIV_UINT32\nGrB_PLUS_INT64     GrB_MINUS_INT64    GrB_TIMES_INT64    GrB_DIV_INT64\nGrB_PLUS_UINT64    GrB_MINUS_UINT64   GrB_TIMES_UINT64   GrB_DIV_UINT64\nGrB_PLUS_FP32      GrB_MINUS_FP32     GrB_TIMES_FP32     GrB_DIV_FP32\nGrB_PLUS_FP64      GrB_MINUS_FP64     GrB_TIMES_FP64     GrB_DIV_FP64\n\nz is always boolean & x,y have the same type :\n\nz = (x == y)       z = (x != y)       z = (x > y)        z = (x < y)\n\nGrB_EQ_BOOL        GrB_NE_BOOL        GrB_GT_BOOL        GrB_LT_BOOL\nGrB_EQ_INT8        GrB_NE_INT8        GrB_GT_INT8        GrB_LT_INT8\nGrB_EQ_UINT8       GrB_NE_UINT8       GrB_GT_UINT8       GrB_LT_UINT8\nGrB_EQ_INT16       GrB_NE_INT16       GrB_GT_INT16       GrB_LT_INT16\nGrB_EQ_UINT16      GrB_NE_UINT16      GrB_GT_UINT16      GrB_LT_UINT16\nGrB_EQ_INT32       GrB_NE_INT32       GrB_GT_INT32       GrB_LT_INT32\nGrB_EQ_UINT32      GrB_NE_UINT32      GrB_GT_UINT32      GrB_LT_UINT32\nGrB_EQ_INT64       GrB_NE_INT64       GrB_GT_INT64       GrB_LT_INT64\nGrB_EQ_UINT64      GrB_NE_UINT64      GrB_GT_UINT64      GrB_LT_UINT64\nGrB_EQ_FP32        GrB_NE_FP32        GrB_GT_FP32        GrB_LT_FP32\nGrB_EQ_FP64        GrB_NE_FP64        GrB_GT_FP64        GrB_LT_FP64\n\nz = (x >= y)       z = (x <= y)\n\nGrB_GE_BOOL        GrB_LE_BOOL\nGrB_GE_INT8        GrB_LE_INT8\nGrB_GE_UINT8       GrB_LE_UINT8\nGrB_GE_INT16       GrB_LE_INT16\nGrB_GE_UINT16      GrB_LE_UINT16\nGrB_GE_INT32       GrB_LE_INT32\nGrB_GE_UINT32      GrB_LE_UINT32\nGrB_GE_INT64       GrB_LE_INT64\nGrB_GE_UINT64      GrB_LE_UINT64\nGrB_GE_FP32        GrB_LE_FP32\nGrB_GE_FP64        GrB_LE_FP64\n\nx,y,z all are boolean :\n\nz = (x || y)       z = (x && y)       z = (x != y)\n\nGrB_LOR            GrB_LAND           GrB_LXOR","category":"page"},{"location":"algebra_methods/#Monoids-1","page":"Operators & algebraic structures","title":"Monoids","text":"","category":"section"},{"location":"algebra_methods/#","page":"Operators & algebraic structures","title":"Operators & algebraic structures","text":"MIN monoids:                   Identity\n\nGxB_MIN_INT8_MONOID            INT8_MAX\nGxB_MIN_UINT8_MONOID           UINT8_MAX\nGxB_MIN_INT16_MONOID           INT16_MAX\nGxB_MIN_UINT16_MONOID          UINT16_MAX\nGxB_MIN_INT32_MONOID           INT32_MAX\nGxB_MIN_UINT32_MONOID          UINT32_MAX\nGxB_MIN_INT64_MONOID           INT64_MAX\nGxB_MIN_UINT64_MONOID          UINT64_MAX\nGxB_MIN_FP32_MONOID            INFINITY\nGxB_MIN_FP64_MONOID            INFINITY\n\nMAX monoids:\n\nGxB_MAX_INT8_MONOID            INT8_MIN\nGxB_MAX_UINT8_MONOID           0\nGxB_MAX_INT16_MONOID           INT16_MIN\nGxB_MAX_UINT16_MONOID          0\nGxB_MAX_INT32_MONOID           INT32_MIN\nGxB_MAX_UINT32_MONOID          0\nGxB_MAX_INT64_MONOID           INT64_MIN\nGxB_MAX_UINT64_MONOID          0\nGxB_MAX_FP32_MONOID            -INFINITY\nGxB_MAX_FP64_MONOID            -INFINITY\n\nPLUS monoids:\n\nGxB_PLUS_INT8_MONOID           0\nGxB_PLUS_UINT8_MONOID          0\nGxB_PLUS_INT16_MONOID          0\nGxB_PLUS_UINT16_MONOID         0\nGxB_PLUS_INT32_MONOID          0\nGxB_PLUS_UINT32_MONOID         0\nGxB_PLUS_INT64_MONOID          0\nGxB_PLUS_UINT64_MONOID         0\nGxB_PLUS_FP32_MONOID           0\nGxB_PLUS_FP64_MONOID           0\n\nTIMES monoids:\n\nGxB_TIMES_INT8_MONOID          1\nGxB_TIMES_UINT8_MONOID         1\nGxB_TIMES_INT16_MONOID         1\nGxB_TIMES_UINT16_MONOID        1\nGxB_TIMES_INT32_MONOID         1\nGxB_TIMES_UINT32_MONOID        1\nGxB_TIMES_INT64_MONOID         1\nGxB_TIMES_UINT64_MONOID        1\nGxB_TIMES_FP32_MONOID          1\nGxB_TIMES_FP64_MONOID          1\n\nBoolean monoids:\n\nGxB_LOR_BOOL_MONOID            false\nGxB_LAND_BOOL_MONOID           true\nGxB_LXOR_BOOL_MONOID           false\nGxB_EQ_BOOL_MONOID             true","category":"page"},{"location":"algebra_methods/#Semirings-1","page":"Operators & algebraic structures","title":"Semirings","text":"","category":"section"},{"location":"algebra_methods/#","page":"Operators & algebraic structures","title":"Operators & algebraic structures","text":"Semirings with multiply op: z = FIRST (x,y), all types x,y,z the same:\n\nGxB_MIN_FIRST_INT8      GxB_MAX_FIRST_INT8     GxB_PLUS_FIRST_INT8    GxB_TIMES_FIRST_INT8\nGxB_MIN_FIRST_UINT8     GxB_MAX_FIRST_UINT8    GxB_PLUS_FIRST_UINT8   GxB_TIMES_FIRST_UINT8\nGxB_MIN_FIRST_INT16     GxB_MAX_FIRST_INT16    GxB_PLUS_FIRST_INT16   GxB_TIMES_FIRST_INT16\nGxB_MIN_FIRST_UINT16    GxB_MAX_FIRST_UINT16   GxB_PLUS_FIRST_UINT16  GxB_TIMES_FIRST_UINT16\nGxB_MIN_FIRST_INT32     GxB_MAX_FIRST_INT32    GxB_PLUS_FIRST_INT32   GxB_TIMES_FIRST_INT32\nGxB_MIN_FIRST_UINT32    GxB_MAX_FIRST_UINT32   GxB_PLUS_FIRST_UINT32  GxB_TIMES_FIRST_UINT32\nGxB_MIN_FIRST_INT64     GxB_MAX_FIRST_INT64    GxB_PLUS_FIRST_INT64   GxB_TIMES_FIRST_INT64\nGxB_MIN_FIRST_UINT64    GxB_MAX_FIRST_UINT64   GxB_PLUS_FIRST_UINT64  GxB_TIMES_FIRST_UINT64\nGxB_MIN_FIRST_FP32      GxB_MAX_FIRST_FP32     GxB_PLUS_FIRST_FP32    GxB_TIMES_FIRST_FP32\nGxB_MIN_FIRST_FP64      GxB_MAX_FIRST_FP64     GxB_PLUS_FIRST_FP64    GxB_TIMES_FIRST_FP64\n\nSemirings with multiply op: z = SECOND (x,y), all types x,y,z the same:\n\nGxB_MIN_SECOND_INT8     GxB_MAX_SECOND_INT8    GxB_PLUS_SECOND_INT8   GxB_TIMES_SECOND_INT8\nGxB_MIN_SECOND_UINT8    GxB_MAX_SECOND_UINT8   GxB_PLUS_SECOND_UINT8  GxB_TIMES_SECOND_UINT8\nGxB_MIN_SECOND_INT16    GxB_MAX_SECOND_INT16   GxB_PLUS_SECOND_INT16  GxB_TIMES_SECOND_INT16\nGxB_MIN_SECOND_UINT16   GxB_MAX_SECOND_UINT16  GxB_PLUS_SECOND_UINT16 GxB_TIMES_SECOND_UINT16\nGxB_MIN_SECOND_INT32    GxB_MAX_SECOND_INT32   GxB_PLUS_SECOND_INT32  GxB_TIMES_SECOND_INT32\nGxB_MIN_SECOND_UINT32   GxB_MAX_SECOND_UINT32  GxB_PLUS_SECOND_UINT32 GxB_TIMES_SECOND_UINT32\nGxB_MIN_SECOND_INT64    GxB_MAX_SECOND_INT64   GxB_PLUS_SECOND_INT64  GxB_TIMES_SECOND_INT64\nGxB_MIN_SECOND_UINT64   GxB_MAX_SECOND_UINT64  GxB_PLUS_SECOND_UINT64 GxB_TIMES_SECOND_UINT64\nGxB_MIN_SECOND_FP32     GxB_MAX_SECOND_FP32    GxB_PLUS_SECOND_FP32   GxB_TIMES_SECOND_FP32\nGxB_MIN_SECOND_FP64     GxB_MAX_SECOND_FP64    GxB_PLUS_SECOND_FP64   GxB_TIMES_SECOND_FP64\n\nSemirings with multiply op: z = MIN (x,y), all types x,y,z the same:\n\nGxB_MIN_MIN_INT8        GxB_MAX_MIN_INT8       GxB_PLUS_MIN_INT8      GxB_TIMES_MIN_INT8\nGxB_MIN_MIN_UINT8       GxB_MAX_MIN_UINT8      GxB_PLUS_MIN_UINT8     GxB_TIMES_MIN_UINT8\nGxB_MIN_MIN_INT16       GxB_MAX_MIN_INT16      GxB_PLUS_MIN_INT16     GxB_TIMES_MIN_INT16\nGxB_MIN_MIN_UINT16      GxB_MAX_MIN_UINT16     GxB_PLUS_MIN_UINT16    GxB_TIMES_MIN_UINT16\nGxB_MIN_MIN_INT32       GxB_MAX_MIN_INT32      GxB_PLUS_MIN_INT32     GxB_TIMES_MIN_INT32\nGxB_MIN_MIN_UINT32      GxB_MAX_MIN_UINT32     GxB_PLUS_MIN_UINT32    GxB_TIMES_MIN_UINT32\nGxB_MIN_MIN_INT64       GxB_MAX_MIN_INT64      GxB_PLUS_MIN_INT64     GxB_TIMES_MIN_INT64\nGxB_MIN_MIN_UINT64      GxB_MAX_MIN_UINT64     GxB_PLUS_MIN_UINT64    GxB_TIMES_MIN_UINT64\nGxB_MIN_MIN_FP32        GxB_MAX_MIN_FP32       GxB_PLUS_MIN_FP32      GxB_TIMES_MIN_FP32\nGxB_MIN_MIN_FP64        GxB_MAX_MIN_FP64       GxB_PLUS_MIN_FP64      GxB_TIMES_MIN_FP64\n\nSemirings with multiply op: z = MAX (x,y), all types x,y,z the same:\n\nGxB_MIN_MAX_INT8        GxB_MAX_MAX_INT8       GxB_PLUS_MAX_INT8      GxB_TIMES_MAX_INT8\nGxB_MIN_MAX_UINT8       GxB_MAX_MAX_UINT8      GxB_PLUS_MAX_UINT8     GxB_TIMES_MAX_UINT8\nGxB_MIN_MAX_INT16       GxB_MAX_MAX_INT16      GxB_PLUS_MAX_INT16     GxB_TIMES_MAX_INT16\nGxB_MIN_MAX_UINT16      GxB_MAX_MAX_UINT16     GxB_PLUS_MAX_UINT16    GxB_TIMES_MAX_UINT16\nGxB_MIN_MAX_INT32       GxB_MAX_MAX_INT32      GxB_PLUS_MAX_INT32     GxB_TIMES_MAX_INT32\nGxB_MIN_MAX_UINT32      GxB_MAX_MAX_UINT32     GxB_PLUS_MAX_UINT32    GxB_TIMES_MAX_UINT32\nGxB_MIN_MAX_INT64       GxB_MAX_MAX_INT64      GxB_PLUS_MAX_INT64     GxB_TIMES_MAX_INT64\nGxB_MIN_MAX_UINT64      GxB_MAX_MAX_UINT64     GxB_PLUS_MAX_UINT64    GxB_TIMES_MAX_UINT64\nGxB_MIN_MAX_FP32        GxB_MAX_MAX_FP32       GxB_PLUS_MAX_FP32      GxB_TIMES_MAX_FP32\nGxB_MIN_MAX_FP64        GxB_MAX_MAX_FP64       GxB_PLUS_MAX_FP64      GxB_TIMES_MAX_FP64\n\nSemirings with multiply op: z = PLUS (x,y), all types x,y,z the same:\n\nGxB_MIN_PLUS_INT8       GxB_MAX_PLUS_INT8      GxB_PLUS_PLUS_INT8     GxB_TIMES_PLUS_INT8\nGxB_MIN_PLUS_UINT8      GxB_MAX_PLUS_UINT8     GxB_PLUS_PLUS_UINT8    GxB_TIMES_PLUS_UINT8\nGxB_MIN_PLUS_INT16      GxB_MAX_PLUS_INT16     GxB_PLUS_PLUS_INT16    GxB_TIMES_PLUS_INT16\nGxB_MIN_PLUS_UINT16     GxB_MAX_PLUS_UINT16    GxB_PLUS_PLUS_UINT16   GxB_TIMES_PLUS_UINT16\nGxB_MIN_PLUS_INT32      GxB_MAX_PLUS_INT32     GxB_PLUS_PLUS_INT32    GxB_TIMES_PLUS_INT32\nGxB_MIN_PLUS_UINT32     GxB_MAX_PLUS_UINT32    GxB_PLUS_PLUS_UINT32   GxB_TIMES_PLUS_UINT32\nGxB_MIN_PLUS_INT64      GxB_MAX_PLUS_INT64     GxB_PLUS_PLUS_INT64    GxB_TIMES_PLUS_INT64\nGxB_MIN_PLUS_UINT64     GxB_MAX_PLUS_UINT64    GxB_PLUS_PLUS_UINT64   GxB_TIMES_PLUS_UINT64\nGxB_MIN_PLUS_FP32       GxB_MAX_PLUS_FP32      GxB_PLUS_PLUS_FP32     GxB_TIMES_PLUS_FP32\nGxB_MIN_PLUS_FP64       GxB_MAX_PLUS_FP64      GxB_PLUS_PLUS_FP64     GxB_TIMES_PLUS_FP64\n\nSemirings with multiply op: z = MINUS (x,y), all types x,y,z the same:\n\nGxB_MIN_MINUS_INT8     GxB_MAX_MINUS_INT8     GxB_PLUS_MINUS_INT8    GxB_TIMES_MINUS_INT8\nGxB_MIN_MINUS_UINT8    GxB_MAX_MINUS_UINT8    GxB_PLUS_MINUS_UINT8   GxB_TIMES_MINUS_UINT8\nGxB_MIN_MINUS_INT16    GxB_MAX_MINUS_INT16    GxB_PLUS_MINUS_INT16   GxB_TIMES_MINUS_INT16\nGxB_MIN_MINUS_UINT16   GxB_MAX_MINUS_UINT16   GxB_PLUS_MINUS_UINT16  GxB_TIMES_MINUS_UINT16\nGxB_MIN_MINUS_INT32    GxB_MAX_MINUS_INT32    GxB_PLUS_MINUS_INT32   GxB_TIMES_MINUS_INT32\nGxB_MIN_MINUS_UINT32   GxB_MAX_MINUS_UINT32   GxB_PLUS_MINUS_UINT32  GxB_TIMES_MINUS_UINT32\nGxB_MIN_MINUS_INT64    GxB_MAX_MINUS_INT64    GxB_PLUS_MINUS_INT64   GxB_TIMES_MINUS_INT64\nGxB_MIN_MINUS_UINT64   GxB_MAX_MINUS_UINT64   GxB_PLUS_MINUS_UINT64  GxB_TIMES_MINUS_UINT64\nGxB_MIN_MINUS_FP32     GxB_MAX_MINUS_FP32     GxB_PLUS_MINUS_FP32    GxB_TIMES_MINUS_FP32\nGxB_MIN_MINUS_FP64     GxB_MAX_MINUS_FP64     GxB_PLUS_MINUS_FP64    GxB_TIMES_MINUS_FP64\n\nSemirings with multiply op: z = TIMES (x,y), all types x,y,z the same:\n\nGxB_MIN_TIMES_INT8     GxB_MAX_TIMES_INT8     GxB_PLUS_TIMES_INT8    GxB_TIMES_TIMES_INT8\nGxB_MIN_TIMES_UINT8    GxB_MAX_TIMES_UINT8    GxB_PLUS_TIMES_UINT8   GxB_TIMES_TIMES_UINT8\nGxB_MIN_TIMES_INT16    GxB_MAX_TIMES_INT16    GxB_PLUS_TIMES_INT16   GxB_TIMES_TIMES_INT16\nGxB_MIN_TIMES_UINT16   GxB_MAX_TIMES_UINT16   GxB_PLUS_TIMES_UINT16  GxB_TIMES_TIMES_UINT16\nGxB_MIN_TIMES_INT32    GxB_MAX_TIMES_INT32    GxB_PLUS_TIMES_INT32   GxB_TIMES_TIMES_INT32\nGxB_MIN_TIMES_UINT32   GxB_MAX_TIMES_UINT32   GxB_PLUS_TIMES_UINT32  GxB_TIMES_TIMES_UINT32\nGxB_MIN_TIMES_INT64    GxB_MAX_TIMES_INT64    GxB_PLUS_TIMES_INT64   GxB_TIMES_TIMES_INT64\nGxB_MIN_TIMES_UINT64   GxB_MAX_TIMES_UINT64   GxB_PLUS_TIMES_UINT64  GxB_TIMES_TIMES_UINT64\nGxB_MIN_TIMES_FP32     GxB_MAX_TIMES_FP32     GxB_PLUS_TIMES_FP32    GxB_TIMES_TIMES_FP32\nGxB_MIN_TIMES_FP64     GxB_MAX_TIMES_FP64     GxB_PLUS_TIMES_FP64    GxB_TIMES_TIMES_FP64\n\nSemirings with multiply op: z = DIV (x,y), all types x,y,z the same:\n\nGxB_MIN_DIV_INT8       GxB_MAX_DIV_INT8       GxB_PLUS_DIV_INT8      GxB_TIMES_DIV_INT8\nGxB_MIN_DIV_UINT8      GxB_MAX_DIV_UINT8      GxB_PLUS_DIV_UINT8     GxB_TIMES_DIV_UINT8\nGxB_MIN_DIV_INT16      GxB_MAX_DIV_INT16      GxB_PLUS_DIV_INT16     GxB_TIMES_DIV_INT16\nGxB_MIN_DIV_UINT16     GxB_MAX_DIV_UINT16     GxB_PLUS_DIV_UINT16    GxB_TIMES_DIV_UINT16\nGxB_MIN_DIV_INT32      GxB_MAX_DIV_INT32      GxB_PLUS_DIV_INT32     GxB_TIMES_DIV_INT32\nGxB_MIN_DIV_UINT32     GxB_MAX_DIV_UINT32     GxB_PLUS_DIV_UINT32    GxB_TIMES_DIV_UINT32\nGxB_MIN_DIV_INT64      GxB_MAX_DIV_INT64      GxB_PLUS_DIV_INT64     GxB_TIMES_DIV_INT64\nGxB_MIN_DIV_UINT64     GxB_MAX_DIV_UINT64     GxB_PLUS_DIV_UINT64    GxB_TIMES_DIV_UINT64\nGxB_MIN_DIV_FP32       GxB_MAX_DIV_FP32       GxB_PLUS_DIV_FP32      GxB_TIMES_DIV_FP32\nGxB_MIN_DIV_FP64       GxB_MAX_DIV_FP64       GxB_PLUS_DIV_FP64      GxB_TIMES_DIV_FP64\n\nSemirings with multiply op: z = ISEQ (x,y), all types x,y,z the same:\n\nGxB_MIN_ISEQ_INT8      GxB_MAX_ISEQ_INT8      GxB_PLUS_ISEQ_INT8     GxB_TIMES_ISEQ_INT8\nGxB_MIN_ISEQ_UINT8     GxB_MAX_ISEQ_UINT8     GxB_PLUS_ISEQ_UINT8    GxB_TIMES_ISEQ_UINT8\nGxB_MIN_ISEQ_INT16     GxB_MAX_ISEQ_INT16     GxB_PLUS_ISEQ_INT16    GxB_TIMES_ISEQ_INT16\nGxB_MIN_ISEQ_UINT16    GxB_MAX_ISEQ_UINT16    GxB_PLUS_ISEQ_UINT16   GxB_TIMES_ISEQ_UINT16\nGxB_MIN_ISEQ_INT32     GxB_MAX_ISEQ_INT32     GxB_PLUS_ISEQ_INT32    GxB_TIMES_ISEQ_INT32\nGxB_MIN_ISEQ_UINT32    GxB_MAX_ISEQ_UINT32    GxB_PLUS_ISEQ_UINT32   GxB_TIMES_ISEQ_UINT32\nGxB_MIN_ISEQ_INT64     GxB_MAX_ISEQ_INT64     GxB_PLUS_ISEQ_INT64    GxB_TIMES_ISEQ_INT64\nGxB_MIN_ISEQ_UINT64    GxB_MAX_ISEQ_UINT64    GxB_PLUS_ISEQ_UINT64   GxB_TIMES_ISEQ_UINT64\nGxB_MIN_ISEQ_FP32      GxB_MAX_ISEQ_FP32      GxB_PLUS_ISEQ_FP32     GxB_TIMES_ISEQ_FP32\nGxB_MIN_ISEQ_FP64      GxB_MAX_ISEQ_FP64      GxB_PLUS_ISEQ_FP64     GxB_TIMES_ISEQ_FP64\n\nSemirings with multiply op: z = ISNE (x,y), all types x,y,z the same:\n\nGxB_MIN_ISNE_INT8      GxB_MAX_ISNE_INT8      GxB_PLUS_ISNE_INT8     GxB_TIMES_ISNE_INT8\nGxB_MIN_ISNE_UINT8     GxB_MAX_ISNE_UINT8     GxB_PLUS_ISNE_UINT8    GxB_TIMES_ISNE_UINT8\nGxB_MIN_ISNE_INT16     GxB_MAX_ISNE_INT16     GxB_PLUS_ISNE_INT16    GxB_TIMES_ISNE_INT16\nGxB_MIN_ISNE_UINT16    GxB_MAX_ISNE_UINT16    GxB_PLUS_ISNE_UINT16   GxB_TIMES_ISNE_UINT16\nGxB_MIN_ISNE_INT32     GxB_MAX_ISNE_INT32     GxB_PLUS_ISNE_INT32    GxB_TIMES_ISNE_INT32\nGxB_MIN_ISNE_UINT32    GxB_MAX_ISNE_UINT32    GxB_PLUS_ISNE_UINT32   GxB_TIMES_ISNE_UINT32\nGxB_MIN_ISNE_INT64     GxB_MAX_ISNE_INT64     GxB_PLUS_ISNE_INT64    GxB_TIMES_ISNE_INT64\nGxB_MIN_ISNE_UINT64    GxB_MAX_ISNE_UINT64    GxB_PLUS_ISNE_UINT64   GxB_TIMES_ISNE_UINT64\nGxB_MIN_ISNE_FP32      GxB_MAX_ISNE_FP32      GxB_PLUS_ISNE_FP32     GxB_TIMES_ISNE_FP32\nGxB_MIN_ISNE_FP64      GxB_MAX_ISNE_FP64      GxB_PLUS_ISNE_FP64     GxB_TIMES_ISNE_FP64\n\nSemirings with multiply op: z = ISGT (x,y), all types x,y,z the same:\n\nGxB_MIN_ISGT_INT8      GxB_MAX_ISGT_INT8      GxB_PLUS_ISGT_INT8     GxB_TIMES_ISGT_INT8\nGxB_MIN_ISGT_UINT8     GxB_MAX_ISGT_UINT8     GxB_PLUS_ISGT_UINT8    GxB_TIMES_ISGT_UINT8\nGxB_MIN_ISGT_INT16     GxB_MAX_ISGT_INT16     GxB_PLUS_ISGT_INT16    GxB_TIMES_ISGT_INT16\nGxB_MIN_ISGT_UINT16    GxB_MAX_ISGT_UINT16    GxB_PLUS_ISGT_UINT16   GxB_TIMES_ISGT_UINT16\nGxB_MIN_ISGT_INT32     GxB_MAX_ISGT_INT32     GxB_PLUS_ISGT_INT32    GxB_TIMES_ISGT_INT32\nGxB_MIN_ISGT_UINT32    GxB_MAX_ISGT_UINT32    GxB_PLUS_ISGT_UINT32   GxB_TIMES_ISGT_UINT32\nGxB_MIN_ISGT_INT64     GxB_MAX_ISGT_INT64     GxB_PLUS_ISGT_INT64    GxB_TIMES_ISGT_INT64\nGxB_MIN_ISGT_UINT64    GxB_MAX_ISGT_UINT64    GxB_PLUS_ISGT_UINT64   GxB_TIMES_ISGT_UINT64\nGxB_MIN_ISGT_FP32      GxB_MAX_ISGT_FP32      GxB_PLUS_ISGT_FP32     GxB_TIMES_ISGT_FP32\nGxB_MIN_ISGT_FP64      GxB_MAX_ISGT_FP64      GxB_PLUS_ISGT_FP64     GxB_TIMES_ISGT_FP64\n\nSemirings with multiply op: z = ISLT (x,y), all types x,y,z the same:\n\nGxB_MIN_ISLT_INT8      GxB_MAX_ISLT_INT8      GxB_PLUS_ISLT_INT8     GxB_TIMES_ISLT_INT8\nGxB_MIN_ISLT_UINT8     GxB_MAX_ISLT_UINT8     GxB_PLUS_ISLT_UINT8    GxB_TIMES_ISLT_UINT8\nGxB_MIN_ISLT_INT16     GxB_MAX_ISLT_INT16     GxB_PLUS_ISLT_INT16    GxB_TIMES_ISLT_INT16\nGxB_MIN_ISLT_UINT16    GxB_MAX_ISLT_UINT16    GxB_PLUS_ISLT_UINT16   GxB_TIMES_ISLT_UINT16\nGxB_MIN_ISLT_INT32     GxB_MAX_ISLT_INT32     GxB_PLUS_ISLT_INT32    GxB_TIMES_ISLT_INT32\nGxB_MIN_ISLT_UINT32    GxB_MAX_ISLT_UINT32    GxB_PLUS_ISLT_UINT32   GxB_TIMES_ISLT_UINT32\nGxB_MIN_ISLT_INT64     GxB_MAX_ISLT_INT64     GxB_PLUS_ISLT_INT64    GxB_TIMES_ISLT_INT64\nGxB_MIN_ISLT_UINT64    GxB_MAX_ISLT_UINT64    GxB_PLUS_ISLT_UINT64   GxB_TIMES_ISLT_UINT64\nGxB_MIN_ISLT_FP32      GxB_MAX_ISLT_FP32      GxB_PLUS_ISLT_FP32     GxB_TIMES_ISLT_FP32\nGxB_MIN_ISLT_FP64      GxB_MAX_ISLT_FP64      GxB_PLUS_ISLT_FP64     GxB_TIMES_ISLT_FP64\n\nSemirings with multiply op: z = ISGE (x,y), all types x,y,z the same:\n\nGxB_MIN_ISGE_INT8      GxB_MAX_ISGE_INT8      GxB_PLUS_ISGE_INT8     GxB_TIMES_ISGE_INT8\nGxB_MIN_ISGE_UINT8     GxB_MAX_ISGE_UINT8     GxB_PLUS_ISGE_UINT8    GxB_TIMES_ISGE_UINT8\nGxB_MIN_ISGE_INT16     GxB_MAX_ISGE_INT16     GxB_PLUS_ISGE_INT16    GxB_TIMES_ISGE_INT16\nGxB_MIN_ISGE_UINT16    GxB_MAX_ISGE_UINT16    GxB_PLUS_ISGE_UINT16   GxB_TIMES_ISGE_UINT16\nGxB_MIN_ISGE_INT32     GxB_MAX_ISGE_INT32     GxB_PLUS_ISGE_INT32    GxB_TIMES_ISGE_INT32\nGxB_MIN_ISGE_UINT32    GxB_MAX_ISGE_UINT32    GxB_PLUS_ISGE_UINT32   GxB_TIMES_ISGE_UINT32\nGxB_MIN_ISGE_INT64     GxB_MAX_ISGE_INT64     GxB_PLUS_ISGE_INT64    GxB_TIMES_ISGE_INT64\nGxB_MIN_ISGE_UINT64    GxB_MAX_ISGE_UINT64    GxB_PLUS_ISGE_UINT64   GxB_TIMES_ISGE_UINT64\nGxB_MIN_ISGE_FP32      GxB_MAX_ISGE_FP32      GxB_PLUS_ISGE_FP32     GxB_TIMES_ISGE_FP32\nGxB_MIN_ISGE_FP64      GxB_MAX_ISGE_FP64      GxB_PLUS_ISGE_FP64     GxB_TIMES_ISGE_FP64\n\nSemirings with multiply op: z = ISLE (x,y), all types x,y,z the same:\n\nGxB_MIN_ISLE_INT8      GxB_MAX_ISLE_INT8      GxB_PLUS_ISLE_INT8     GxB_TIMES_ISLE_INT8\nGxB_MIN_ISLE_UINT8     GxB_MAX_ISLE_UINT8     GxB_PLUS_ISLE_UINT8    GxB_TIMES_ISLE_UINT8\nGxB_MIN_ISLE_INT16     GxB_MAX_ISLE_INT16     GxB_PLUS_ISLE_INT16    GxB_TIMES_ISLE_INT16\nGxB_MIN_ISLE_UINT16    GxB_MAX_ISLE_UINT16    GxB_PLUS_ISLE_UINT16   GxB_TIMES_ISLE_UINT16\nGxB_MIN_ISLE_INT32     GxB_MAX_ISLE_INT32     GxB_PLUS_ISLE_INT32    GxB_TIMES_ISLE_INT32\nGxB_MIN_ISLE_UINT32    GxB_MAX_ISLE_UINT32    GxB_PLUS_ISLE_UINT32   GxB_TIMES_ISLE_UINT32\nGxB_MIN_ISLE_INT64     GxB_MAX_ISLE_INT64     GxB_PLUS_ISLE_INT64    GxB_TIMES_ISLE_INT64\nGxB_MIN_ISLE_UINT64    GxB_MAX_ISLE_UINT64    GxB_PLUS_ISLE_UINT64   GxB_TIMES_ISLE_UINT64\nGxB_MIN_ISLE_FP32      GxB_MAX_ISLE_FP32      GxB_PLUS_ISLE_FP32     GxB_TIMES_ISLE_FP32\nGxB_MIN_ISLE_FP64      GxB_MAX_ISLE_FP64      GxB_PLUS_ISLE_FP64     GxB_TIMES_ISLE_FP64\n\nSemirings with multiply op: z = LOR (x,y), all types x,y,z the same:\n\nGxB_MIN_LOR_INT8       GxB_MAX_LOR_INT8       GxB_PLUS_LOR_INT8      GxB_TIMES_LOR_INT8\nGxB_MIN_LOR_UINT8      GxB_MAX_LOR_UINT8      GxB_PLUS_LOR_UINT8     GxB_TIMES_LOR_UINT8\nGxB_MIN_LOR_INT16      GxB_MAX_LOR_INT16      GxB_PLUS_LOR_INT16     GxB_TIMES_LOR_INT16\nGxB_MIN_LOR_UINT16     GxB_MAX_LOR_UINT16     GxB_PLUS_LOR_UINT16    GxB_TIMES_LOR_UINT16\nGxB_MIN_LOR_INT32      GxB_MAX_LOR_INT32      GxB_PLUS_LOR_INT32     GxB_TIMES_LOR_INT32\nGxB_MIN_LOR_UINT32     GxB_MAX_LOR_UINT32     GxB_PLUS_LOR_UINT32    GxB_TIMES_LOR_UINT32\nGxB_MIN_LOR_INT64      GxB_MAX_LOR_INT64      GxB_PLUS_LOR_INT64     GxB_TIMES_LOR_INT64\nGxB_MIN_LOR_UINT64     GxB_MAX_LOR_UINT64     GxB_PLUS_LOR_UINT64    GxB_TIMES_LOR_UINT64\nGxB_MIN_LOR_FP32       GxB_MAX_LOR_FP32       GxB_PLUS_LOR_FP32      GxB_TIMES_LOR_FP32\nGxB_MIN_LOR_FP64       GxB_MAX_LOR_FP64       GxB_PLUS_LOR_FP64      GxB_TIMES_LOR_FP64\n\nSemirings with multiply op: z = LAND (x,y), all types x,y,z the same:\n\nGxB_MIN_LAND_INT8      GxB_MAX_LAND_INT8      GxB_PLUS_LAND_INT8     GxB_TIMES_LAND_INT8\nGxB_MIN_LAND_UINT8     GxB_MAX_LAND_UINT8     GxB_PLUS_LAND_UINT8    GxB_TIMES_LAND_UINT8\nGxB_MIN_LAND_INT16     GxB_MAX_LAND_INT16     GxB_PLUS_LAND_INT16    GxB_TIMES_LAND_INT16\nGxB_MIN_LAND_UINT16    GxB_MAX_LAND_UINT16    GxB_PLUS_LAND_UINT16   GxB_TIMES_LAND_UINT16\nGxB_MIN_LAND_INT32     GxB_MAX_LAND_INT32     GxB_PLUS_LAND_INT32    GxB_TIMES_LAND_INT32\nGxB_MIN_LAND_UINT32    GxB_MAX_LAND_UINT32    GxB_PLUS_LAND_UINT32   GxB_TIMES_LAND_UINT32\nGxB_MIN_LAND_INT64     GxB_MAX_LAND_INT64     GxB_PLUS_LAND_INT64    GxB_TIMES_LAND_INT64\nGxB_MIN_LAND_UINT64    GxB_MAX_LAND_UINT64    GxB_PLUS_LAND_UINT64   GxB_TIMES_LAND_UINT64\nGxB_MIN_LAND_FP32      GxB_MAX_LAND_FP32      GxB_PLUS_LAND_FP32     GxB_TIMES_LAND_FP32\nGxB_MIN_LAND_FP64      GxB_MAX_LAND_FP64      GxB_PLUS_LAND_FP64     GxB_TIMES_LAND_FP64\n\nSemirings with multiply op: z = LXOR (x,y), all types x,y,z the same:\n\nGxB_MIN_LXOR_INT8      GxB_MAX_LXOR_INT8      GxB_PLUS_LXOR_INT8     GxB_TIMES_LXOR_INT8\nGxB_MIN_LXOR_UINT8     GxB_MAX_LXOR_UINT8     GxB_PLUS_LXOR_UINT8    GxB_TIMES_LXOR_UINT8\nGxB_MIN_LXOR_INT16     GxB_MAX_LXOR_INT16     GxB_PLUS_LXOR_INT16    GxB_TIMES_LXOR_INT16\nGxB_MIN_LXOR_UINT16    GxB_MAX_LXOR_UINT16    GxB_PLUS_LXOR_UINT16   GxB_TIMES_LXOR_UINT16\nGxB_MIN_LXOR_INT32     GxB_MAX_LXOR_INT32     GxB_PLUS_LXOR_INT32    GxB_TIMES_LXOR_INT32\nGxB_MIN_LXOR_UINT32    GxB_MAX_LXOR_UINT32    GxB_PLUS_LXOR_UINT32   GxB_TIMES_LXOR_UINT32\nGxB_MIN_LXOR_INT64     GxB_MAX_LXOR_INT64     GxB_PLUS_LXOR_INT64    GxB_TIMES_LXOR_INT64\nGxB_MIN_LXOR_UINT64    GxB_MAX_LXOR_UINT64    GxB_PLUS_LXOR_UINT64   GxB_TIMES_LXOR_UINT64\nGxB_MIN_LXOR_FP32      GxB_MAX_LXOR_FP32      GxB_PLUS_LXOR_FP32     GxB_TIMES_LXOR_FP32\nGxB_MIN_LXOR_FP64      GxB_MAX_LXOR_FP64      GxB_PLUS_LXOR_FP64     GxB_TIMES_LXOR_FP64\n\nSemirings with multiply op: z = EQ (x,y), where z is Boolean and x,y are given by the suffix:\n\nGxB_LOR_EQ_INT8        GxB_LAND_EQ_INT8       GxB_LXOR_EQ_INT8       GxB_EQ_EQ_INT8\nGxB_LOR_EQ_UINT8       GxB_LAND_EQ_UINT8      GxB_LXOR_EQ_UINT8      GxB_EQ_EQ_UINT8\nGxB_LOR_EQ_INT16       GxB_LAND_EQ_INT16      GxB_LXOR_EQ_INT16      GxB_EQ_EQ_INT16\nGxB_LOR_EQ_UINT16      GxB_LAND_EQ_UINT16     GxB_LXOR_EQ_UINT16     GxB_EQ_EQ_UINT16\nGxB_LOR_EQ_INT32       GxB_LAND_EQ_INT32      GxB_LXOR_EQ_INT32      GxB_EQ_EQ_INT32\nGxB_LOR_EQ_UINT32      GxB_LAND_EQ_UINT32     GxB_LXOR_EQ_UINT32     GxB_EQ_EQ_UINT32\nGxB_LOR_EQ_INT64       GxB_LAND_EQ_INT64      GxB_LXOR_EQ_INT64      GxB_EQ_EQ_INT64\nGxB_LOR_EQ_UINT64      GxB_LAND_EQ_UINT64     GxB_LXOR_EQ_UINT64     GxB_EQ_EQ_UINT64\nGxB_LOR_EQ_FP32        GxB_LAND_EQ_FP32       GxB_LXOR_EQ_FP32       GxB_EQ_EQ_FP32\nGxB_LOR_EQ_FP64        GxB_LAND_EQ_FP64       GxB_LXOR_EQ_FP64       GxB_EQ_EQ_FP64\n\nSemirings with multiply op: z = NE (x,y), where z is Boolean and x,y are given by the suffix:\n\nGxB_LOR_NE_INT8        GxB_LAND_NE_INT8       GxB_LXOR_NE_INT8       GxB_EQ_NE_INT8\nGxB_LOR_NE_UINT8       GxB_LAND_NE_UINT8      GxB_LXOR_NE_UINT8      GxB_EQ_NE_UINT8\nGxB_LOR_NE_INT16       GxB_LAND_NE_INT16      GxB_LXOR_NE_INT16      GxB_EQ_NE_INT16\nGxB_LOR_NE_UINT16      GxB_LAND_NE_UINT16     GxB_LXOR_NE_UINT16     GxB_EQ_NE_UINT16\nGxB_LOR_NE_INT32       GxB_LAND_NE_INT32      GxB_LXOR_NE_INT32      GxB_EQ_NE_INT32\nGxB_LOR_NE_UINT32      GxB_LAND_NE_UINT32     GxB_LXOR_NE_UINT32     GxB_EQ_NE_UINT32\nGxB_LOR_NE_INT64       GxB_LAND_NE_INT64      GxB_LXOR_NE_INT64      GxB_EQ_NE_INT64\nGxB_LOR_NE_UINT64      GxB_LAND_NE_UINT64     GxB_LXOR_NE_UINT64     GxB_EQ_NE_UINT64\nGxB_LOR_NE_FP32        GxB_LAND_NE_FP32       GxB_LXOR_NE_FP32       GxB_EQ_NE_FP32\nGxB_LOR_NE_FP64        GxB_LAND_NE_FP64       GxB_LXOR_NE_FP64       GxB_EQ_NE_FP64\n\nSemirings with multiply op: z = GT (x,y), where z is Boolean and x,y are given by the suffix:\n\nGxB_LOR_GT_INT8        GxB_LAND_GT_INT8       GxB_LXOR_GT_INT8       GxB_EQ_GT_INT8\nGxB_LOR_GT_UINT8       GxB_LAND_GT_UINT8      GxB_LXOR_GT_UINT8      GxB_EQ_GT_UINT8\nGxB_LOR_GT_INT16       GxB_LAND_GT_INT16      GxB_LXOR_GT_INT16      GxB_EQ_GT_INT16\nGxB_LOR_GT_UINT16      GxB_LAND_GT_UINT16     GxB_LXOR_GT_UINT16     GxB_EQ_GT_UINT16\nGxB_LOR_GT_INT32       GxB_LAND_GT_INT32      GxB_LXOR_GT_INT32      GxB_EQ_GT_INT32\nGxB_LOR_GT_UINT32      GxB_LAND_GT_UINT32     GxB_LXOR_GT_UINT32     GxB_EQ_GT_UINT32\nGxB_LOR_GT_INT64       GxB_LAND_GT_INT64      GxB_LXOR_GT_INT64      GxB_EQ_GT_INT64\nGxB_LOR_GT_UINT64      GxB_LAND_GT_UINT64     GxB_LXOR_GT_UINT64     GxB_EQ_GT_UINT64\nGxB_LOR_GT_FP32        GxB_LAND_GT_FP32       GxB_LXOR_GT_FP32       GxB_EQ_GT_FP32\nGxB_LOR_GT_FP64        GxB_LAND_GT_FP64       GxB_LXOR_GT_FP64       GxB_EQ_GT_FP64\n\nSemirings with multiply op: z = LT (x,y), where z is Boolean and x,y are given by the suffix:\n\nGxB_LOR_LT_INT8        GxB_LAND_LT_INT8       GxB_LXOR_LT_INT8       GxB_EQ_LT_INT8\nGxB_LOR_LT_UINT8       GxB_LAND_LT_UINT8      GxB_LXOR_LT_UINT8      GxB_EQ_LT_UINT8\nGxB_LOR_LT_INT16       GxB_LAND_LT_INT16      GxB_LXOR_LT_INT16      GxB_EQ_LT_INT16\nGxB_LOR_LT_UINT16      GxB_LAND_LT_UINT16     GxB_LXOR_LT_UINT16     GxB_EQ_LT_UINT16\nGxB_LOR_LT_INT32       GxB_LAND_LT_INT32      GxB_LXOR_LT_INT32      GxB_EQ_LT_INT32\nGxB_LOR_LT_UINT32      GxB_LAND_LT_UINT32     GxB_LXOR_LT_UINT32     GxB_EQ_LT_UINT32\nGxB_LOR_LT_INT64       GxB_LAND_LT_INT64      GxB_LXOR_LT_INT64      GxB_EQ_LT_INT64\nGxB_LOR_LT_UINT64      GxB_LAND_LT_UINT64     GxB_LXOR_LT_UINT64     GxB_EQ_LT_UINT64\nGxB_LOR_LT_FP32        GxB_LAND_LT_FP32       GxB_LXOR_LT_FP32       GxB_EQ_LT_FP32\nGxB_LOR_LT_FP64        GxB_LAND_LT_FP64       GxB_LXOR_LT_FP64       GxB_EQ_LT_FP64\n\nSemirings with multiply op: z = GE (x,y), where z is Boolean and x,y are given by the suffix:\n\nGxB_LOR_GE_INT8        GxB_LAND_GE_INT8       GxB_LXOR_GE_INT8       GxB_EQ_GE_INT8\nGxB_LOR_GE_UINT8       GxB_LAND_GE_UINT8      GxB_LXOR_GE_UINT8      GxB_EQ_GE_UINT8\nGxB_LOR_GE_INT16       GxB_LAND_GE_INT16      GxB_LXOR_GE_INT16      GxB_EQ_GE_INT16\nGxB_LOR_GE_UINT16      GxB_LAND_GE_UINT16     GxB_LXOR_GE_UINT16     GxB_EQ_GE_UINT16\nGxB_LOR_GE_INT32       GxB_LAND_GE_INT32      GxB_LXOR_GE_INT32      GxB_EQ_GE_INT32\nGxB_LOR_GE_UINT32      GxB_LAND_GE_UINT32     GxB_LXOR_GE_UINT32     GxB_EQ_GE_UINT32\nGxB_LOR_GE_INT64       GxB_LAND_GE_INT64      GxB_LXOR_GE_INT64      GxB_EQ_GE_INT64\nGxB_LOR_GE_UINT64      GxB_LAND_GE_UINT64     GxB_LXOR_GE_UINT64     GxB_EQ_GE_UINT64\nGxB_LOR_GE_FP32        GxB_LAND_GE_FP32       GxB_LXOR_GE_FP32       GxB_EQ_GE_FP32\nGxB_LOR_GE_FP64        GxB_LAND_GE_FP64       GxB_LXOR_GE_FP64       GxB_EQ_GE_FP64\n\nSemirings with multiply op: z = LE (x,y), where z is Boolean and x,y are given by the suffix:\n\nGxB_LOR_LE_INT8        GxB_LAND_LE_INT8       GxB_LXOR_LE_INT8       GxB_EQ_LE_INT8\nGxB_LOR_LE_UINT8       GxB_LAND_LE_UINT8      GxB_LXOR_LE_UINT8      GxB_EQ_LE_UINT8\nGxB_LOR_LE_INT16       GxB_LAND_LE_INT16      GxB_LXOR_LE_INT16      GxB_EQ_LE_INT16\nGxB_LOR_LE_UINT16      GxB_LAND_LE_UINT16     GxB_LXOR_LE_UINT16     GxB_EQ_LE_UINT16\nGxB_LOR_LE_INT32       GxB_LAND_LE_INT32      GxB_LXOR_LE_INT32      GxB_EQ_LE_INT32\nGxB_LOR_LE_UINT32      GxB_LAND_LE_UINT32     GxB_LXOR_LE_UINT32     GxB_EQ_LE_UINT32\nGxB_LOR_LE_INT64       GxB_LAND_LE_INT64      GxB_LXOR_LE_INT64      GxB_EQ_LE_INT64\nGxB_LOR_LE_UINT64      GxB_LAND_LE_UINT64     GxB_LXOR_LE_UINT64     GxB_EQ_LE_UINT64\nGxB_LOR_LE_FP32        GxB_LAND_LE_FP32       GxB_LXOR_LE_FP32       GxB_EQ_LE_FP32\nGxB_LOR_LE_FP64        GxB_LAND_LE_FP64       GxB_LXOR_LE_FP64       GxB_EQ_LE_FP64\n\nPurely boolean semirings (in the form GxB_(add monoid)_(multipy operator)_BOOL:\n\nGxB_LOR_FIRST_BOOL     GxB_LAND_FIRST_BOOL    GxB_LXOR_FIRST_BOOL    GxB_EQ_FIRST_BOOL\nGxB_LOR_SECOND_BOOL    GxB_LAND_SECOND_BOOL   GxB_LXOR_SECOND_BOOL   GxB_EQ_SECOND_BOOL\nGxB_LOR_LOR_BOOL       GxB_LAND_LOR_BOOL      GxB_LXOR_LOR_BOOL      GxB_EQ_LOR_BOOL\nGxB_LOR_LAND_BOOL      GxB_LAND_LAND_BOOL     GxB_LXOR_LAND_BOOL     GxB_EQ_LAND_BOOL\nGxB_LOR_LXOR_BOOL      GxB_LAND_LXOR_BOOL     GxB_LXOR_LXOR_BOOL     GxB_EQ_LXOR_BOOL\nGxB_LOR_EQ_BOOL        GxB_LAND_EQ_BOOL       GxB_LXOR_EQ_BOOL       GxB_EQ_EQ_BOOL\nGxB_LOR_GT_BOOL        GxB_LAND_GT_BOOL       GxB_LXOR_GT_BOOL       GxB_EQ_GT_BOOL\nGxB_LOR_LT_BOOL        GxB_LAND_LT_BOOL       GxB_LXOR_LT_BOOL       GxB_EQ_LT_BOOL\nGxB_LOR_GE_BOOL        GxB_LAND_GE_BOOL       GxB_LXOR_GE_BOOL       GxB_EQ_GE_BOOL\nGxB_LOR_LE_BOOL        GxB_LAND_LE_BOOL       GxB_LXOR_LE_BOOL       GxB_EQ_LE_BOOL","category":"page"},{"location":"desc_methods/#Descriptor-methods-1","page":"Descriptors","title":"Descriptor methods","text":"","category":"section"},{"location":"desc_methods/#","page":"Descriptors","title":"Descriptors","text":"GrB_Descriptor_new\nGrB_Descriptor_set","category":"page"},{"location":"desc_methods/#GraphBLASInterface.GrB_Descriptor_new","page":"Descriptors","title":"GraphBLASInterface.GrB_Descriptor_new","text":"GrB_Descriptor_new(desc)\n\nInitialize a descriptor with default field values.\n\n\n\n\n\n","category":"function"},{"location":"desc_methods/#GraphBLASInterface.GrB_Descriptor_set","page":"Descriptors","title":"GraphBLASInterface.GrB_Descriptor_set","text":"GrB_Descriptor_set(desc, field, val)\n\nSet the content for a field for an existing descriptor.\n\n\n\n\n\n","category":"function"},{"location":"free_methods/#Free-methods-1","page":"Freeing objects","title":"Free methods","text":"","category":"section"},{"location":"free_methods/#","page":"Freeing objects","title":"Freeing objects","text":"GrB_free\nGrB_UnaryOp_free\nGrB_BinaryOp_free\nGrB_Monoid_free\nGrB_Semiring_free\nGrB_Matrix_free\nGrB_Vector_free\nGrB_Descriptor_free","category":"page"},{"location":"free_methods/#GraphBLASInterface.GrB_free","page":"Freeing objects","title":"GraphBLASInterface.GrB_free","text":"GrB_free(object)\n\nGeneric method to free a GraphBLAS object.\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> w = GrB_Vector{Int64}()\nGrB_Vector{Int64}\n\njulia> I = ZeroBasedIndex[0, 2, 4]; X = [10, 20, 30]; n = 3;\n\njulia> GrB_Vector_new(w, GrB_INT64, 5)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Vector_build(w, I, X, n, GrB_FIRST_INT64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> @GxB_fprint(w, GxB_COMPLETE)\n\nGraphBLAS vector: w\nnrows: 5 ncols: 1 max # entries: 3\nformat: standard CSC vlen: 5 nvec_nonempty: 1 nvec: 1 plen: 1 vdim: 1\nhyper_ratio 0.0625\nGraphBLAS type:  int64_t size: 8\nnumber of entries: 3\ncolumn: 0 : 3 entries [0:2]\n    row 0: int64 10\n    row 2: int64 20\n    row 4: int64 30\n\n\njulia> GrB_free(w)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> @GxB_fprint(w, GxB_COMPLETE)\n\nGraphBLAS vector: w NULL\n\n\n\n\n\n","category":"function"},{"location":"free_methods/#GraphBLASInterface.GrB_UnaryOp_free","page":"Freeing objects","title":"GraphBLASInterface.GrB_UnaryOp_free","text":"GrB_UnaryOp_free(unaryop)\n\nFree unary operator.\n\n\n\n\n\n","category":"function"},{"location":"free_methods/#GraphBLASInterface.GrB_BinaryOp_free","page":"Freeing objects","title":"GraphBLASInterface.GrB_BinaryOp_free","text":"GrB_BinaryOp_free(binaryop)\n\nFree binary operator.\n\n\n\n\n\n","category":"function"},{"location":"free_methods/#GraphBLASInterface.GrB_Monoid_free","page":"Freeing objects","title":"GraphBLASInterface.GrB_Monoid_free","text":"GrB_Monoid_free(monoid)\n\nFree monoid.\n\n\n\n\n\n","category":"function"},{"location":"free_methods/#GraphBLASInterface.GrB_Semiring_free","page":"Freeing objects","title":"GraphBLASInterface.GrB_Semiring_free","text":"GrB_Semiring_free(semiring)\n\nFree semiring.\n\n\n\n\n\n","category":"function"},{"location":"free_methods/#GraphBLASInterface.GrB_Matrix_free","page":"Freeing objects","title":"GraphBLASInterface.GrB_Matrix_free","text":"GrB_Matrix_free(A)\n\nFree matrix.\n\n\n\n\n\n","category":"function"},{"location":"free_methods/#GraphBLASInterface.GrB_Vector_free","page":"Freeing objects","title":"GraphBLASInterface.GrB_Vector_free","text":"GrB_Vector_free(v)\n\nFree vector.\n\n\n\n\n\n","category":"function"},{"location":"free_methods/#GraphBLASInterface.GrB_Descriptor_free","page":"Freeing objects","title":"GraphBLASInterface.GrB_Descriptor_free","text":"GrB_Descriptor_free(desc)\n\nFree descriptor.\n\n\n\n\n\n","category":"function"},{"location":"seq_ter/#Sequence-termination-1","page":"Sequence termination","title":"Sequence termination","text":"","category":"section"},{"location":"seq_ter/#","page":"Sequence termination","title":"Sequence termination","text":"GrB_wait\nGrB_error","category":"page"},{"location":"seq_ter/#GraphBLASInterface.GrB_wait","page":"Sequence termination","title":"GraphBLASInterface.GrB_wait","text":"GrB_wait()\n\nGrB_wait forces all pending operations to complete. Blocking mode is as if GrB_wait is called whenever a GraphBLAS method or operation returns to the user.\n\n\n\n\n\n","category":"function"},{"location":"seq_ter/#GraphBLASInterface.GrB_error","page":"Sequence termination","title":"GraphBLASInterface.GrB_error","text":"GrB_error()\n\nEach GraphBLAS method and operation returns a GrB_Info error code. GrB_error returns additional information on the last error.\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_INVALID_VALUE::GrB_Info = 5\n\njulia> GrB_error()\nGraphBLAS error: GrB_INVALID_VALUE\nfunction: GrB_init (mode)\nGrB_init must not be called twice\n\n\n\n\n\n","category":"function"},{"location":"operations/#GraphBLAS-operations-1","page":"Operations","title":"GraphBLAS operations","text":"","category":"section"},{"location":"operations/#Multiplication-1","page":"Operations","title":"Multiplication","text":"","category":"section"},{"location":"operations/#","page":"Operations","title":"Operations","text":"GrB_mxm\nGrB_vxm\nGrB_mxv","category":"page"},{"location":"operations/#GraphBLASInterface.GrB_mxm","page":"Operations","title":"GraphBLASInterface.GrB_mxm","text":"GrB_mxm(C, Mask, accum, semiring, A, B, desc)\n\nMultiplies a matrix with another matrix on a semiring. The result is a matrix.\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> A = GrB_Matrix{Int64}()\nGrB_Matrix{Int64}\n\njulia> GrB_Matrix_new(A, GrB_INT64, 2, 2)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I1 = ZeroBasedIndex[0, 1]; J1 = ZeroBasedIndex[0, 1]; X1 = [10, 20]; n1 = 2;\n\njulia> GrB_Matrix_build(A, I1, J1, X1, n1, GrB_FIRST_INT64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> B = GrB_Matrix{Int64}()\nGrB_Matrix{Int64}\n\njulia> GrB_Matrix_new(B, GrB_INT64, 2, 2)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I2 = ZeroBasedIndex[0, 1]; J2 = ZeroBasedIndex[0, 1]; X2 = [5, 15]; n2 = 2;\n\njulia> GrB_Matrix_build(B, I2, J2, X2, n2, GrB_FIRST_INT64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> C = GrB_Matrix{Int64}()\nGrB_Matrix{Int64}\n\njulia> GrB_Matrix_new(C, GrB_INT64, 2, 2)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_mxm(C, GrB_NULL, GrB_NULL, GxB_PLUS_TIMES_INT64, A, B, GrB_NULL)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> @GxB_fprint(C, GxB_COMPLETE)\n\nGraphBLAS matrix: C \nnrows: 2 ncols: 2 max # entries: 2\nformat: standard CSR vlen: 2 nvec_nonempty: 2 nvec: 2 plen: 2 vdim: 2\nhyper_ratio 0.0625\nGraphBLAS type:  int64_t size: 8\nlast method used for GrB_mxm, vxm, or mxv: heap\nnumber of entries: 2 \nrow: 0 : 1 entries [0:0]\n    column 0: int64 50\nrow: 1 : 1 entries [1:1]\n    column 1: int64 300\n\n\n\n\n\n","category":"function"},{"location":"operations/#GraphBLASInterface.GrB_vxm","page":"Operations","title":"GraphBLASInterface.GrB_vxm","text":"GrB_vxm(w, mask, accum, semiring, u, A, desc)\n\nMultiplies a (row)vector with a matrix on an semiring. The result is a vector.\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> A = GrB_Matrix{Int64}()\nGrB_Matrix{Int64}\n\njulia> GrB_Matrix_new(A, GrB_INT64, 2, 2)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I1 = ZeroBasedIndex[0, 1]; J1 = ZeroBasedIndex[0, 1]; X1 = [10, 20]; n1 = 2;\n\njulia> GrB_Matrix_build(A, I1, J1, X1, n1, GrB_FIRST_INT64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> u = GrB_Vector{Int64}()\nGrB_Vector{Int64}\n\njulia> GrB_Vector_new(u, GrB_INT64, 2)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I2 = ZeroBasedIndex[0, 1]; X2 = [5, 6]; n2 = 2;\n\njulia> GrB_Vector_build(u, I2, X2, n2, GrB_FIRST_INT64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> w = GrB_Vector{Int64}()\nGrB_Vector{Int64}\n\njulia> GrB_Vector_new(w, GrB_INT64, 2)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_vxm(w, GrB_NULL, GrB_NULL, GxB_PLUS_TIMES_INT64, u, A, GrB_NULL)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> @GxB_fprint(w, GxB_COMPLETE)\n\nGraphBLAS vector: w \nnrows: 2 ncols: 1 max # entries: 2\nformat: standard CSC vlen: 2 nvec_nonempty: 1 nvec: 1 plen: 1 vdim: 1\nhyper_ratio 0.0625\nGraphBLAS type:  int64_t size: 8\nlast method used for GrB_mxm, vxm, or mxv: heap\nnumber of entries: 2 \ncolumn: 0 : 2 entries [0:1]\n    row 0: int64 50\n    row 1: int64 120\n\n\n\n\n\n","category":"function"},{"location":"operations/#GraphBLASInterface.GrB_mxv","page":"Operations","title":"GraphBLASInterface.GrB_mxv","text":"GrB_mxv(w, mask, accum, semiring, A, u, desc)\n\nMultiplies a matrix by a vector on a semiring. The result is a vector.\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> A = GrB_Matrix{Int64}()\nGrB_Matrix{Int64}\n\njulia> GrB_Matrix_new(A, GrB_INT64, 2, 2)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I1 = ZeroBasedIndex[0, 0, 1]; J1 = ZeroBasedIndex[0, 1, 1]; X1 = [10, 20, 30]; n1 = 3;\n\njulia> GrB_Matrix_build(A, I1, J1, X1, n1, GrB_FIRST_INT64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> u = GrB_Vector{Int64}()\nGrB_Vector{Int64}\n\njulia> GrB_Vector_new(u, GrB_INT64, 2)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I2 = ZeroBasedIndex[0, 1]; X2 = [5, 6]; n2 = 2;\n\njulia> GrB_Vector_build(u, I2, X2, n2, GrB_FIRST_INT64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> w = GrB_Vector{Int64}()\nGrB_Vector{Int64}\n\njulia> GrB_Vector_new(w, GrB_INT64, 2)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_mxv(w, GrB_NULL, GrB_NULL, GxB_PLUS_TIMES_INT64, A, u, GrB_NULL)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> @GxB_fprint(w, GxB_COMPLETE)\n\nGraphBLAS vector: w \nnrows: 2 ncols: 1 max # entries: 2\nformat: standard CSC vlen: 2 nvec_nonempty: 1 nvec: 1 plen: 1 vdim: 1\nhyper_ratio 0.0625\nGraphBLAS type:  int64_t size: 8\nlast method used for GrB_mxm, vxm, or mxv: dot\nnumber of entries: 2 \ncolumn: 0 : 2 entries [0:1]\n    row 0: int64 170\n    row 1: int64 180\n\n\n\n\n\n","category":"function"},{"location":"operations/#Element-wise-multiplication-1","page":"Operations","title":"Element-wise multiplication","text":"","category":"section"},{"location":"operations/#","page":"Operations","title":"Operations","text":"GrB_eWiseMult\nGrB_eWiseMult_Vector_Semiring\nGrB_eWiseMult_Vector_Monoid\nGrB_eWiseMult_Vector_BinaryOp\nGrB_eWiseMult_Matrix_Semiring\nGrB_eWiseMult_Matrix_Monoid\nGrB_eWiseMult_Matrix_BinaryOp","category":"page"},{"location":"operations/#GraphBLASInterface.GrB_eWiseMult","page":"Operations","title":"GraphBLASInterface.GrB_eWiseMult","text":"GrB_eWiseMult(C, mask, accum, op, A, B, desc)\n\nGeneric method for element-wise matrix and vector operations: using set intersection.\n\nGrB_eWiseMult computes C<Mask> = accum (C, A .* B), where pairs of elements in two matrices (or vectors) are pairwise \"multiplied\" with C(i, j) = mult (A(i, j), B(i, j)). The \"multiplication\" operator can be any binary operator. The pattern of the result T = A .* B is the set intersection (not union) of A and B. Entries outside of the intersection are not computed. This is primary difference with GrB_eWiseAdd. The input matrices A and/or B may be transposed first, via the descriptor. For a semiring, the mult operator is the semiring's multiply operator; this differs from the eWiseAdd methods which use the semiring's add operator instead.\n\n\n\n\n\n","category":"function"},{"location":"operations/#GraphBLASInterface.GrB_eWiseMult_Vector_Semiring","page":"Operations","title":"GraphBLASInterface.GrB_eWiseMult_Vector_Semiring","text":"GrB_eWiseMult_Vector_Semiring(w, mask, accum, semiring, u, v, desc)\n\nCompute element-wise vector multiplication using semiring. Semiring's multiply operator is used. w<mask> = accum (w, u .* v)\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> u = GrB_Vector{Int64}()\nGrB_Vector{Int64}\n\njulia> GrB_Vector_new(u, GrB_INT64, 5)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I1 = ZeroBasedIndex[0, 2, 4]; X1 = [10, 20, 3]; n1 = 3;\n\njulia> GrB_Vector_build(u, I1, X1, n1, GrB_FIRST_INT64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> v = GrB_Vector{Float64}()\nGrB_Vector{Float64}\n\njulia> GrB_Vector_new(v, GrB_FP64, 5)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I2 = ZeroBasedIndex[0, 1, 4]; X2 = [1.1, 2.2, 3.3]; n2 = 3;\n\njulia> GrB_Vector_build(v, I2, X2, n2, GrB_FIRST_FP64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> w = GrB_Vector{Float64}()\nGrB_Vector{Float64}\n\njulia> GrB_Vector_new(w, GrB_FP64, 5)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_eWiseMult_Vector_Semiring(w, GrB_NULL, GrB_NULL, GxB_PLUS_TIMES_FP64, u, v, GrB_NULL)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> @GxB_fprint(w, GxB_COMPLETE)\n\nGraphBLAS vector: w \nnrows: 5 ncols: 1 max # entries: 2\nformat: standard CSC vlen: 5 nvec_nonempty: 1 nvec: 1 plen: 1 vdim: 1\nhyper_ratio 0.0625\nGraphBLAS type:  double size: 8\nnumber of entries: 2 \ncolumn: 0 : 2 entries [0:1]\n    row 0: double 11\n    row 4: double 9.9\n\n\n\n\n\n","category":"function"},{"location":"operations/#GraphBLASInterface.GrB_eWiseMult_Vector_Monoid","page":"Operations","title":"GraphBLASInterface.GrB_eWiseMult_Vector_Monoid","text":"GrB_eWiseMult_Vector_Monoid(w, mask, accum, monoid, u, v, desc)\n\nCompute element-wise vector multiplication using monoid. w<mask> = accum (w, u .* v)\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> u = GrB_Vector{Int64}()\nGrB_Vector{Int64}\n\njulia> GrB_Vector_new(u, GrB_INT64, 5)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I1 = ZeroBasedIndex[0, 2, 4]; X1 = [10, 20, 3]; n1 = 3;\n\njulia> GrB_Vector_build(u, I1, X1, n1, GrB_FIRST_INT64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> v = GrB_Vector{Float64}()\nGrB_Vector{Float64}\n\njulia> GrB_Vector_new(v, GrB_FP64, 5)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I2 = ZeroBasedIndex[0, 1, 4]; X2 = [1.1, 2.2, 3.3]; n2 = 3;\n\njulia> GrB_Vector_build(v, I2, X2, n2, GrB_FIRST_FP64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> w = GrB_Vector{Float64}()\nGrB_Vector{Float64}\n\njulia> GrB_Vector_new(w, GrB_FP64, 5)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_eWiseMult_Vector_Monoid(w, GrB_NULL, GrB_NULL, GxB_MAX_FP64_MONOID, u, v, GrB_NULL)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> @GxB_fprint(w, GxB_COMPLETE)\n\nGraphBLAS vector: w \nnrows: 5 ncols: 1 max # entries: 2\nformat: standard CSC vlen: 5 nvec_nonempty: 1 nvec: 1 plen: 1 vdim: 1\nhyper_ratio 0.0625\nGraphBLAS type:  double size: 8\nnumber of entries: 2 \ncolumn: 0 : 2 entries [0:1]\n    row 0: double 10\n    row 4: double 3.3\n\n\n\n\n\n","category":"function"},{"location":"operations/#GraphBLASInterface.GrB_eWiseMult_Vector_BinaryOp","page":"Operations","title":"GraphBLASInterface.GrB_eWiseMult_Vector_BinaryOp","text":"GrB_eWiseMult_Vector_BinaryOp(w, mask, accum, mult, u, v, desc)\n\nCompute element-wise vector multiplication using binary operator. w<mask> = accum (w, u .* v)\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> u = GrB_Vector{Int64}()\nGrB_Vector{Int64}\n\njulia> GrB_Vector_new(u, GrB_INT64, 5)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I1 = ZeroBasedIndex[0, 2, 4]; X1 = [10, 20, 30]; n1 = 3;\n\njulia> GrB_Vector_build(u, I1, X1, n1, GrB_FIRST_INT64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> v = GrB_Vector{Float64}()\nGrB_Vector{Float64}\n\njulia> GrB_Vector_new(v, GrB_FP64, 5)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I2 = ZeroBasedIndex[0, 1, 4]; X2 = [1.1, 2.2, 3.3]; n2 = 3;\n\njulia> GrB_Vector_build(v, I2, X2, n2, GrB_FIRST_FP64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> w = GrB_Vector{Float64}()\nGrB_Vector{Float64}\n\njulia> GrB_Vector_new(w, GrB_FP64, 5)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_eWiseMult_Vector_BinaryOp(w, GrB_NULL, GrB_NULL, GrB_TIMES_FP64, u, v, GrB_NULL)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> @GxB_fprint(w, GxB_COMPLETE)\n\nGraphBLAS vector: w \nnrows: 5 ncols: 1 max # entries: 2\nformat: standard CSC vlen: 5 nvec_nonempty: 1 nvec: 1 plen: 1 vdim: 1\nhyper_ratio 0.0625\nGraphBLAS type:  double size: 8\nnumber of entries: 2 \ncolumn: 0 : 2 entries [0:1]\n    row 0: double 11\n    row 4: double 99\n\n\n\n\n\n","category":"function"},{"location":"operations/#GraphBLASInterface.GrB_eWiseMult_Matrix_Semiring","page":"Operations","title":"GraphBLASInterface.GrB_eWiseMult_Matrix_Semiring","text":"GrB_eWiseMult_Matrix_Semiring(C, Mask, accum, semiring, A, B, desc)\n\nCompute element-wise matrix multiplication using semiring. Semiring's multiply operator is used. C<Mask> = accum (C, A .* B)\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> A = GrB_Matrix{Int64}()\nGrB_Matrix{Int64}\n\njulia> GrB_Matrix_new(A, GrB_INT64, 4, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I1 = ZeroBasedIndex[0, 0, 2, 2]; J1 = ZeroBasedIndex[1, 2, 0, 2]; X1 = [10, 20, 30, 40]; n1 = 4;\n\njulia> GrB_Matrix_build(A, I1, J1, X1, n1, GrB_FIRST_INT64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> B = GrB_Matrix{Int64}()\nGrB_Matrix{Int64}\n\njulia> GrB_Matrix_new(B, GrB_INT64, 4, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I2 = ZeroBasedIndex[0, 0, 2]; J2 = ZeroBasedIndex[3, 2, 0]; X2 = [15, 16, 17]; n2 = 3;\n\njulia> GrB_Matrix_build(B, I2, J2, X2, n2, GrB_FIRST_INT64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> C = GrB_Matrix{Int64}()\nGrB_Matrix{Int64}\n\njulia> GrB_Matrix_new(C, GrB_INT64, 4, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_eWiseMult_Matrix_Semiring(C, GrB_NULL, GrB_NULL, GxB_PLUS_TIMES_INT64, A, B, GrB_NULL)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> @GxB_fprint(C, GxB_COMPLETE)\n\nGraphBLAS matrix: C \nnrows: 4 ncols: 4 max # entries: 2\nformat: standard CSR vlen: 4 nvec_nonempty: 2 nvec: 4 plen: 4 vdim: 4\nhyper_ratio 0.0625\nGraphBLAS type:  int64_t size: 8\nnumber of entries: 2 \nrow: 0 : 1 entries [0:0]\n    column 2: int64 320\nrow: 2 : 1 entries [1:1]\n    column 0: int64 510\n\n\n\n\n\n","category":"function"},{"location":"operations/#GraphBLASInterface.GrB_eWiseMult_Matrix_Monoid","page":"Operations","title":"GraphBLASInterface.GrB_eWiseMult_Matrix_Monoid","text":"GrB_eWiseMult_Matrix_Monoid(C, Mask, accum, monoid, A, B, desc)\n\nCompute element-wise matrix multiplication using monoid. C<Mask> = accum (C, A .* B)\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> A = GrB_Matrix{Int64}()\nGrB_Matrix{Int64}\n\njulia> GrB_Matrix_new(A, GrB_INT64, 4, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I1 = ZeroBasedIndex[0, 0, 2, 2]; J1 = ZeroBasedIndex[1, 2, 0, 2]; X1 = [10, 20, 30, 40]; n1 = 4;\n\njulia> GrB_Matrix_build(A, I1, J1, X1, n1, GrB_FIRST_INT64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> B = GrB_Matrix{Int64}()\nGrB_Matrix{Int64}\n\njulia> GrB_Matrix_new(B, GrB_INT64, 4, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I2 = ZeroBasedIndex[0, 0, 2]; J2 = ZeroBasedIndex[3, 2, 0]; X2 = [15, 16, 17]; n2 = 3;\n\njulia> GrB_Matrix_build(B, I2, J2, X2, n2, GrB_FIRST_INT64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> C = GrB_Matrix{Int64}()\nGrB_Matrix{Int64}\n\njulia> GrB_Matrix_new(C, GrB_INT64, 4, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_eWiseMult_Matrix_Monoid(C, GrB_NULL, GrB_NULL, GxB_PLUS_INT64_MONOID, A, B, GrB_NULL)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> @GxB_fprint(C, GxB_COMPLETE)\n\nGraphBLAS matrix: C \nnrows: 4 ncols: 4 max # entries: 2\nformat: standard CSR vlen: 4 nvec_nonempty: 2 nvec: 4 plen: 4 vdim: 4\nhyper_ratio 0.0625\nGraphBLAS type:  int64_t size: 8\nnumber of entries: 2 \nrow: 0 : 1 entries [0:0]\n    column 2: int64 36\nrow: 2 : 1 entries [1:1]\n    column 0: int64 47\n\n\n\n\n\n","category":"function"},{"location":"operations/#GraphBLASInterface.GrB_eWiseMult_Matrix_BinaryOp","page":"Operations","title":"GraphBLASInterface.GrB_eWiseMult_Matrix_BinaryOp","text":"GrB_eWiseMult_Matrix_BinaryOp(C, Mask, accum, mult, A, B, desc)\n\nCompute element-wise matrix multiplication using binary operator. C<Mask> = accum (C, A .* B)\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> A = GrB_Matrix{Int64}()\nGrB_Matrix{Int64}\n\njulia> GrB_Matrix_new(A, GrB_INT64, 4, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I1 = ZeroBasedIndex[0, 0, 2, 2]; J1 = ZeroBasedIndex[1, 2, 0, 2]; X1 = [10, 20, 30, 40]; n1 = 4;\n\njulia> GrB_Matrix_build(A, I1, J1, X1, n1, GrB_FIRST_INT64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> B = GrB_Matrix{Int64}()\nGrB_Matrix{Int64}\n\njulia> GrB_Matrix_new(B, GrB_INT64, 4, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I2 = ZeroBasedIndex[0, 0, 2]; J2 = ZeroBasedIndex[3, 2, 0]; X2 = [15, 16, 17]; n2 = 3;\n\njulia> GrB_Matrix_build(B, I2, J2, X2, n2, GrB_FIRST_INT64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> C = GrB_Matrix{Int64}()\nGrB_Matrix{Int64}\n\njulia> GrB_Matrix_new(C, GrB_INT64, 4, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_eWiseMult_Matrix_BinaryOp(C, GrB_NULL, GrB_NULL, GrB_PLUS_INT64, A, B, GrB_NULL)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> @GxB_fprint(C, GxB_COMPLETE)\n\nGraphBLAS matrix: C \nnrows: 4 ncols: 4 max # entries: 2\nformat: standard CSR vlen: 4 nvec_nonempty: 2 nvec: 4 plen: 4 vdim: 4\nhyper_ratio 0.0625\nGraphBLAS type:  int64_t size: 8\nnumber of entries: 2 \nrow: 0 : 1 entries [0:0]\n    column 2: int64 36\nrow: 2 : 1 entries [1:1]\n    column 0: int64 47\n\n\n\n\n\n","category":"function"},{"location":"operations/#Element-wise-addition-1","page":"Operations","title":"Element-wise addition","text":"","category":"section"},{"location":"operations/#","page":"Operations","title":"Operations","text":"GrB_eWiseAdd\nGrB_eWiseAdd_Vector_Semiring\nGrB_eWiseAdd_Vector_Monoid\nGrB_eWiseAdd_Vector_BinaryOp\nGrB_eWiseAdd_Matrix_Semiring\nGrB_eWiseAdd_Matrix_Monoid\nGrB_eWiseAdd_Matrix_BinaryOp","category":"page"},{"location":"operations/#GraphBLASInterface.GrB_eWiseAdd","page":"Operations","title":"GraphBLASInterface.GrB_eWiseAdd","text":"GrB_eWiseAdd(C, mask, accum, op, A, B, desc)\n\nGeneric method for element-wise matrix and vector operations: using set union.\n\nGrB_eWiseAdd computes C<Mask> = accum (C, A + B), where pairs of elements in two matrices (or two vectors) are pairwise \"added\". The \"add\" operator can be any binary operator. With the plus operator, this is the same matrix addition in conventional linear algebra. The pattern of the result T = A + B is the set union of A and B. Entries outside of the union are not computed. That is, if both A(i, j) and B(i, j) are present in the pattern of A and B, then T(i, j) = A(i, j) \"+\" B(i, j). If only A(i, j) is present then T(i, j) = A (i, j) and the \"+\" operator is not used. Likewise, if only B(i, j) is in the pattern of B but A(i, j) is not in the pattern of A, then T(i, j) = B(i, j). For a semiring, the mult operator is the semiring's add operator.\n\n\n\n\n\n","category":"function"},{"location":"operations/#GraphBLASInterface.GrB_eWiseAdd_Vector_Semiring","page":"Operations","title":"GraphBLASInterface.GrB_eWiseAdd_Vector_Semiring","text":"GrB_eWiseAdd_Vector_Semiring(w, mask, accum, semiring, u, v, desc)\n\nCompute element-wise vector addition using semiring. Semiring's add operator is used. w<mask> = accum (w, u + v)\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> u = GrB_Vector{Int64}()\nGrB_Vector{Int64}\n\njulia> GrB_Vector_new(u, GrB_INT64, 5)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I1 = ZeroBasedIndex[0, 2, 4]; X1 = [10, 20, 3]; n1 = 3;\n\njulia> GrB_Vector_build(u, I1, X1, n1, GrB_FIRST_INT64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> v = GrB_Vector{Float64}()\nGrB_Vector{Float64}\n\njulia> GrB_Vector_new(v, GrB_FP64, 5)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I2 = ZeroBasedIndex[0, 1, 4]; X2 = [1.1, 2.2, 3.3]; n2 = 3;\n\njulia> GrB_Vector_build(v, I2, X2, n2, GrB_FIRST_FP64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> w = GrB_Vector{Float64}()\nGrB_Vector{Float64}\n\njulia> GrB_Vector_new(w, GrB_FP64, 5)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_eWiseAdd_Vector_Semiring(w, GrB_NULL, GrB_NULL, GxB_PLUS_TIMES_FP64, u, v, GrB_NULL)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> @GxB_fprint(w, GxB_COMPLETE)\n\nGraphBLAS vector: w \nnrows: 5 ncols: 1 max # entries: 4\nformat: standard CSC vlen: 5 nvec_nonempty: 1 nvec: 1 plen: 1 vdim: 1\nhyper_ratio 0.0625\nGraphBLAS type:  double size: 8\nnumber of entries: 4 \ncolumn: 0 : 4 entries [0:3]\n    row 0: double 11.1\n    row 1: double 2.2\n    row 2: double 20\n    row 4: double 6.3\n\n\n\n\n\n","category":"function"},{"location":"operations/#GraphBLASInterface.GrB_eWiseAdd_Vector_Monoid","page":"Operations","title":"GraphBLASInterface.GrB_eWiseAdd_Vector_Monoid","text":"GrB_eWiseAdd_Vector_Monoid(w, mask, accum, monoid, u, v, desc)\n\nCompute element-wise vector addition using monoid. w<mask> = accum (w, u + v)\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> u = GrB_Vector{Int64}()\nGrB_Vector{Int64}\n\njulia> GrB_Vector_new(u, GrB_INT64, 5)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I1 = ZeroBasedIndex[0, 2, 4]; X1 = [10, 20, 3]; n1 = 3;\n\njulia> GrB_Vector_build(u, I1, X1, n1, GrB_FIRST_INT64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> v = GrB_Vector{Float64}()\nGrB_Vector{Float64}\n\njulia> GrB_Vector_new(v, GrB_FP64, 5)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I2 = ZeroBasedIndex[0, 1, 4]; X2 = [1.1, 2.2, 3.3]; n2 = 3;\n\njulia> GrB_Vector_build(v, I2, X2, n2, GrB_FIRST_FP64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> w = GrB_Vector{Float64}()\nGrB_Vector{Float64}\n\njulia> GrB_Vector_new(w, GrB_FP64, 5)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_eWiseAdd_Vector_Monoid(w, GrB_NULL, GrB_NULL, GxB_MAX_FP64_MONOID, u, v, GrB_NULL)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> @GxB_fprint(w, GxB_COMPLETE)\n\nGraphBLAS vector: w \nnrows: 5 ncols: 1 max # entries: 4\nformat: standard CSC vlen: 5 nvec_nonempty: 1 nvec: 1 plen: 1 vdim: 1\nhyper_ratio 0.0625\nGraphBLAS type:  double size: 8\nnumber of entries: 4 \ncolumn: 0 : 4 entries [0:3]\n    row 0: double 10\n    row 1: double 2.2\n    row 2: double 20\n    row 4: double 3.3\n\n\n\n\n\n","category":"function"},{"location":"operations/#GraphBLASInterface.GrB_eWiseAdd_Vector_BinaryOp","page":"Operations","title":"GraphBLASInterface.GrB_eWiseAdd_Vector_BinaryOp","text":"GrB_eWiseAdd_Vector_BinaryOp(w, mask, accum, add, u, v, desc)\n\nCompute element-wise vector addition using binary operator. w<mask> = accum (w, u + v)\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> u = GrB_Vector{Int64}()\nGrB_Vector{Int64}\n\njulia> GrB_Vector_new(u, GrB_INT64, 5)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I1 = ZeroBasedIndex[0, 2, 4]; X1 = [10, 20, 3]; n1 = 3;\n\njulia> GrB_Vector_build(u, I1, X1, n1, GrB_FIRST_INT64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> v = GrB_Vector{Float64}()\nGrB_Vector{Float64}\n\njulia> GrB_Vector_new(v, GrB_FP64, 5)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I2 = ZeroBasedIndex[0, 1, 4]; X2 = [1.1, 2.2, 3.3]; n2 = 3;\n\njulia> GrB_Vector_build(v, I2, X2, n2, GrB_FIRST_FP64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> w = GrB_Vector{Float64}()\nGrB_Vector{Float64}\n\njulia> GrB_Vector_new(w, GrB_FP64, 5)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_eWiseAdd_Vector_BinaryOp(w, GrB_NULL, GrB_NULL, GrB_PLUS_FP64, u, v, GrB_NULL)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> @GxB_fprint(w, GxB_COMPLETE)\n\nGraphBLAS vector: w \nnrows: 5 ncols: 1 max # entries: 4\nformat: standard CSC vlen: 5 nvec_nonempty: 1 nvec: 1 plen: 1 vdim: 1\nhyper_ratio 0.0625\nGraphBLAS type:  double size: 8\nnumber of entries: 4 \ncolumn: 0 : 4 entries [0:3]\n    row 0: double 11.1\n    row 1: double 2.2\n    row 2: double 20\n    row 4: double 6.3\n\n\n\n\n\n","category":"function"},{"location":"operations/#GraphBLASInterface.GrB_eWiseAdd_Matrix_Semiring","page":"Operations","title":"GraphBLASInterface.GrB_eWiseAdd_Matrix_Semiring","text":"GrB_eWiseAdd_Matrix_Semiring(C, Mask, accum, semiring, A, B, desc)\n\nCompute element-wise matrix addition using semiring. Semiring's add operator is used. C<Mask> = accum (C, A + B)\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> A = GrB_Matrix{Int64}()\nGrB_Matrix{Int64}\n\njulia> GrB_Matrix_new(A, GrB_INT64, 4, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I1 = ZeroBasedIndex[0, 0, 2, 2]; J1 = ZeroBasedIndex[1, 2, 0, 2]; X1 = [10, 20, 30, 40]; n1 = 4;\n\njulia> GrB_Matrix_build(A, I1, J1, X1, n1, GrB_FIRST_INT64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> B = GrB_Matrix{Int64}()\nGrB_Matrix{Int64}\n\njulia> GrB_Matrix_new(B, GrB_INT64, 4, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I2 = ZeroBasedIndex[0, 0, 2]; J2 = ZeroBasedIndex[3, 2, 0]; X2 = [15, 16, 17]; n2 = 3;\n\njulia> GrB_Matrix_build(B, I2, J2, X2, n2, GrB_FIRST_INT64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> C = GrB_Matrix{Int64}()\nGrB_Matrix{Int64}\n\njulia> GrB_Matrix_new(C, GrB_INT64, 4, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_eWiseAdd_Matrix_Semiring(C, GrB_NULL, GrB_NULL, GxB_PLUS_TIMES_INT64, A, B, GrB_NULL)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> @GxB_fprint(C, GxB_COMPLETE)\n\nGraphBLAS matrix: C \nnrows: 4 ncols: 4 max # entries: 5\nformat: standard CSR vlen: 4 nvec_nonempty: 2 nvec: 4 plen: 4 vdim: 4\nhyper_ratio 0.0625\nGraphBLAS type:  int64_t size: 8\nnumber of entries: 5 \nrow: 0 : 3 entries [0:2]\n    column 1: int64 10\n    column 2: int64 36\n    column 3: int64 15\nrow: 2 : 2 entries [3:4]\n    column 0: int64 47\n    column 2: int64 40\n\n\n\n\n\n","category":"function"},{"location":"operations/#GraphBLASInterface.GrB_eWiseAdd_Matrix_Monoid","page":"Operations","title":"GraphBLASInterface.GrB_eWiseAdd_Matrix_Monoid","text":"GrB_eWiseAdd_Matrix_Monoid(C, Mask, accum, monoid, A, B, desc)\n\nCompute element-wise matrix addition using monoid. C<Mask> = accum (C, A + B)\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> A = GrB_Matrix{Int64}()\nGrB_Matrix{Int64}\n\njulia> GrB_Matrix_new(A, GrB_INT64, 4, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I1 = ZeroBasedIndex[0, 0, 2, 2]; J1 = ZeroBasedIndex[1, 2, 0, 2]; X1 = [10, 20, 30, 40]; n1 = 4;\n\njulia> GrB_Matrix_build(A, I1, J1, X1, n1, GrB_FIRST_INT64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> B = GrB_Matrix{Int64}()\nGrB_Matrix{Int64}\n\njulia> GrB_Matrix_new(B, GrB_INT64, 4, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I2 = ZeroBasedIndex[0, 0, 2]; J2 = ZeroBasedIndex[3, 2, 0]; X2 = [15, 16, 17]; n2 = 3;\n\njulia> GrB_Matrix_build(B, I2, J2, X2, n2, GrB_FIRST_INT64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> C = GrB_Matrix{Int64}()\nGrB_Matrix{Int64}\n\njulia> GrB_Matrix_new(C, GrB_INT64, 4, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> mask = GrB_Matrix{Bool}()\nGrB_Matrix{Bool}\n\njulia> GrB_Matrix_new(mask, GrB_BOOL, 4, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Matrix_build(mask, ZeroBasedIndex[0, 0], ZeroBasedIndex[1, 2], [true, true], 2, GrB_FIRST_BOOL)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_eWiseAdd_Matrix_Monoid(C, mask, GrB_NULL, GxB_PLUS_INT64_MONOID, A, B, GrB_NULL)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> @GxB_fprint(C, GxB_COMPLETE)\n\nGraphBLAS matrix: C \nnrows: 4 ncols: 4 max # entries: 5\nformat: standard CSR vlen: 4 nvec_nonempty: 1 nvec: 4 plen: 4 vdim: 4\nhyper_ratio 0.0625\nGraphBLAS type:  int64_t size: 8\nnumber of entries: 2 \nrow: 0 : 2 entries [0:1]\n    column 1: int64 10\n    column 2: int64 36\n\n\n\n\n\n","category":"function"},{"location":"operations/#GraphBLASInterface.GrB_eWiseAdd_Matrix_BinaryOp","page":"Operations","title":"GraphBLASInterface.GrB_eWiseAdd_Matrix_BinaryOp","text":"GrB_eWiseAdd_Matrix_BinaryOp(C, Mask, accum, add, A, B, desc)\n\nCompute element-wise matrix addition using binary operator. C<Mask> = accum (C, A + B)\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> A = GrB_Matrix{Int64}()\nGrB_Matrix{Int64}\n\njulia> GrB_Matrix_new(A, GrB_INT64, 4, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I1 = ZeroBasedIndex[0, 0, 2, 2]; J1 = ZeroBasedIndex[1, 2, 0, 2]; X1 = [10, 20, 30, 40]; n1 = 4;\n\njulia> GrB_Matrix_build(A, I1, J1, X1, n1, GrB_FIRST_INT64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> B = GrB_Matrix{Int64}()\nGrB_Matrix{Int64}\n\njulia> GrB_Matrix_new(B, GrB_INT64, 4, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I2 = [0, 0, 2]; J2 = [3, 2, 0]; X2 = [15, 16, 17]; n2 = 3;\n\njulia> GrB_Matrix_build(B, I2, J2, X2, n2, GrB_FIRST_INT64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> C = GrB_Matrix{Int64}()\nGrB_Matrix{Int64}\n\njulia> GrB_Matrix_new(C, GrB_INT64, 4, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_eWiseAdd_Matrix_BinaryOp(C, GrB_NULL, GrB_NULL, GrB_PLUS_INT64, A, B, GrB_NULL)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Matrix_extractTuples(C)\njulia> @GxB_fprint(C, GxB_COMPLETE)\n\nGraphBLAS matrix: C \nnrows: 4 ncols: 4 max # entries: 5\nformat: standard CSR vlen: 4 nvec_nonempty: 2 nvec: 4 plen: 4 vdim: 4\nhyper_ratio 0.0625\nGraphBLAS type:  int64_t size: 8\nnumber of entries: 5 \nrow: 0 : 3 entries [0:2]\n    column 1: int64 10\n    column 2: int64 36\n    column 3: int64 15\nrow: 2 : 2 entries [3:4]\n    column 0: int64 47\n    column 2: int64 40\n\n\n\n\n\n","category":"function"},{"location":"operations/#Extract-1","page":"Operations","title":"Extract","text":"","category":"section"},{"location":"operations/#","page":"Operations","title":"Operations","text":"GrB_extract\nGrB_Vector_extract\nGrB_Matrix_extract\nGrB_Col_extract","category":"page"},{"location":"operations/#GraphBLASInterface.GrB_extract","page":"Operations","title":"GraphBLASInterface.GrB_extract","text":"GrB_extract(arg1, Mask, accum, arg4, ...)\n\nGeneric matrix/vector extraction.\n\n\n\n\n\n","category":"function"},{"location":"operations/#GraphBLASInterface.GrB_Vector_extract","page":"Operations","title":"GraphBLASInterface.GrB_Vector_extract","text":"GrB_Vector_extract(w, mask, accum, u, I, ni, desc)\n\nExtract a sub-vector from a larger vector as specified by a set of indices. The result is a vector whose size is equal to the number of indices.\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> V = GrB_Vector{Int64}()\nGrB_Vector{Int64}\n\njulia> GrB_Vector_new(V, GrB_INT64, 5)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I = ZeroBasedIndex[1, 2, 4]; X = [15, 32, 84]; n = 3;\n\njulia> GrB_Vector_build(V, I, X, n, GrB_FIRST_INT64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> @GxB_Vector_fprint(V, GxB_COMPLETE)\n\nGraphBLAS vector: V\nnrows: 5 ncols: 1 max # entries: 3\nformat: standard CSC vlen: 5 nvec_nonempty: 1 nvec: 1 plen: 1 vdim: 1\nhyper_ratio 0.0625\nGraphBLAS type:  int64_t size: 8\nnumber of entries: 3\ncolumn: 0 : 3 entries [0:2]\n    row 1: int64 15\n    row 2: int64 32\n    row 4: int64 84\n\n\njulia> W = GrB_Vector{Int64}()\nGrB_Vector{Int64}\n\njulia> GrB_Vector_new(W, GrB_INT64, 2)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Vector_extract(W, GrB_NULL, GrB_NULL, V, ZeroBasedIndex[1, 4], 2, GrB_NULL)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Vector_extractTuples(W)[2]\n2-element Array{Int64,1}:\n 15\n 84\n\n\n\n\n\n","category":"function"},{"location":"operations/#GraphBLASInterface.GrB_Matrix_extract","page":"Operations","title":"GraphBLASInterface.GrB_Matrix_extract","text":"GrB_Matrix_extract(C, Mask, accum, A, I, ni, J, nj, desc)\n\nExtract a sub-matrix from a larger matrix as specified by a set of row indices and a set of column indices. The result is a matrix whose size is equal to size of the sets of indices.\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> MAT = GrB_Matrix{Int8}()\nGrB_Matrix{Int8}\n\njulia> GrB_Matrix_new(MAT, GrB_INT8, 4, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I = ZeroBasedIndex[1, 2, 2, 2, 3]; J = ZeroBasedIndex[1, 2, 1, 3, 3]; X = Int8[2, 3, 4, 5, 6]; n = 5;\n\njulia> GrB_Matrix_build(MAT, I, J, X, n, GrB_FIRST_INT8)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> @GxB_Matrix_fprint(MAT, GxB_COMPLETE)\n\nGraphBLAS matrix: MAT\nnrows: 4 ncols: 4 max # entries: 5\nformat: standard CSR vlen: 4 nvec_nonempty: 3 nvec: 4 plen: 4 vdim: 4\nhyper_ratio 0.0625\nGraphBLAS type:  int8_t size: 1\nnumber of entries: 5\nrow: 1 : 1 entries [0:0]\n    column 1: int8 2\nrow: 2 : 3 entries [1:3]\n    column 1: int8 4\n    column 2: int8 3\n    column 3: int8 5\nrow: 3 : 1 entries [4:4]\n    column 3: int8 6\n\n\njulia> OUT = GrB_Matrix{Int8}()\nGrB_Matrix{Int8}\n\njulia> GrB_Matrix_new(OUT, GrB_INT8, 2, 2)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Matrix_extract(OUT, GrB_NULL, GrB_NULL, MAT, ZeroBasedIndex[1, 3], 2, ZeroBasedIndex[1, 3], 2, GrB_NULL)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Matrix_extractTuples(OUT)[3]\n2-element Array{Int8,1}:\n 2\n 6\n\n\n\n\n\n","category":"function"},{"location":"operations/#GraphBLASInterface.GrB_Col_extract","page":"Operations","title":"GraphBLASInterface.GrB_Col_extract","text":"GrB_Col_extract(w, mask, accum, A, I, ni, j, desc)\n\nExtract from one column of a matrix into a vector. With the transpose descriptor for the source matrix, elements of an arbitrary row of the matrix can be extracted with this function as well.\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> MAT = GrB_Matrix{Int8}()\nGrB_Matrix{Int8}\n\njulia> GrB_Matrix_new(MAT, GrB_INT8, 4, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I = ZeroBasedIndex[1, 2, 2, 2, 3]; J = ZeroBasedIndex[1, 2, 1, 3, 3]; X = Int8[23, 34, 43, 57, 61]; n = 5;\n\njulia> GrB_Matrix_build(MAT, I, J, X, n, GrB_FIRST_INT8)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> @GxB_Matrix_fprint(MAT, GxB_COMPLETE)\n\nGraphBLAS matrix: MAT\nnrows: 4 ncols: 4 max # entries: 5\nformat: standard CSR vlen: 4 nvec_nonempty: 3 nvec: 4 plen: 4 vdim: 4\nhyper_ratio 0.0625\nGraphBLAS type:  int8_t size: 1\nnumber of entries: 5\nrow: 1 : 1 entries [0:0]\n    column 1: int8 23\nrow: 2 : 3 entries [1:3]\n    column 1: int8 43\n    column 2: int8 34\n    column 3: int8 57\nrow: 3 : 1 entries [4:4]\n    column 3: int8 61\n\n\njulia> desc = GrB_Descriptor()\nGrB_Descriptor\n\njulia> GrB_Descriptor_new(desc)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Descriptor_set(desc, GrB_INP0, GrB_TRAN) # descriptor to transpose first input\nGrB_SUCCESS::GrB_Info = 0\n\njulia> out = GrB_Vector{Int8}()\nGrB_Vector{Int8}\n\njulia> GrB_Vector_new(out, GrB_INT8, 3)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Col_extract(out, GrB_NULL, GrB_NULL, MAT, ZeroBasedIndex[1, 2, 3], 3, ZeroBasedIndex(2), desc) # extract elements of row 2\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Vector_extractTuples(out)[2]\n3-element Array{Int8,1}:\n 43\n 34\n 57\n\n\n\n\n\n","category":"function"},{"location":"operations/#Assign-1","page":"Operations","title":"Assign","text":"","category":"section"},{"location":"operations/#","page":"Operations","title":"Operations","text":"GrB_assign\nGrB_Vector_assign\nGrB_Matrix_assign\nGrB_Col_assign\nGrB_Row_assign","category":"page"},{"location":"operations/#GraphBLASInterface.GrB_assign","page":"Operations","title":"GraphBLASInterface.GrB_assign","text":"GrB_assign(arg1, Mask, accum, arg4, arg5, ...)\n\nGeneric method for submatrix/subvector assignment.\n\n\n\n\n\n","category":"function"},{"location":"operations/#GraphBLASInterface.GrB_Vector_assign","page":"Operations","title":"GraphBLASInterface.GrB_Vector_assign","text":"GrB_Vector_assign(w, mask, accum, u, I, ni, desc)\n\nAssign values from one GraphBLAS vector to a subset of a vector as specified by a set of indices. The size of the input vector is the same size as the index array provided.\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> w = GrB_Vector{Int64}()\nGrB_Vector{Int64}\n\njulia> GrB_Vector_new(w, GrB_INT64, 5)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> u = GrB_Vector{Int64}()\nGrB_Vector{Int64}\n\njulia> GrB_Vector_new(u, GrB_INT64, 2)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I = ZeroBasedIndex[0, 1]; X = [10, 20]; n = 2;\n\njulia> GrB_Vector_build(u, I, X, n, GrB_FIRST_INT64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Vector_assign(w, GrB_NULL, GrB_NULL, u, [2, 4], 2, GrB_NULL)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Vector_extractTuples(w)\n(ZeroBasedIndex[ZeroBasedIndex(0x0000000000000002), ZeroBasedIndex(0x0000000000000004)], [10, 20])\n\n\n\n\n\nGrB_Vector_assign(w, mask, accum, x, I, ni, desc)\n\nAssign the same value to a specified subset of vector elements. With the use of GrB_ALL, the entire destination vector can be filled with the constant.\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> w = GrB_Vector{Float64}()\nGrB_Vector{Float64}\n\njulia> GrB_Vector_new(w, GrB_FP64, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Vector_assign(w, GrB_NULL, GrB_NULL, 2.3, ZeroBasedIndex[0, 3], 2, GrB_NULL)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Vector_extractTuples(w)\n(ZeroBasedIndex[ZeroBasedIndex(0x0000000000000000), ZeroBasedIndex(0x0000000000000003)], [2.3, 2.3])\n\n\n\n\n\n","category":"function"},{"location":"operations/#GraphBLASInterface.GrB_Matrix_assign","page":"Operations","title":"GraphBLASInterface.GrB_Matrix_assign","text":"GrB_Matrix_assign(C, Mask, accum, A, I, ni, J, nj, desc)\n\nAssign values from one GraphBLAS matrix to a subset of a matrix as specified by a set of indices. The dimensions of the input matrix are the same size as the row and column index arrays provided.\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> A = GrB_Matrix{Int64}()\nGrB_Matrix{Int64}\n\njulia> GrB_Matrix_new(A, GrB_INT64, 4, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I = ZeroBasedIndex[0, 0, 2, 2]; J = ZeroBasedIndex[1, 2, 0, 2]; X = [10, 20, 30, 40]; n = 4;\n\njulia> GrB_Matrix_build(A, I, J, X, n, GrB_FIRST_INT64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> C = GrB_Matrix{Int64}()\nGrB_Matrix{Int64}\n\njulia> GrB_Matrix_new(C, GrB_INT64, 4, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Matrix_assign(C, GrB_NULL, GrB_NULL, A, GrB_ALL, 4, GrB_ALL, 4, GrB_NULL)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_wait()\nGrB_SUCCESS::GrB_Info = 0\n\njulia> @GxB_Matrix_fprint(C, GxB_COMPLETE)\n\nGraphBLAS matrix: C\nnrows: 4 ncols: 4 max # entries: 4\nformat: standard CSR vlen: 4 nvec_nonempty: 2 nvec: 4 plen: 4 vdim: 4\nhyper_ratio 0.0625\nGraphBLAS type:  int64_t size: 8\nnumber of entries: 4\nrow: 0 : 2 entries [0:1]\n    column 1: int64 10\n    column 2: int64 20\nrow: 2 : 2 entries [2:3]\n    column 0: int64 30\n    column 2: int64 40\n\n\n\n\n\nGrB_Matrix_assign(C, Mask, accum, x, I, ni, J, nj, desc)\n\nAssign the same value to a specified subset of matrix elements. With the use of GrB_ALL, the entire destination matrix can be filled with the constant.\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> A = GrB_Matrix{Bool}()\nGrB_Matrix{Bool}\n\njulia> GrB_Matrix_new(A, GrB_BOOL, 4, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Matrix_assign(A, GrB_NULL, GrB_NULL, true, ZeroBasedIndex[0, 1], 2, ZeroBasedIndex[0, 1], 2, GrB_NULL)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_wait()\nGrB_SUCCESS::GrB_Info = 0\n\njulia> @GxB_Matrix_fprint(A, GxB_COMPLETE)\n\nGraphBLAS matrix: A\nnrows: 4 ncols: 4 max # entries: 4\nformat: standard CSR vlen: 4 nvec_nonempty: 2 nvec: 4 plen: 4 vdim: 4\nhyper_ratio 0.0625\nGraphBLAS type:  bool size: 1\nnumber of entries: 4\nrow: 0 : 2 entries [0:1]\n    column 0: bool 1\n    column 1: bool 1\nrow: 1 : 2 entries [2:3]\n    column 0: bool 1\n    column 1: bool 1\n\n\n\n\n\n","category":"function"},{"location":"operations/#GraphBLASInterface.GrB_Col_assign","page":"Operations","title":"GraphBLASInterface.GrB_Col_assign","text":"GrB_Col_assign(C, mask, accum, u, I, ni, j, desc)\n\nAssign the contents of a vector to a subset of elements in one column of a matrix. Note that since the output cannot be transposed, a different variant of assign is provided to assign to a row of matrix.\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> A = GrB_Matrix{Int64}()\nGrB_Matrix{Int64}\n\njulia> GrB_Matrix_new(A, GrB_INT64, 4, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I = ZeroBasedIndex[0, 0, 2, 2]; J = ZeroBasedIndex[1, 2, 0, 2]; X = [10, 20, 30, 40]; n = 4;\n\njulia> GrB_Matrix_build(A, I, J, X, n, GrB_FIRST_INT64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> u = GrB_Vector{Int64}()\nGrB_Vector{Int64}\n\njulia> GrB_Vector_new(u, GrB_INT64, 2)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I2 = ZeroBasedIndex[0, 1]; X2 = [5, 6]; n2 = 2;\n\njulia> GrB_Vector_build(u, I2, X2, n2, GrB_FIRST_INT64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Col_assign(A, GrB_NULL, GrB_NULL, u, ZeroBasedIndex[1, 2], 2, ZeroBasedIndex(0), GrB_NULL)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_wait()\nGrB_SUCCESS::GrB_Info = 0\n\njulia> @GxB_Matrix_fprint(A, GxB_COMPLETE)\n\nGraphBLAS matrix: A\nnrows: 4 ncols: 4 max # entries: 7\nformat: standard CSR vlen: 4 nvec_nonempty: 3 nvec: 4 plen: 4 vdim: 4\nhyper_ratio 0.0625\nGraphBLAS type:  int64_t size: 8\nnumber of entries: 5\nrow: 0 : 2 entries [0:1]\n    column 1: int64 10\n    column 2: int64 20\nrow: 1 : 1 entries [2:2]\n    column 0: int64 5\nrow: 2 : 2 entries [3:4]\n    column 0: int64 6\n    column 2: int64 40\n\n\n\n\n\n","category":"function"},{"location":"operations/#GraphBLASInterface.GrB_Row_assign","page":"Operations","title":"GraphBLASInterface.GrB_Row_assign","text":"GrB_Row_assign(C, mask, accum, u, i, J, nj, desc)\n\nAssign the contents of a vector to a subset of elements in one row of a matrix. Note that since the output cannot be transposed, a different variant of assign is provided to assign to a column of a matrix.\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> A = GrB_Matrix{Int64}()\nGrB_Matrix{Int64}\n\njulia> GrB_Matrix_new(A, GrB_INT64, 4, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I = ZeroBasedIndex[0, 0, 2, 2]; J = ZeroBasedIndex[1, 2, 0, 2]; X = [10, 20, 30, 40]; n = 4;\n\njulia> GrB_Matrix_build(A, I, J, X, n, GrB_FIRST_INT64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> u = GrB_Vector{Int64}()\nGrB_Vector{Int64}\n\njulia> GrB_Vector_new(u, GrB_INT64, 2)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I2 = ZeroBasedIndex[0, 1]; X2 = [5, 6]; n2 = 2;\n\njulia> GrB_Vector_build(u, I2, X2, n2, GrB_FIRST_INT64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Row_assign(A, GrB_NULL, GrB_NULL, u, ZeroBasedIndex(0), ZeroBasedIndex[1, 3], 2, GrB_NULL)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_wait()\nGrB_SUCCESS::GrB_Info = 0\n\njulia> @GxB_Matrix_fprint(A, GxB_COMPLETE)\n\nGraphBLAS matrix: A\nnrows: 4 ncols: 4 max # entries: 7\nformat: standard CSR vlen: 4 nvec_nonempty: 2 nvec: 4 plen: 4 vdim: 4\nhyper_ratio 0.0625\nGraphBLAS type:  int64_t size: 8\nnumber of entries: 5\nrow: 0 : 3 entries [0:2]\n    column 1: int64 5\n    column 2: int64 20\n    column 3: int64 6\nrow: 2 : 2 entries [3:4]\n    column 0: int64 30\n    column 2: int64 40\n\n\n\n\n\n","category":"function"},{"location":"operations/#Apply-1","page":"Operations","title":"Apply","text":"","category":"section"},{"location":"operations/#","page":"Operations","title":"Operations","text":"GrB_apply\nGrB_Vector_apply\nGrB_Matrix_apply","category":"page"},{"location":"operations/#GraphBLASInterface.GrB_apply","page":"Operations","title":"GraphBLASInterface.GrB_apply","text":"GrB_apply(C, Mask, accum, op, A, desc)\n\nGeneric matrix/vector apply.\n\n\n\n\n\n","category":"function"},{"location":"operations/#GraphBLASInterface.GrB_Vector_apply","page":"Operations","title":"GraphBLASInterface.GrB_Vector_apply","text":"GrB_Vector_apply(w, mask, accum, op, u, desc)\n\nCompute the transformation of the values of the elements of a vector using a unary function.\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> u = GrB_Vector{Int64}()\nGrB_Vector{Int64}\n\njulia> GrB_Vector_new(u, GrB_INT64, 3)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I = ZeroBasedIndex[0, 2]; X = [10, 20]; n = 2;\n\njulia> GrB_Vector_build(u, I, X, n, GrB_FIRST_INT64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> w = GrB_Vector{Int64}()\nGrB_Vector{Int64}\n\njulia> GrB_Vector_new(w, GrB_INT64, 3)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Vector_apply(w, GrB_NULL, GrB_NULL, GrB_AINV_INT64, u, GrB_NULL)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> @GxB_fprint(w, GxB_COMPLETE)\n\nGraphBLAS vector: w \nnrows: 3 ncols: 1 max # entries: 2\nformat: standard CSC vlen: 3 nvec_nonempty: 1 nvec: 1 plen: 1 vdim: 1\nhyper_ratio 0.0625\nGraphBLAS type:  int64_t size: 8\nnumber of entries: 2 \ncolumn: 0 : 2 entries [0:1]\n    row 0: int64 -10\n    row 2: int64 -20\n\n\n\n\n\n","category":"function"},{"location":"operations/#GraphBLASInterface.GrB_Matrix_apply","page":"Operations","title":"GraphBLASInterface.GrB_Matrix_apply","text":"GrB_Matrix_apply(C, Mask, accum, op, A, desc)\n\nCompute the transformation of the values of the elements of a matrix using a unary function.\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> A = GrB_Matrix{Int64}()\nGrB_Matrix{Int64}\n\njulia> GrB_Matrix_new(A, GrB_INT64, 2, 2)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I = ZeroBasedIndex[0, 0, 1]; J = ZeroBasedIndex[0, 1, 1]; X = [10, 20, 30]; n = 3;\n\njulia> GrB_Matrix_build(A, I, J, X, n, GrB_FIRST_INT64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> B = GrB_Matrix{Int64}()\nGrB_Matrix{Int64}\n\njulia> GrB_Matrix_new(B, GrB_INT64, 2, 2)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Matrix_apply(B, GrB_NULL, GrB_NULL, GrB_AINV_INT64, A, GrB_NULL)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> @GxB_fprint(B, GxB_COMPLETE)\n\nGraphBLAS matrix: B\nnrows: 2 ncols: 2 max # entries: 3\nformat: standard CSR vlen: 2 nvec_nonempty: 2 nvec: 2 plen: 2 vdim: 2\nhyper_ratio 0.0625\nGraphBLAS type:  int64_t size: 8\nnumber of entries: 3\nrow: 0 : 2 entries [0:1]\n    column 0: int64 -10\n    column 1: int64 -20\nrow: 1 : 1 entries [2:2]\n    column 1: int64 -30\n\n\n\n\n\n","category":"function"},{"location":"operations/#Reduce-1","page":"Operations","title":"Reduce","text":"","category":"section"},{"location":"operations/#","page":"Operations","title":"Operations","text":"GrB_reduce\nGrB_Matrix_reduce_Monoid\nGrB_Matrix_reduce_BinaryOp\nGrB_Vector_reduce\nGrB_Matrix_reduce","category":"page"},{"location":"operations/#GraphBLASInterface.GrB_reduce","page":"Operations","title":"GraphBLASInterface.GrB_reduce","text":"GrB_reduce(arg1, arg2, arg3, arg4, ...)\n\nGeneric method for matrix/vector reduction to a vector or scalar.\n\n\n\n\n\n","category":"function"},{"location":"operations/#GraphBLASInterface.GrB_Matrix_reduce_Monoid","page":"Operations","title":"GraphBLASInterface.GrB_Matrix_reduce_Monoid","text":"GrB_Matrix_reduce_Monoid(w, mask, accum, monoid, A, desc)\n\nReduce the entries in a matrix to a vector. By default these methods compute a column vector w such that w(i) = sum(A(i,:)), where \"sum\" is a commutative and associative monoid with an identity value. A can be transposed, which reduces down the columns instead of the rows.\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> A = GrB_Matrix{Int64}()\nGrB_Matrix{Int64}\n\njulia> GrB_Matrix_new(A, GrB_INT64, 4, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I = ZeroBasedIndex[0, 0, 2, 2]; J = ZeroBasedIndex[1, 2, 0, 2]; X = [10, 20, 30, 40]; n = 4;\n\njulia> GrB_Matrix_build(A, I, J, X, n, GrB_FIRST_INT64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> w = GrB_Vector{Int64}()\nGrB_Vector{Int64}\n\njulia> GrB_Vector_new(w, GrB_INT64, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Matrix_reduce_Monoid(w, GrB_NULL, GrB_NULL, GxB_PLUS_INT64_MONOID, A, GrB_NULL)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> @GxB_fprint(w, GxB_COMPLETE)\n\nGraphBLAS vector: w\nnrows: 4 ncols: 1 max # entries: 2\nformat: standard CSC vlen: 4 nvec_nonempty: 1 nvec: 1 plen: 1 vdim: 1\nhyper_ratio 0.0625\nGraphBLAS type:  int64_t size: 8\nnumber of entries: 2\ncolumn: 0 : 2 entries [0:1]\n    row 0: int64 30\n    row 2: int64 70\n\n\n\n\n\n","category":"function"},{"location":"operations/#GraphBLASInterface.GrB_Matrix_reduce_BinaryOp","page":"Operations","title":"GraphBLASInterface.GrB_Matrix_reduce_BinaryOp","text":"GrB_Matrix_reduce_BinaryOp(w, mask, accum, op, A, desc)\n\nReduce the entries in a matrix to a vector. By default these methods compute a column vector w such that w(i) = sum(A(i,:)), where \"sum\" is a commutative and associative binary operator. A can be transposed, which reduces down the columns instead of the rows.\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> A = GrB_Matrix{Int64}()\nGrB_Matrix{Int64}\n\njulia> GrB_Matrix_new(A, GrB_INT64, 4, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I = ZeroBasedIndex[0, 0, 2, 2]; J = ZeroBasedIndex[1, 2, 0, 2]; X = [10, 20, 30, 40]; n = 4;\n\njulia> GrB_Matrix_build(A, I, J, X, n, GrB_FIRST_INT64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> w = GrB_Vector{Int64}()\nGrB_Vector{Int64}\n\njulia> GrB_Vector_new(w, GrB_INT64, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Matrix_reduce_BinaryOp(w, GrB_NULL, GrB_NULL, GrB_TIMES_INT64, A, GrB_NULL)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> @GxB_fprint(w, GxB_COMPLETE)\n\nGraphBLAS vector: w\nnrows: 4 ncols: 1 max # entries: 2\nformat: standard CSC vlen: 4 nvec_nonempty: 1 nvec: 1 plen: 1 vdim: 1\nhyper_ratio 0.0625\nGraphBLAS type:  int64_t size: 8\nnumber of entries: 2\ncolumn: 0 : 2 entries [0:1]\n    row 0: int64 200\n    row 2: int64 1200\n\n\n\n\n\n","category":"function"},{"location":"operations/#GraphBLASInterface.GrB_Vector_reduce","page":"Operations","title":"GraphBLASInterface.GrB_Vector_reduce","text":"GrB_Vector_reduce(monoid, u, desc)\n\nReduce entries in a vector to a scalar. All entries in the vector are \"summed\" using the reduce monoid, which must be associative (otherwise the results are undefined). If the vector has no entries, the result is the identity value of the monoid.\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> u = GrB_Vector{Int64}()\nGrB_Vector{Int64}\n\njulia> GrB_Vector_new(u, GrB_INT64, 5)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I = ZeroBasedIndex[0, 2, 4]; X = [10, 20, 30]; n = 3;\n\njulia> GrB_Vector_build(u, I, X, n, GrB_FIRST_INT64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Vector_reduce(GxB_MAX_INT64_MONOID, u, GrB_NULL)\n30\n\n\n\n\n\n","category":"function"},{"location":"operations/#GraphBLASInterface.GrB_Matrix_reduce","page":"Operations","title":"GraphBLASInterface.GrB_Matrix_reduce","text":"GrB_Matrix_reduce(monoid, A, desc)\n\nReduce entries in a matrix to a scalar. All entries in the matrix are \"summed\" using the reduce monoid, which must be associative (otherwise the results are undefined). If the matrix has no entries, the result is the identity value of the monoid.\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> A = GrB_Matrix{Int64}()\nGrB_Matrix{Int64}\n\njulia> GrB_Matrix_new(A, GrB_INT64, 4, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I = ZeroBasedIndex[0, 0, 2, 2]; J = ZeroBasedIndex[1, 2, 0, 2]; X = [10, 20, 30, 40]; n = 4;\n\njulia> GrB_Matrix_build(A, I, J, X, n, GrB_FIRST_INT64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_Matrix_reduce(GxB_MIN_INT64_MONOID, A, GrB_NULL)\n10\n\n\n\n\n\n","category":"function"},{"location":"operations/#Transpose-1","page":"Operations","title":"Transpose","text":"","category":"section"},{"location":"operations/#","page":"Operations","title":"Operations","text":"GrB_transpose","category":"page"},{"location":"operations/#GraphBLASInterface.GrB_transpose","page":"Operations","title":"GraphBLASInterface.GrB_transpose","text":"GrB_transpose(C, Mask, accum, A, desc)\n\nCompute a new matrix that is the transpose of the source matrix.\n\nExamples\n\njulia> using GraphBLASInterface, SuiteSparseGraphBLAS\n\njulia> GrB_init(GrB_NONBLOCKING)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> M = GrB_Matrix{Int64}()\nGrB_Matrix{Int64}\n\njulia> GrB_Matrix_new(M, GrB_INT64, 4, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> I = ZeroBasedIndex[0, 0]; J = ZeroBasedIndex[1, 2]; X = [10, 20]; n = 2;\n\njulia> GrB_Matrix_build(M, I, J, X, n, GrB_FIRST_INT64)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> @GxB_fprint(M, GxB_COMPLETE)\n\nGraphBLAS matrix: M \nnrows: 4 ncols: 4 max # entries: 2\nformat: standard CSR vlen: 4 nvec_nonempty: 1 nvec: 4 plen: 4 vdim: 4\nhyper_ratio 0.0625\nGraphBLAS type:  int64_t size: 8\nnumber of entries: 2 \nrow: 0 : 2 entries [0:1]\n    column 1: int64 10\n    column 2: int64 20\n\njulia> M_TRAN = GrB_Matrix{Int64}()\nGrB_Matrix{Int64}\n\njulia> GrB_Matrix_new(M_TRAN, GrB_INT64, 4, 4)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> GrB_transpose(M_TRAN, GrB_NULL, GrB_NULL, M, GrB_NULL)\nGrB_SUCCESS::GrB_Info = 0\n\njulia> @GxB_fprint(M_TRAN, GxB_COMPLETE)\n\nGraphBLAS matrix: M_TRAN \nnrows: 4 ncols: 4 max # entries: 2\nformat: standard CSR vlen: 4 nvec_nonempty: 2 nvec: 4 plen: 4 vdim: 4\nhyper_ratio 0.0625\nGraphBLAS type:  int64_t size: 8\nnumber of entries: 2 \nrow: 1 : 1 entries [0:0]\n    column 0: int64 10\nrow: 2 : 1 entries [1:1]\n    column 0: int64 20\n\n\n\n\n\n","category":"function"}]
}
