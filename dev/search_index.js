var documenterSearchIndex = {"docs":
[{"location":"binaryops/#Binary-Operators","page":"Binary Operators","title":"Binary Operators","text":"","category":"section"},{"location":"binaryops/","page":"Binary Operators","title":"Binary Operators","text":"Binary operators are defined on three domains D_1 times D_2 rightarrow D_3. However, the vast majority of binary operators are defined on a single domain.","category":"page"},{"location":"binaryops/#Built-Ins","page":"Binary Operators","title":"Built-Ins","text":"","category":"section"},{"location":"binaryops/","page":"Binary Operators","title":"Binary Operators","text":"All built-in binary operators can be found in the BinaryOps submodule.","category":"page"},{"location":"binaryops/","page":"Binary Operators","title":"Binary Operators","text":"using Pkg\nPkg.activate(\"..\")\ncd(\"..\")\nusing SuiteSparseGraphBLAS\nusing Latexify\nhead = [\"UnaryOp\", \"Function Form\", \"Types\"]\nv1 = filter((x) -> getproperty(BinaryOps, x) isa SuiteSparseGraphBLAS.AbstractBinaryOp, names(BinaryOps))\nops = getproperty.(Ref(BinaryOps), v1)\nv2 = convert(Vector{Any}, SuiteSparseGraphBLAS.juliaop.(ops))\nv4 = SuiteSparseGraphBLAS.validtypes.(ops)\n\nv1 = \"`\" .* string.(v1) .* \"`\"\nv2 = \"`\" .* string.(v2) .* \"`\"\nLatexify.mdtable(hcat(v1,v2,v4); head, latex=false)","category":"page"},{"location":"semirings/#Semirings","page":"Semirings","title":"Semirings","text":"","category":"section"},{"location":"semirings/","page":"Semirings","title":"Semirings","text":"A semiring in GraphBLAS is a set of three domains D_1, D_2, and D_3, along with two binary operators and an identity element mathbb0. ","category":"page"},{"location":"semirings/","page":"Semirings","title":"Semirings","text":"The first operator, oplus or \"add\" is a commutative and associative monoid defined on D_3 times D_3 rightarrow D_3. The identity of the monoid is mathbb0. See Monoids for more information.","category":"page"},{"location":"semirings/","page":"Semirings","title":"Semirings","text":"The second, otimes or \"multiply\", is a binary operator defined on D_1 times D_2 rightarrow D_3. See Binary Operators for more information. ","category":"page"},{"location":"semirings/","page":"Semirings","title":"Semirings","text":"A semiring is denoted by a tuple (D_1 D_2 D_3 oplus otimes mathbb0). However in the vast majority of cases D_1 = D_2 = D_3 so this is often shortened to (oplus otimes).","category":"page"},{"location":"semirings/","page":"Semirings","title":"Semirings","text":"Semirings are used in a single GraphBLAS operation, mul[!].","category":"page"},{"location":"semirings/#Built-Ins","page":"Semirings","title":"Built-Ins","text":"","category":"section"},{"location":"semirings/","page":"Semirings","title":"Semirings","text":"There are over 200 built-in semirings available as constants in the Semirings submodule. These are named <ADD>_<MULTIPLY> and include many of the most commonly used semirings such as:","category":"page"},{"location":"semirings/","page":"Semirings","title":"Semirings","text":"Arithmetic semiring (+ times), available as Semirings.PLUS_TIMES and as the default operator for mul[!].\nTropical semirings (max +), available as Semirings.MAX_PLUS, and (min +), available as Semirings.MIN_PLUS).\nBoolean semiring (vee wedge) available as Semirings.LOR_LAND. \nGF2, the two-element Galois Field (textxor wedge), available as Semirings.LXOR_LAND.","category":"page"},{"location":"semirings/","page":"Semirings","title":"Semirings","text":"Below are the built-in semirings available, along with their associated monoids, binary operators, and types. For common semirings where the binary operator and monoid have equivalent julia functions, those functions are listed.","category":"page"},{"location":"semirings/","page":"Semirings","title":"Semirings","text":"note: Note\nIn all cases the input and output types of the semirings are the same, except for cases where the \"add\" types and \"multiply\" output output types are boolean, such as in LAND_GE.","category":"page"},{"location":"semirings/","page":"Semirings","title":"Semirings","text":"using Pkg\nPkg.activate(\"..\")\ncd(\"..\")\nusing SuiteSparseGraphBLAS\nusing Latexify\nhead = [\"Semiring\", \"⊕\", \"⊗\", \"Types\"]\nv1 = filter((x) -> getproperty(Semirings, x) isa SuiteSparseGraphBLAS.AbstractSemiring, names(Semirings))\nops = getproperty.(Ref(Semirings), v1)\nv2 = convert(Vector{Any}, SuiteSparseGraphBLAS.addop.(ops))\nv3 = convert(Vector{Any}, SuiteSparseGraphBLAS.mulop.(ops))\nfor i in 1:length(v2)\n    if v2[i] === nothing\n        x = \n        v2[i] = replace(summary(SuiteSparseGraphBLAS.monoid(ops[i])), \"SuiteSparseGraphBLAS.Monoids.\" => \"\")[1:end-2]\n    end\n    if v3[i] === nothing\n        v3[i] = replace(summary(SuiteSparseGraphBLAS.binop(ops[i])), \"SuiteSparseGraphBLAS.BinaryOps.\" => \"\")[1:end-2]\n    end\nend\nv4 = SuiteSparseGraphBLAS.validtypes.(ops)\n\nv1 = \"`\" .* string.(v1) .* \"`\"\nv2 = \"`\" .* string.(v2) .* \"`\"\nv3 = \"`\" .* string.(v3) .* \"`\"\nLatexify.mdtable(hcat(v1,v2,v3,v4); head, latex=false)","category":"page"},{"location":"udfs/#User-Defined-Operators","page":"User Defined Operators","title":"User Defined Operators","text":"","category":"section"},{"location":"udfs/","page":"User Defined Operators","title":"User Defined Operators","text":"warning: Experimental\nThis is still a work in progress, and subject to change. Please open an issue if you find any problems!","category":"page"},{"location":"udfs/","page":"User Defined Operators","title":"User Defined Operators","text":"GraphBLAS supports users to supply functions as operators. Constructors exported are:","category":"page"},{"location":"udfs/","page":"User Defined Operators","title":"User Defined Operators","text":"UnaryOp(name::String, fn::Function, [type | types | ztype, xtype | ztypes, xtypes])\nBinaryOp(name::String, fn::Function, [type | types | ztype, xtype | ztypes, xtypes])\nMonoid(name::String, binop::Union{AbstractBinaryOp, GrB_BinaryOp}, id::T, terminal::T = nothing): all types must be the same.\nSemiring(name::String, add::[GrB_Monoid | AbstractMonoid], mul::[GrB_BinaryOp | AbstractBinaryOp])","category":"page"},{"location":"udfs/","page":"User Defined Operators","title":"User Defined Operators","text":"GrB_ prefixed arguments are typed operators, such as the result of UnaryOps.COS[Float64]. Type arguments may be single types or vectors of types. If no type is supplied to UnaryOp or BinaryOp they will default to constructing typed operators for all the built-in primitive types.","category":"page"},{"location":"udfs/","page":"User Defined Operators","title":"User Defined Operators","text":"The fn arguments to UnaryOp and BinaryOp must have one or two arguments respectively.","category":"page"},{"location":"udfs/","page":"User Defined Operators","title":"User Defined Operators","text":"danger: Performance\nDue to the nature of the underlying C library user-defined operators may be significantly slower than their built-in counterparts. When possible use the built-in operators, or combinations of them.","category":"page"},{"location":"udfs/","page":"User Defined Operators","title":"User Defined Operators","text":"note: Where to Find User-Defined Operators\nThe constructors for an operator add that operator to the submodule for that operator type. For instance UnaryOp(minus, -, Int64, Int64) will add UnaryOps.minus.","category":"page"},{"location":"selectops/#Select-Operators","page":"Select Operators","title":"Select Operators","text":"","category":"section"},{"location":"selectops/","page":"Select Operators","title":"Select Operators","text":"A SelectOp is effectively a binary or unary operation which is able to access the location of an element as well as its value. They define predicates for use with the select function.","category":"page"},{"location":"selectops/","page":"Select Operators","title":"Select Operators","text":"Applying select with a SelectOp will always return a result with the same type and shape as its argument.","category":"page"},{"location":"selectops/#Built-Ins","page":"Select Operators","title":"Built-Ins","text":"","category":"section"},{"location":"selectops/","page":"Select Operators","title":"Select Operators","text":"Built-in SelectOps can be found in the SelectOps submodule.","category":"page"},{"location":"selectops/","page":"Select Operators","title":"Select Operators","text":"SuiteSparseGraphBLAS.TRIL\nSuiteSparseGraphBLAS.TRIU\nSuiteSparseGraphBLAS.DIAG\nSuiteSparseGraphBLAS.OFFDIAG\nSuiteSparseGraphBLAS.NONZERO\nSuiteSparseGraphBLAS.NE\nSuiteSparseGraphBLAS.EQ\nSuiteSparseGraphBLAS.GT\nSuiteSparseGraphBLAS.GE\nSuiteSparseGraphBLAS.LT\nSuiteSparseGraphBLAS.LE","category":"page"},{"location":"selectops/#SuiteSparseGraphBLAS.TRIL","page":"Select Operators","title":"SuiteSparseGraphBLAS.TRIL","text":"select(SuiteSparseGraphBLAS.TRIL, A, k=0)\nselect(tril, A, k=0)\n\nSelect the entries on or below the kth diagonal of A.\n\nSee also: LinearAlgebra.tril\n\n\n\n\n\n","category":"constant"},{"location":"selectops/#SuiteSparseGraphBLAS.TRIU","page":"Select Operators","title":"SuiteSparseGraphBLAS.TRIU","text":"select(SuiteSparseGraphBLAS.TRIU, A, k=0)\nselect(triu, A, k=0)\n\nSelect the entries on or above the kth diagonal of A.\n\nSee also: LinearAlgebra.triu\n\n\n\n\n\n","category":"constant"},{"location":"selectops/#SuiteSparseGraphBLAS.DIAG","page":"Select Operators","title":"SuiteSparseGraphBLAS.DIAG","text":"select(DIAG, A, k=0)\n\nSelect the entries on the kth diagonal of A.\n\nSee also: LinearAlgebra.diag\n\n\n\n\n\n","category":"constant"},{"location":"selectops/#SuiteSparseGraphBLAS.OFFDIAG","page":"Select Operators","title":"SuiteSparseGraphBLAS.OFFDIAG","text":"select(OFFDIAG, A, k=0)\n\nSelect the entries not on the kth diagonal of A.\n\n\n\n\n\n","category":"constant"},{"location":"selectops/#SuiteSparseGraphBLAS.NONZERO","page":"Select Operators","title":"SuiteSparseGraphBLAS.NONZERO","text":"select(NONZERO, A)\nselect(nonzeros, A)\n\nSelect all entries in A with nonzero value.\n\n\n\n\n\n","category":"constant"},{"location":"selectops/#SuiteSparseGraphBLAS.NE","page":"Select Operators","title":"SuiteSparseGraphBLAS.NE","text":"select(NE, A, k)\nselect(!=, A, k)\n\nSelect all entries not equal to k.\n\n\n\n\n\n","category":"constant"},{"location":"selectops/#SuiteSparseGraphBLAS.EQ","page":"Select Operators","title":"SuiteSparseGraphBLAS.EQ","text":"select(EQ, A, k)\nselect(==, A, k)\n\nSelect all entries equal to k.\n\n\n\n\n\n","category":"constant"},{"location":"selectops/#SuiteSparseGraphBLAS.GT","page":"Select Operators","title":"SuiteSparseGraphBLAS.GT","text":"select(GT, A, k)\nselect(>, A, k)\n\nSelect all entries greater than k.\n\n\n\n\n\n","category":"constant"},{"location":"selectops/#SuiteSparseGraphBLAS.GE","page":"Select Operators","title":"SuiteSparseGraphBLAS.GE","text":"select(GE, A, k)\nselect(>=, A, k)\n\nSelect all entries greater than or equal to k.\n\n\n\n\n\n","category":"constant"},{"location":"selectops/#SuiteSparseGraphBLAS.LT","page":"Select Operators","title":"SuiteSparseGraphBLAS.LT","text":"select(LT, A, k)\nselect(<, A, k)\n\nSelect all entries less than k.\n\n\n\n\n\n","category":"constant"},{"location":"selectops/#SuiteSparseGraphBLAS.LE","page":"Select Operators","title":"SuiteSparseGraphBLAS.LE","text":"select(LE, A, k)\nselect(<=, A, k)\n\nSelect all entries less than or equal to k.\n\n\n\n\n\n","category":"constant"},{"location":"monoids/#Monoids","page":"Monoids","title":"Monoids","text":"","category":"section"},{"location":"monoids/","page":"Monoids","title":"Monoids","text":"A monoid is made up of a set or domain T and a binary operator z = f(x y) operating on the same domain, T times T rightarrow T. This binary operator must be associative, that is f(a f(b c)) = f(f(a b) c) is always true. Associativity is important for operations like reduce and the multiplication step of mul.","category":"page"},{"location":"monoids/","page":"Monoids","title":"Monoids","text":"The operator is also be equipped with an identity such that f(x 0) = f(0 x) = x. Some monoids are equipped with a terminal or annihilator such that z = f(z x) forall x.","category":"page"},{"location":"monoids/","page":"Monoids","title":"Monoids","text":"Monoids are used primarily in the reduce(@ref) operation. Their other use is as a component of semirings in the mul operation.","category":"page"},{"location":"monoids/#Built-Ins","page":"Monoids","title":"Built-Ins","text":"","category":"section"},{"location":"monoids/","page":"Monoids","title":"Monoids","text":"All built-in monoids can be found in the Monoids submodule.","category":"page"},{"location":"monoids/","page":"Monoids","title":"Monoids","text":"The documentation below uses T to refer to any of the valid primitive types listed in Supported Types, ℤ to refer to integers (signed and unsigned), F to refer to floating point types, ℝ to refer to real numbers (non-complex numbers).","category":"page"},{"location":"monoids/","page":"Monoids","title":"Monoids","text":"note: Note\nIn the case of floating point numbers +∞ and -∞ have their typical meanings. However, for integer types they indicate typemax and typemin respectively.","category":"page"},{"location":"monoids/","page":"Monoids","title":"Monoids","text":"SuiteSparseGraphBLAS.Monoids.MAX_MONOID\nSuiteSparseGraphBLAS.Monoids.MIN_MONOID\nSuiteSparseGraphBLAS.Monoids.PLUS_MONOID\nSuiteSparseGraphBLAS.Monoids.TIMES_MONOID\nSuiteSparseGraphBLAS.Monoids.ANY_MONOID\nSuiteSparseGraphBLAS.Monoids.BAND_MONOID\nSuiteSparseGraphBLAS.Monoids.BOR_MONOID\nSuiteSparseGraphBLAS.Monoids.BXNOR_MONOID\nSuiteSparseGraphBLAS.Monoids.BXOR_MONOID\nSuiteSparseGraphBLAS.Monoids.EQ_MONOID\nSuiteSparseGraphBLAS.Monoids.LAND_MONOID\nSuiteSparseGraphBLAS.Monoids.LOR_MONOID\nSuiteSparseGraphBLAS.Monoids.LXNOR_MONOID\nSuiteSparseGraphBLAS.Monoids.LXOR_MONOID","category":"page"},{"location":"monoids/#SuiteSparseGraphBLAS.Monoids.MAX_MONOID","page":"Monoids","title":"SuiteSparseGraphBLAS.Monoids.MAX_MONOID","text":"Max monoid: f(x::ℝ, y::ℝ)::ℝ = max(x, y)\n\nIdentity: -∞\nTerminal: +∞\n\n\n\n\n\n","category":"constant"},{"location":"monoids/#SuiteSparseGraphBLAS.Monoids.MIN_MONOID","page":"Monoids","title":"SuiteSparseGraphBLAS.Monoids.MIN_MONOID","text":"Minimum monoid: f(x::ℝ, y::ℝ)::ℝ = min(x, y)\n\nIdentity: +∞\nTerminal: -∞\n\n\n\n\n\n","category":"constant"},{"location":"monoids/#SuiteSparseGraphBLAS.Monoids.PLUS_MONOID","page":"Monoids","title":"SuiteSparseGraphBLAS.Monoids.PLUS_MONOID","text":"Plus monoid: f(x::T, y::T)::T = x + y\n\nIdentity: 0\nTerminal: nothing\n\n\n\n\n\n","category":"constant"},{"location":"monoids/#SuiteSparseGraphBLAS.Monoids.TIMES_MONOID","page":"Monoids","title":"SuiteSparseGraphBLAS.Monoids.TIMES_MONOID","text":"Times monoid: f(x::T, y::T)::T = xy\n\nIdentity: 1\nTerminal: 0 for non Floating-point numbers.\n\n\n\n\n\n","category":"constant"},{"location":"monoids/#SuiteSparseGraphBLAS.Monoids.ANY_MONOID","page":"Monoids","title":"SuiteSparseGraphBLAS.Monoids.ANY_MONOID","text":"Any monoid: f(x::T, y::T)::T = x or y\n\nIdentity: any\nTerminal: any\n\n\n\n\n\n","category":"constant"},{"location":"monoids/#SuiteSparseGraphBLAS.Monoids.BAND_MONOID","page":"Monoids","title":"SuiteSparseGraphBLAS.Monoids.BAND_MONOID","text":"Bitwise AND monoid: f(x::ℤ, y::ℤ)::ℤ = x&y\n\nIdentity: All bits 1.\nTerminal: All bits 0.\n\n\n\n\n\n","category":"constant"},{"location":"monoids/#SuiteSparseGraphBLAS.Monoids.BOR_MONOID","page":"Monoids","title":"SuiteSparseGraphBLAS.Monoids.BOR_MONOID","text":"Bitwise OR monoid: f(x::ℤ, y::ℤ)::ℤ = x|y\n\nIdentity: All bits 0.* Terminal: All bits 1.\n\n\n\n\n\n","category":"constant"},{"location":"monoids/#SuiteSparseGraphBLAS.Monoids.BXNOR_MONOID","page":"Monoids","title":"SuiteSparseGraphBLAS.Monoids.BXNOR_MONOID","text":"Bitwise XNOR monoid: f(x::ℤ, y::ℤ)::ℤ = ~(x^y)\n\nIdentity: All bits 1.\nTerminal: nothing\n\n\n\n\n\n","category":"constant"},{"location":"monoids/#SuiteSparseGraphBLAS.Monoids.BXOR_MONOID","page":"Monoids","title":"SuiteSparseGraphBLAS.Monoids.BXOR_MONOID","text":"Bitwise XOR monoid: f(x::ℤ, y::ℤ)::ℤ = x^y\n\nIdentity: All bits 0.\nTerminal: nothing\n\n\n\n\n\n","category":"constant"},{"location":"monoids/#SuiteSparseGraphBLAS.Monoids.EQ_MONOID","page":"Monoids","title":"SuiteSparseGraphBLAS.Monoids.EQ_MONOID","text":"Boolean Equality f(x::Bool, y::Bool)::Bool = x == y.\n\n\n\n\n\n","category":"constant"},{"location":"monoids/#SuiteSparseGraphBLAS.Monoids.LAND_MONOID","page":"Monoids","title":"SuiteSparseGraphBLAS.Monoids.LAND_MONOID","text":"Logical AND monoid: f(x::Bool, y::Bool)::Bool = x ∧ y\n\nIdentity: true\nTerminal: false\n\n\n\n\n\n","category":"constant"},{"location":"monoids/#SuiteSparseGraphBLAS.Monoids.LOR_MONOID","page":"Monoids","title":"SuiteSparseGraphBLAS.Monoids.LOR_MONOID","text":"Logical OR monoid: f(x::Bool, y::Bool)::Bool = x ∨ y\n\nIdentity: false\nTerminal: true\n\n\n\n\n\n","category":"constant"},{"location":"monoids/#SuiteSparseGraphBLAS.Monoids.LXNOR_MONOID","page":"Monoids","title":"SuiteSparseGraphBLAS.Monoids.LXNOR_MONOID","text":"Logical XNOR monoid: f(x::Bool, y::Bool)::Bool = x == y\n\nIdentity: true\nTerminal: nothing\n\n\n\n\n\n","category":"constant"},{"location":"monoids/#SuiteSparseGraphBLAS.Monoids.LXOR_MONOID","page":"Monoids","title":"SuiteSparseGraphBLAS.Monoids.LXOR_MONOID","text":"Logical XOR monoid: f(x::Bool, y::Bool)::Bool = x ⊻ y\n\nIdentity: false\nTerminal: nothing\n\n\n\n\n\n","category":"constant"},{"location":"unaryops/#Unary-Operators","page":"Unary Operators","title":"Unary Operators","text":"","category":"section"},{"location":"unaryops/","page":"Unary Operators","title":"Unary Operators","text":"UnaryOps are fairly straightforward z = f(x) and their meaning should be clear from the name in most cases. ","category":"page"},{"location":"unaryops/","page":"Unary Operators","title":"Unary Operators","text":"UnaryOps are used only in the map function, for example:","category":"page"},{"location":"unaryops/","page":"Unary Operators","title":"Unary Operators","text":"using SuiteSparseGraphBLAS\n\nx = GBVector([1.5, 0, pi])\n\ny = map(UnaryOps.SIN, x)\n\nmap(UnaryOps.ASIN, y)\n","category":"page"},{"location":"unaryops/#Built-Ins","page":"Unary Operators","title":"Built-Ins","text":"","category":"section"},{"location":"unaryops/","page":"Unary Operators","title":"Unary Operators","text":"using Pkg\nPkg.activate(\"..\")\ncd(\"..\")\nusing SuiteSparseGraphBLAS\nusing Latexify\nhead = [\"UnaryOp\", \"Function Form\", \"Types\"]\nv1 = filter((x) -> getproperty(UnaryOps, x) isa SuiteSparseGraphBLAS.AbstractUnaryOp, names(UnaryOps))\nops = getproperty.(Ref(UnaryOps), v1)\nv2 = convert(Vector{Any}, SuiteSparseGraphBLAS.juliaop.(ops))\nv4 = SuiteSparseGraphBLAS.validtypes.(ops)\n\nv1 = \"`\" .* string.(v1) .* \"`\"\nv2 = \"`\" .* string.(v2) .* \"`\"\nLatexify.mdtable(hcat(v1,v2,v4); head, latex=false)","category":"page"},{"location":"arrays/#Array-Types","page":"Arrays","title":"Array Types","text":"","category":"section"},{"location":"arrays/","page":"Arrays","title":"Arrays","text":"There are two primary datastructures in in SuiteSparseGraphBLAS.jl: the GBVector and GBMatrix.","category":"page"},{"location":"arrays/","page":"Arrays","title":"Arrays","text":"Both types currently implement most of the AbstractArray interface and part of the SparseArrays interface. ","category":"page"},{"location":"arrays/#Matrix-Construction","page":"Arrays","title":"Matrix Construction","text":"","category":"section"},{"location":"arrays/","page":"Arrays","title":"Arrays","text":"using SuiteSparseGraphBLAS\nusing SparseArrays","category":"page"},{"location":"arrays/","page":"Arrays","title":"Arrays","text":"x = GBMatrix{Bool}(20_000_000, 50_000)\nx = GBMatrix([[1,2] [3,4]])\nx = GBMatrix(sprand(100, 100, 0.5))\nx = GBMatrix(rand(1:50_000, 5000), rand(1:500_000, 5000), 1; ncols = 500_000, nrows = 500_000)","category":"page"},{"location":"arrays/","page":"Arrays","title":"Arrays","text":"GBMatrix\nSuiteSparseGraphBLAS.GBMatrix(::Matrix)\nSuiteSparseGraphBLAS.GBMatrix(::SparseMatrixCSC)","category":"page"},{"location":"arrays/#SuiteSparseGraphBLAS.GBMatrix","page":"Arrays","title":"SuiteSparseGraphBLAS.GBMatrix","text":"GBMatrix{T} <: AbstractSparseArray{T, UInt64, 2}\n\nTwo-dimensional GraphBLAS array with elements of type T. Internal representation is specified as opaque, but in this implementation is stored as one of the following in either row or column orientation:\n\n1. Dense\n2. Bitmap\n3. Sparse Compressed\n4. Hypersparse\n\nThe storage type is automatically determined by the library.\n\n\n\n\n\n","category":"type"},{"location":"arrays/#SuiteSparseGraphBLAS.GBMatrix-Tuple{Matrix}","page":"Arrays","title":"SuiteSparseGraphBLAS.GBMatrix","text":"GBMatrix{T}(nrows = libgb.GxB_INDEX_MAX, ncols = libgb.GxB_INDEX_MAX)\n\nCreate a GBMatrix of the specified size, defaulting to the maximum on each dimension, 2^60.\n\n\n\n\n\nGBMatrix(I, J, X; dup = +, nrows = maximum(I), ncols = maximum(J))\n\nCreate an nrows x ncols GBMatrix M such that M[I[k], J[k]] = X[k]. The dup function defaults to | for booleans and + for nonbooleans.\n\n\n\n\n\nGBMatrix(I, J, x; nrows = maximum(I), ncols = maximum(J))\n\nCreate an nrows x ncols GBMatrix M such that M[I[k], J[k]] = x. The resulting matrix is \"iso-valued\" such that it only stores x once rather than once for each index.\n\n\n\n\n\nGBMatrix(M::Matrix)\n\nCreate a GBMatrix from a Julia dense matrix.\n\n\n\n\n\n","category":"method"},{"location":"arrays/#SuiteSparseGraphBLAS.GBMatrix-Tuple{SparseMatrixCSC}","page":"Arrays","title":"SuiteSparseGraphBLAS.GBMatrix","text":"GBMatrix(S::SparseMatrixCSC)\n\nCreate a GBMatrix from a SparseArrays.SparseMatrixCSC S.\n\nNote, that unlike other methods of construction, the resulting matrix will be held by column. Use gbset(A, :format, :byrow) to switch to row orientation.\n\n\n\n\n\n","category":"method"},{"location":"arrays/","page":"Arrays","title":"Arrays","text":"Conversion back to matrices, sparse or dense, is also supported.","category":"page"},{"location":"arrays/#Vector-Construction","page":"Arrays","title":"Vector Construction","text":"","category":"section"},{"location":"arrays/","page":"Arrays","title":"Arrays","text":"v = GBVector{ComplexF32}(100)\nv = GBMatrix(rand(ComplexF64, 3))\nv = GBVector(sprand(Bool, 100_000_000, 0.001))","category":"page"},{"location":"arrays/","page":"Arrays","title":"Arrays","text":"GBVector\nSuiteSparseGraphBLAS.GBVector(::Vector)\nSuiteSparseGraphBLAS.GBVector(::AbstractVector{<:Integer}, ::AbstractVector)","category":"page"},{"location":"arrays/#SuiteSparseGraphBLAS.GBVector","page":"Arrays","title":"SuiteSparseGraphBLAS.GBVector","text":"GBVector{T} <: AbstractSparseArray{T, UInt64, 1}\n\nOne-dimensional GraphBLAS array with elements of type T. Internal representation is specified as opaque, but may be either a dense array, bitmap array, or compressed sparse vector.\n\nSee also: GBMatrix.\n\n\n\n\n\n","category":"type"},{"location":"arrays/#SuiteSparseGraphBLAS.GBVector-Tuple{Vector}","page":"Arrays","title":"SuiteSparseGraphBLAS.GBVector","text":"GBVector{T}(n = libgb.GxB_INDEX_MAX)\n\n\n\n\n\nGBVector(I::AbstractVector, X::AbstractVector{T})\n\nCreate a GBVector from a vector of indices I and a vector of values X.\n\n\n\n\n\nGBVector(I, x; nrows = maximum(I))\n\nCreate an n length GBVector v such that M[I[k]] = x. The resulting vector is \"iso-valued\" such that it only stores x once rather than once for each index.\n\n\n\n\n\nGBVector(n, x)\n\nCreate an n length dense GBVector v such that M[I[k]] = x. The resulting vector is \"iso-valued\" such that it only stores x once rather than once for each index.\n\n\n\n\n\nGBVector(v::SparseVector)\n\nCreate a GBVector from a Julia dense vector.\n\n\n\n\n\n","category":"method"},{"location":"arrays/#SuiteSparseGraphBLAS.GBVector-Tuple{AbstractVector{<:Integer}, AbstractVector}","page":"Arrays","title":"SuiteSparseGraphBLAS.GBVector","text":"GBVector(I::AbstractVector, X::AbstractVector{T})\n\nCreate a GBVector from a vector of indices I and a vector of values X.\n\n\n\n\n\nGBVector(I, x; nrows = maximum(I))\n\nCreate an n length GBVector v such that M[I[k]] = x. The resulting vector is \"iso-valued\" such that it only stores x once rather than once for each index.\n\n\n\n\n\n","category":"method"},{"location":"arrays/#Indexing","page":"Arrays","title":"Indexing","text":"","category":"section"},{"location":"arrays/","page":"Arrays","title":"Arrays","text":"The usual AbstractArray and SparseArray indexing capabilities are available. Including indexing by scalars, vectors, and ranges.","category":"page"},{"location":"arrays/","page":"Arrays","title":"Arrays","text":"danger: Indexing Structural Zeros\nWhen indexing a SparseMatrixCSC from SparseArrays a structural, or implicit, zero will be returned as zero(T) where T is the element type of the matrix.When indexing a GBArray structural zeros are instead returned as nothing.  While this is a significant departure from the SparseMatrixCSC it more closely matches the GraphBLAS spec, and enables the consuming method to determine the value of implicit zeros. For instance with an element type of Float64 you may want the zero to be 0.0, -∞ or +∞ depending on your algorithm. In addition, for graph algorithms there may be a distinction between an implicit zero, indicating the lack of an edge between two vertices in an adjacency matrix, and an explicit zero where the edge exists but has a 0 weight.Better compatibility with SparseMatrixCSC and the ability to specify the value of implicit zeros is provided by SuiteSparseGraphBLAS.SparseArrayCompat.SparseMatrixGB array type.","category":"page"},{"location":"arrays/","page":"Arrays","title":"Arrays","text":"A = GBMatrix([1,1,2,2,3,4,4,5,6,7,7,7], [2,4,5,7,6,1,3,6,3,3,4,5], [1:12...])\nSparseMatrixCSC(A)\nA[4]\nA[1,2]\nA[[1,3,5,7], :]\nA[1:2:7, :]\nA[:,:]\nA[:, 5]\nSparseMatrixCSC(A'[:,:]) #Transpose the first argument","category":"page"},{"location":"arrays/","page":"Arrays","title":"Arrays","text":"The functionality illustrated above extends to GBVector as well.","category":"page"},{"location":"arrays/#Transpose","page":"Arrays","title":"Transpose","text":"","category":"section"},{"location":"arrays/","page":"Arrays","title":"Arrays","text":"The lazy Julia transpose is available, and the adjoint operator ' is also overloaded to be equivalent.","category":"page"},{"location":"arrays/","page":"Arrays","title":"Arrays","text":"danger: Adjoint vs Transpose\nThe adjoint operator ' currently transposes matrices rather than performing the conjugate transposition. In the future this will change to the complex conjugate for complex types, but currently you must do map(conj, A') to achieve this.","category":"page"},{"location":"arrays/#Utilities","page":"Arrays","title":"Utilities","text":"","category":"section"},{"location":"arrays/","page":"Arrays","title":"Arrays","text":"clear!","category":"page"},{"location":"arrays/#SuiteSparseGraphBLAS.clear!","page":"Arrays","title":"SuiteSparseGraphBLAS.clear!","text":"clear!(v::GBVector)\nclear!(A::GBMatrix)\n\nClear all the entries from the GBArray. Does not modify the type or dimensions.\n\n\n\n\n\n","category":"function"},{"location":"operations/#Operations","page":"Operations","title":"Operations","text":"","category":"section"},{"location":"operations/","page":"Operations","title":"Operations","text":"GraphBLAS operations cover most of the typical linear algebra operations on arrays in Julia.","category":"page"},{"location":"operations/#Correspondence-of-GraphBLAS-C-functions-and-Julia-functions","page":"Operations","title":"Correspondence of GraphBLAS C functions and Julia functions","text":"","category":"section"},{"location":"operations/","page":"Operations","title":"Operations","text":"GraphBLAS Operation Julia\nmxm, mxv, vxm bf C langle M rangle = C odot AB mul[!]\neWiseMult bf C langle M rangle = C odot (A otimes B) emul[!]\neWiseAdd bf C langle M rangle = C odot (A oplus  B) eadd[!]\nextract bf C langle M rangle = C odot A(IJ) extract[!], getindex\nsubassign bf C (IJ) langle M rangle = C(IJ) odot A subassign[!], setindex!\nassign bf C langle M rangle (IJ) = C(IJ) odot A assign[!]\napply bf C langle M rangle = C odot fbf (A) map[!]\n bf C langle M rangle = C odot f(bf Ay) \n bf C langle M rangle = C odot f(xbf A) \nselect bf C langle M rangle = C odot f(bf Ak) select[!]\nreduce bf w langle m rangle = w odot oplus_j bf A(j) reduce[!]\n s = s odot oplus_ij  bf A(ij) \ntranspose bf C langle M rangle = C odot A^sf T gbtranspose[!], lazy: transpose, '\nkronecker bf C langle M rangle = C odot textkron(A B) kron[!]","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"where bf M is a GBArray mask, odot is a binary operator for accumulating into bf C, and otimes and oplus are a binary operation and commutative monoid respectively. ","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"note: assign vs subassign\nsubassign is equivalent to assign except that the mask in subassign has the dimensions of bf C(IJ) vs the dimensions of C for assign, and elements outside of the mask will never be modified by subassign. See the GraphBLAS User Guide for more details.","category":"page"},{"location":"operations/#Operation-Documentation","page":"Operations","title":"Operation Documentation","text":"","category":"section"},{"location":"operations/","page":"Operations","title":"Operations","text":"All non-mutating operations below support a mutating form by adding an output array as the first argument as well as the ! function suffix. ","category":"page"},{"location":"operations/#mul","page":"Operations","title":"mul","text":"","category":"section"},{"location":"operations/","page":"Operations","title":"Operations","text":"mul\nemul\nemul!\neadd\neadd!\nextract\nsubassign!\nassign!\nBase.map\nselect\nBase.reduce\ngbtranspose\nLinearAlgebra.kron","category":"page"},{"location":"operations/#SuiteSparseGraphBLAS.mul","page":"Operations","title":"SuiteSparseGraphBLAS.mul","text":"mul(A::GBArray, B::GBArray, op=(+,*); kwargs...)::GBArray\n\nMultiply two GBArrays A and B using a semiring, which defaults to the arithmetic semiring +.*.\n\nEither operand may be transposed using ' or transpose(A) provided the dimensions match.\n\nThe mutating form, mul!(C, A, B, op; kwargs...) is identical except it stores the result in C::GBVecOrMat.\n\nThe operator syntax A * B can be used when the default semiring is desired, and *(max, +)(A, B) can be used otherwise.\n\nArguments\n\nA, B::GBArray: A GBVector or GBMatrix, possibly transposed.\nop::Union{Tuple{Function, Function}, AbstractSemiring}: the semiring used for matrix multiplication. May be passed as a tuple of functions, or an AbstractSemiring found in the Semirings submodule.\n\nKeywords\n\nmask::Union{Nothing, GBArray} = nothing: optional mask which determines the output pattern.\naccum::Union{Nothing, Function, AbstractBinaryOp} = nothing: optional binary accumulator   operation such that C[i,j] = accum(C[i,j], T[i,j]) where T is the result of this function before accum is applied.\ndesc::Union{Nothing, Descriptor}\n\nReturns\n\nGBArray: The output matrix whose eltype is determined by A and B or the semiring   if a type specific semiring is provided.\n\n\n\n\n\n","category":"function"},{"location":"operations/#SuiteSparseGraphBLAS.emul","page":"Operations","title":"SuiteSparseGraphBLAS.emul","text":"emul(A::GBArray, B::GBArray, op = *; kwargs...)::GBMatrix\n\nApply the binary operator op elementwise on the set intersection of A and B. When op = * this is equivalent to A .* B, however any binary operator may be substituted.\n\nThe pattern of the result is the set intersection of A and B. For a set union equivalent see eadd.\n\nArguments\n\nA, B::GBArray: A GBVector or GBMatrix, possibly transposed.\nop::Union{Function, AbstractBinaryOp, Monoid} = *: the binary operation which is   applied such that C[i,j] = op(A[i,j], B[i,j]) for all i,j present in both A and B.\n\nKeywords\n\nmask::Union{Nothing, GBVecOrMat} = nothing: optional mask.\naccum::Union{Nothing, AbstractBinaryOp} = nothing: binary accumulator operation   where C[i,j] = accum(C[i,j], T[i,j]) where T is the result of this function before accum is applied.\ndesc = nothing\n\nReturns\n\nGBVecOrMat: Output GBVector or GBMatrix whose eltype is determined by the eltype of   A and B or the binary operation if a type specific operation is provided.\n\n\n\n\n\n","category":"function"},{"location":"operations/#SuiteSparseGraphBLAS.emul!","page":"Operations","title":"SuiteSparseGraphBLAS.emul!","text":"emul!(C::GBArray, A::GBArray, B::GBArray, op = *; kwargs...)::GBArray\n\nApply the binary operator op elementwise on the set intersection of A and B. Store or accumulate the result into C. When op = * this is equivalent to A .* B, however any binary operator may be substituted.\n\nThe pattern of the result is the set intersection of A and B. For a set union equivalent see eadd!.\n\nArguments\n\nC::GBArray: the output vector or matrix.\nA, B::GBArray: A GBVector or GBMatrix, possibly transposed.\nop::Union{Function, AbstractBinaryOp, Monoid} = *: the binary operation which is   applied such that C[i,j] = op(A[i,j], B[i,j]) for all i,j present in both A and B.\n\nKeywords\n\nmask::Union{Nothing, GBVecOrMat} = nothing: optional mask.\naccum::Union{Nothing, Function, AbstractBinaryOp} = nothing: binary accumulator operation   such that C[i,j] = accum(C[i,j], T[i,j]) where T is the result of this function before   accum is applied.\ndesc::Union{Nothing, Descriptor} = nothing\n\n\n\n\n\n","category":"function"},{"location":"operations/#SuiteSparseGraphBLAS.eadd","page":"Operations","title":"SuiteSparseGraphBLAS.eadd","text":"eadd(A::GBArray, B::GBArray, op = +; kwargs...)::GBVecOrMat\n\nApply the binary operator op elementwise on the set union of A and B. When op = + this is equivalent to A .+ B, however any binary operation may be substituted.\n\nNote that the behavior of A[i,j] op B[i,j] may be unintuitive when one operand is an implicit zero. The explicit operand passes through the function. So A[i,j] op B[i,j] where B[i,j] is an implicit zero returns A[i,j] not A[i,j] op zero(T).\n\nFor a set intersection equivalent see emul.\n\nArguments\n\nA, B::GBArray: A GBVector or GBMatrix, possibly transposed.\nop::Union{Function, AbstractBinaryOp, Monoid} = +: the binary operation which is   applied such that C[i,j] = op(A[i,j], B[i,j]) for all i,j present in either A and B.\n\nKeywords\n\nmask::Union{Nothing, GBVecOrMat} = nothing: optional mask.\naccum::Union{Nothing, Function, AbstractBinaryOp} = nothing: binary accumulator operation   such that C[i,j] = accum(C[i,j], T[i,j]) where T is the result of this function before accum is applied.\ndesc::Union{Nothing, Descriptor} = nothing\n\n\n\n\n\n","category":"function"},{"location":"operations/#SuiteSparseGraphBLAS.eadd!","page":"Operations","title":"SuiteSparseGraphBLAS.eadd!","text":"eadd!(C::GBVecOrMat, A::GBArray, B::GBArray, op = +; kwargs...)::GBVecOrMat\n\nApply the binary operator op elementwise on the set union of A and B. Store or accumulate the result into C. When op = + this is equivalent to A .+ B, however any binary operation may be substituted.\n\nNote that the behavior of A[i,j] op B[i,j] may be unintuitive when one operand is an implicit zero. The explicit operand passes through the function. So A[i,j] op B[i,j] where B[i,j] is an implicit zero returns A[i,j] not A[i,j] op zero(T).\n\nFor a set intersection equivalent see emul!.\n\nArguments\n\nC::GBArray: the output vector or matrix.\nA, B::GBArray: A GBVector or GBMatrix, possibly transposed.\nop::Union{Function, AbstractBinaryOp, Monoid} = +: the binary operation which is   applied such that C[i,j] = op(A[i,j], B[i,j]) for all i,j present in either A and B.\n\nKeywords\n\nmask::Union{Nothing, GBVecOrMat} = nothing: optional mask.\naccum::Union{Nothing, Function, AbstractBinaryOp} = nothing: binary accumulator operation   such that C[i,j] = accum(C[i,j], T[i,j]) where T is the result of this function before accum is applied.\ndesc::Union{Nothing, Descriptor} = nothing\n\n\n\n\n\n","category":"function"},{"location":"operations/#SuiteSparseGraphBLAS.extract","page":"Operations","title":"SuiteSparseGraphBLAS.extract","text":"extract(A::GBMatOrTranspose, I, J; kwargs...)::GBMatrix\nextract(A::GBVector, I; kwargs...)::GBVector\n\nExtract a submatrix or subvector from A\n\nArguments\n\nA::GBArray: the array being indexed.\nI and J: A colon, scalar, vector, or range indexing A.\n\nKeywords\n\nmask::Union{Nothing, GBArray} = nothing: mask where   size(M) == (max(I), max(J)).\naccum::Union{Nothing, AbstractBinaryOp} = nothing: binary accumulator operation   where C[i,j] = accum(C[i,j], T[i,j]) where T is the result of this function before accum is applied.\ndesc::Descriptor = nothing\n\nReturns\n\nGBMatrix: the submatrix A[I, J].\n\nThrows\n\nGrB_DIMENSION_MISMATCH: If (max(I), max(J)) != size(mask).\n\n\n\n\n\n","category":"function"},{"location":"operations/#SuiteSparseGraphBLAS.subassign!","page":"Operations","title":"SuiteSparseGraphBLAS.subassign!","text":"subassign(w::GBVector, u::GBVector, I; kwargs...)::GBVector\n\nAssign a subvector of w to u. Return u. Equivalent to the matrix definition.\n\n\n\n\n\nsubassign!(C::GBMatrix, A::GBMatrix, I, J; kwargs...)::GBMatrix\n\nAssign a submatrix of A to C. Equivalent to assign! except that size(mask) == size(A), whereas size(mask) == size(C) in assign!.\n\nArguments\n\nC::GBMatrix: the matrix being subassigned to where C[I,J] = A.\nA::GBMatrix: the matrix being assigned to a submatrix of C.\nI and J: A colon, scalar, vector, or range indexing C.\n\nKeywords\n\nmask::Union{Nothing, GBMatrix} = nothing: mask where   size(M) == size(A).\naccum::Union{Nothing, Function, AbstractBinaryOp} = nothing: binary accumulator operation   where C[i,j] = accum(C[i,j], T[i,j]) where T is the result of this function before accum is applied.\ndesc::Union{Nothing, Descriptor} = nothing\n\nReturns\n\nGBMatrix: The input matrix A.\n\nThrows\n\nGrB_DIMENSION_MISMATCH: If size(A) != (max(I), max(J)) or size(A) != size(mask).\n\n\n\n\n\n","category":"function"},{"location":"operations/#SuiteSparseGraphBLAS.assign!","page":"Operations","title":"SuiteSparseGraphBLAS.assign!","text":"assign(w::GBVector, u::GBVector, I; kwargs...)::GBVector\n\nAssign a subvector of w to u. Return u. Equivalent to the matrix definition.\n\n\n\n\n\nassign!(C::GBMatrix, A::GBMatrix, I, J; kwargs...)::GBMatrix\n\nAssign a submatrix of A to C. Equivalent to subassign! except that size(mask) == size(C), whereas size(mask) == size(A) insubassign!`.\n\nArguments\n\nC::GBMatrix: the matrix being subassigned to where C[I,J] = A.\nA::GBMatrix: the matrix being assigned to a submatrix of C.\nI and J: A colon, scalar, vector, or range indexing C.\n\nKeywords\n\nmask::Union{Nothing, GBMatrix} = nothing: mask where   size(M) == size(C).\naccum::Union{Nothing, Function, AbstractBinaryOp} = nothing: binary accumulator operation   where C[i,j] = accum(C[i,j], T[i,j]) where T is the result of this function before accum is applied.\ndesc::Union{Nothing, Descriptor} = nothing\n\nReturns\n\nGBMatrix: The input matrix A.\n\nThrows\n\nGrB_DIMENSION_MISMATCH: If size(A) != (max(I), max(J)) or size(C) != size(mask).\n\n\n\n\n\n","category":"function"},{"location":"operations/#Base.map","page":"Operations","title":"Base.map","text":"map(op::Union{Function, AbstractUnaryOp}, A::GBArray; kwargs...)::GBArray\nmap(op::Union{Function, AbstractBinaryOp}, A::GBArray, x; kwargs...)::GBArray\nmap(op::Union{Function, AbstractBinaryOp}, x, A::GBArray, kwargs...)::GBArray\n\nTransform a GBArray by applying op to each element.\n\nUnaryOps and single argument functions apply elementwise in the usual fashion. BinaryOps and two argument functions require the additional argument x which is      substituted as the first or second operand of op depending on its position.\n\nArguments\n\nop::Union{Function, AbstractUnaryOp, AbstractBinaryOp}\nA::GBArray\nx: Position dependent argument to binary operators.\n\nKeywords\n\nmask::Union{Nothing, GBVecOrMat} = nothing: optional mask.\naccum::Union{Nothing, AbstractBinaryOp} = nothing: binary accumulator operation   where C[i,j] = accum(C[i,j], T[i,j]) where T is the result of this function before accum is applied.\ndesc::Union{Nothing, Descriptor} = nothing\n\n\n\n\n\n","category":"function"},{"location":"operations/#SuiteSparseGraphBLAS.select","page":"Operations","title":"SuiteSparseGraphBLAS.select","text":"select(op::Union{Function, SelectUnion}, A::GBArray; kwargs...)::GBArray\nselect(op::Union{Function, SelectUnion}, A::GBArray, thunk; kwargs...)::GBArray\n\nReturn a GBArray whose elements satisfy the predicate defined by op. Some SelectOps or functions may require an additional argument thunk, for use in     comparison operations such as C[i,j] = A[i,j] >= thunk ? A[i,j] : nothing, which is     performed by select(>, A, thunk).\n\nArguments\n\nop::Union{Function, SelectUnion}: A select operator from the SelectOps submodule.\nA::GBArray\nthunk::Union{GBScalar, nothing, valid_union}: Optional value used to evaluate op.\n\nKeywords\n\nmask::Union{Nothing, GBMatrix} = nothing: optional mask which determines the output   pattern.\naccum::Union{Nothing, AbstractBinaryOp} = nothing: optional binary accumulator   operation where C[i,j] = accum(C[i,j], T[i,j]) where T is the result of this function before accum is applied.\ndesc = nothing\n\nReturns\n\nGBArray: The output matrix whose eltype is determined by A and op.\n\n\n\n\n\n","category":"function"},{"location":"operations/#Base.reduce","page":"Operations","title":"Base.reduce","text":"reduce(op::Monoid, A::GBMatrix, dims=:; kwargs...)\nreduce(op::Monoid, v::GBVector; kwargs...)\n\nReduce A along dimensions of A with monoid op.\n\nArguments\n\nop::MonoidUnion: the monoid reducer. This may not be a BinaryOp.\nA::GBArray: GBVector or optionally transposed GBMatrix.\ndims = :: Optional dimensions for GBMatrix, may be 1, 2, or :.\n\nKeywords\n\ntypeout: Optional output type specification. Defaults to eltype(A).\ninit: Optional initial value.\nmask::Union{Nothing, GBMatrix} = nothing: optional mask.\naccum::Union{Nothing, AbstractBinaryOp} = nothing: binary accumulator operation   where C[i,j] = accum(C[i,j], T[i,j]) where T is the result of this function before accum is applied.\ndesc = nothing\n\n\n\n\n\n","category":"function"},{"location":"operations/#SuiteSparseGraphBLAS.gbtranspose","page":"Operations","title":"SuiteSparseGraphBLAS.gbtranspose","text":"gbtranspose(A::GBMatrix; kwargs...)::GBMatrix\n\nEagerly evaluated matrix transpose which returns the transposed matrix.\n\nKeywords\n\nmask::Union{Nothing, GBMatrix} = nothing: optional mask.\naccum::Union{Nothing, AbstractBinaryOp} = nothing: binary accumulator operation   where C[i,j] = accum(C[i,j], T[i,j]) where T is the result of this function before accum is applied.\ndesc::Union{Nothing, Descriptor} = nothing\n\nReturns\n\nC::GBMatrix: output matrix.\n\n\n\n\n\n","category":"function"},{"location":"operations/#Base.kron","page":"Operations","title":"Base.kron","text":"kron(A::GBMatrix, B::GBMatrix, op = BinaryOps.TIMES; kwargs...)::GBMatrix\n\nKronecker product of two matrices using op as the multiplication operator. Does not support GBVectors at this time.\n\nArguments\n\nA::GBMatrix: optionally transposed.\nB::GBMatrix: optionally transposed.\nop::MonoidBinaryOrRig = BinaryOps.TIMES: the binary operation which replaces the arithmetic   multiplication operation from the usual kron function.\n\nKeywords\n\nmask::Union{Nothing, GBMatrix} = nothing: optional mask.\naccum::Union{Nothing, AbstractBinaryOp} = nothing: binary accumulator operation   where C[i,j] = accum(C[i,j], T[i,j]) where T is the result of this function before accum is applied.\ndesc = nothing\n\n\n\n\n\n","category":"function"},{"location":"operations/#Common-arguments","page":"Operations","title":"Common arguments","text":"","category":"section"},{"location":"operations/","page":"Operations","title":"Operations","text":"The operations typically accept one of the following types in the op argument.","category":"page"},{"location":"operations/#op-UnaryOp,-BinaryOp,-Monoid,-Semiring,-or-SelectOp:","page":"Operations","title":"op - UnaryOp, BinaryOp, Monoid, Semiring, or SelectOp:","text":"","category":"section"},{"location":"operations/","page":"Operations","title":"Operations","text":"This argument determines oplus, otimes, or f in the table above as well as the semiring used in mul. They typically have synonymous functions in Julia, so conj can be used in place of UnaryOps.CONJ for instance.","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"tip: Built-Ins\nThe built-in operators can be found in the submodules: UnaryOps, BinaryOps, Monoids, and Semirings.","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"See the Operators section for more information.","category":"page"},{"location":"operations/#desc-Descriptor:","page":"Operations","title":"desc - Descriptor:","text":"","category":"section"},{"location":"operations/","page":"Operations","title":"Operations","text":"The descriptor argument allows the user to modify the operation in some fashion. The most common options are:","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"desc.[transpose_input1 | transpose_input2] == [true | false] \nTypically you should use Julia's built-in transpose functionality.\ndesc.complement_mask == [true | false] \nIf complement_mask is set the presence/truth value of the mask is complemented.\ndesc.structural_mask == [true | false]\nIf structural_mask is set the presence of a value in the mask determines the presence of values   in the output, rather than the actual value of the mask.\ndesc.replace_output == [true | false]\nIf this option is set the operation will replace all values in the output matrix after the accumulation step.    If an index is found in the output matrix, but not in the results of the operation it will be set to nothing. ","category":"page"},{"location":"operations/#accum-BinaryOp-Function:","page":"Operations","title":"accum - BinaryOp | Function:","text":"","category":"section"},{"location":"operations/","page":"Operations","title":"Operations","text":"The accum keyword argument provides a binary operation to accumulate results into the result array.  The accumulation step is performed before masking.","category":"page"},{"location":"operations/#mask-GBArray:","page":"Operations","title":"mask - GBArray:","text":"","category":"section"},{"location":"operations/","page":"Operations","title":"Operations","text":"The mask keyword argument determines whether each index from the result of an operation appears in the output.  The mask may be structural, where the presence of a value indicates the mask is true, or valued where the value of the mask indicates its truth value.  The mask may also be complemented. These options are controlled by the desc argument.","category":"page"},{"location":"operations/#Order-of-Operations","page":"Operations","title":"Order of Operations","text":"","category":"section"},{"location":"operations/","page":"Operations","title":"Operations","text":"A GraphBLAS operation semantically occurs in the following order:","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"Calculate T = <operation>(args...)\nElementwise accumulate Z[i,j] = accum(C[i,j], T[i,j])\nOptionally masked assignment C[i,j] = mask[i,j] ? Z[i,j] : [nothing | C[i,j]]","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"If replace_output is set the option in step 3. is nothing, otherwise it is C[i,j].","category":"page"},{"location":"operators/#Basics","page":"Basics","title":"Basics","text":"","category":"section"},{"location":"operators/","page":"Basics","title":"Basics","text":"There are five operator types in SuiteSparseGraphBLAS. Four are defined for all GraphBLAS implementations: UnaryOp, BinaryOp, Monoid, and Semiring.  One is an extension to the v1.3 specification: SelectOp.","category":"page"},{"location":"operators/","page":"Basics","title":"Basics","text":"danger: Note\nOperators are not callable objects like functions. They do behave like functions as arguments to higher-order functions (operations in the language of GraphBLAS). However BinaryOp and UnaryOp operators typically have a synonymous julia function, which can be found using juliaop(op).","category":"page"},{"location":"operators/","page":"Basics","title":"Basics","text":"Typically operators are positional arguments in one of two places. For operations with a clear default operator they appear as the last positional argument:","category":"page"},{"location":"operators/","page":"Basics","title":"Basics","text":"emul(A, B, op::Union{BinaryOp, Function})\neadd(A, B, op::Union{BinaryOp, Function})\nkron(A, B, op::Union{BinaryOp, Function})\nmul(A, B, op::Union{Semiring, Tuple{Function, Function}})","category":"page"},{"location":"operators/","page":"Basics","title":"Basics","text":"For other operations without a clear default operator they appear as the first argument:","category":"page"},{"location":"operators/","page":"Basics","title":"Basics","text":"map(op::Union{UnaryOp, Function}, A)\nreduce(op::Union{BinaryOp, Function}, A)\nselect(op::Union{SelectOp, Function}, A)","category":"page"},{"location":"operators/#UnaryOps,-BinaryOps,-Monoids,-and-Semirings","page":"Basics","title":"UnaryOps, BinaryOps, Monoids, and Semirings","text":"","category":"section"},{"location":"operators/","page":"Basics","title":"Basics","text":"Each operator is defined on a specific domain. For some this is the usual primitive datatypes like booleans, floats, and signed and unsigned integers of the typical sizes.","category":"page"},{"location":"operators/","page":"Basics","title":"Basics","text":"Each operator is represented as its own concrete type for dispatch purposes.  For instance BinaryOps.PLUS <: AbstractBinaryOp <: AbstractOp. Operators are effectively dictionaries containing the type-specific operators indexed by the DataType of their arguments. ","category":"page"},{"location":"operators/#Supported-Types","page":"Basics","title":"Supported Types","text":"","category":"section"},{"location":"operators/","page":"Basics","title":"Basics","text":"SuiteSparseGraphBLAS.jl natively supports the following types:","category":"page"},{"location":"operators/","page":"Basics","title":"Basics","text":"Booleans\nIntegers with sizes 8, 16, 32, 64\nUnsigned Integers with sizes 8, 16, 32, 64\nFloat32 and Float64\nComplexF32 and ComplexF64","category":"page"},{"location":"operators/","page":"Basics","title":"Basics","text":"The supported types can be found as in the example below:","category":"page"},{"location":"operators/","page":"Basics","title":"Basics","text":"using SuiteSparseGraphBLAS","category":"page"},{"location":"operators/","page":"Basics","title":"Basics","text":"Semiring(max, +)\nSemirings.MAX_PLUS\nSemirings.MAX_PLUS[Float64]","category":"page"},{"location":"operators/","page":"Basics","title":"Basics","text":"All operations will accept the function/tuple form, the DataType form, or the TypedSemiring form. Unless you need to specifically cast the arguments to a specific type there is no need to specify the operator type.","category":"page"},{"location":"operators/","page":"Basics","title":"Basics","text":"You can determine the available types for an operator and the input and output types of a type-specific operator with the functions below:","category":"page"},{"location":"operators/","page":"Basics","title":"Basics","text":"xtype\nytype\nztype","category":"page"},{"location":"operators/#SuiteSparseGraphBLAS.xtype","page":"Basics","title":"SuiteSparseGraphBLAS.xtype","text":"xtype(op::GrBOp)::DataType\n\nDetermine type of the first argument to a typed operator.\n\n\n\n\n\n","category":"function"},{"location":"operators/#SuiteSparseGraphBLAS.ytype","page":"Basics","title":"SuiteSparseGraphBLAS.ytype","text":"ytype(op::GrBOp)::DataType\n\nDetermine type of the second argument to a typed operator.\n\n\n\n\n\n","category":"function"},{"location":"operators/#SuiteSparseGraphBLAS.ztype","page":"Basics","title":"SuiteSparseGraphBLAS.ztype","text":"ytype(op::GrBOp)::DataType\n\nDetermine type of the output of a typed operator.\n\n\n\n\n\n","category":"function"},{"location":"operators/","page":"Basics","title":"Basics","text":"validtypes","category":"page"},{"location":"operators/#SuiteSparseGraphBLAS.validtypes","page":"Basics","title":"SuiteSparseGraphBLAS.validtypes","text":"validtypes(operator::AbstractOp)::Vector{DataType}\nvalidtypes(operator::SelectOp)::Nothing\n\nDetermine the types available as a domain for a particular operator. Each operator is defined on a specific set of types, for instance the Semirings.LAND_LOR     semiring is only defined for Boolean arguments.\n\nWhen applied to an AbstractSelectOp this will return nothing. When applied to certain operators like positional semirings it will return [Any].\n\n\n\n\n\n","category":"function"},{"location":"operators/","page":"Basics","title":"Basics","text":"Some examples of these functions are below.  Note the difference between ISGT which returns a result with the same type as the input, and GT which returns a Boolean.","category":"page"},{"location":"operators/","page":"Basics","title":"Basics","text":"xtype(Semirings.LOR_GT[Float64])\nztype(Semirings.LOR_GT[Float64])\nxtype(BinaryOps.ISGT[Int8])\nztype(BinaryOps.ISGT[Int8])\nztype(BinaryOps.GT[Int8])","category":"page"},{"location":"operators/#SelectOps","page":"Basics","title":"SelectOps","text":"","category":"section"},{"location":"operators/","page":"Basics","title":"Basics","text":"The SelectOp is a SuiteSparse extension to the specification, although a similar construct is likely to be found in a future specification. Unlike the other operators there are no type-specific operators, and as such you cannot index into them with types to obtain a type-specific version.","category":"page"},{"location":"#SuiteSparseGraphBLAS.jl","page":"Introduction","title":"SuiteSparseGraphBLAS.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"SuiteSparseGraphBLAS.jl is a package for sparse linear algebra on arbitrary semirings, with a particular focus on graph computations. It aims to provide a Julian wrapper over Tim Davis' SuiteSparse reference implementation of the GraphBLAS C specification.","category":"page"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Install using the Julia package manager in the REPL:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"] add SuiteSparseGraphBLAS","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"or with Pkg","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using Pkg\nPkg.add(\"SuiteSparseGraphBLAS\")","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The SuiteSparse:GraphBLAS binary is installed automatically as SSGraphBLAS_jll.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Then in the REPL or script using SuiteSparseGraphBLAS will import the package.","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"GraphBLAS harnesses the well-understood duality between graphs and matrices. Specifically a graph can be represented by its adjacency matrix, incidence matrix, or one of the many variations on those formats.  With this matrix representation in hand we have a method to operate on the graph using linear algebra operations on the matrix.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Below is an example of the adjacency matrix of a directed graph, and finding the neighbors of a single vertex using basic matrix-vector multiplication on the arithemtic semiring.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"(Image: BFS and Adjacency Matrix)","category":"page"},{"location":"#GraphBLAS-Concepts","page":"Introduction","title":"GraphBLAS Concepts","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The three primary components of GraphBLAS are: matrices, operators, and operations. Operators include monoids, binary operators, and semirings. Operations include the typical linear algebraic operations like matrix multiplication as well as indexing operations.","category":"page"},{"location":"#GBArrays","page":"Introduction","title":"GBArrays","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"SuiteSparseGraphBLAS.jl provides GBVector and GBMatrix array types which are subtypes of SparseArrays.AbstractSparseVector and SparseArrays.AbstractSparseMatrix respectively.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using SuiteSparseGraphBLAS\nusing SparseArrays","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"GBVector{Float64}(13)\n\nGBMatrix{ComplexF64}(1000, 1000)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"GraphBLAS array types are opaque to the user in order to allow the library author to choose the best storage format. SuiteSparse:GraphBLAS takes advantage of this by storing matrices in one of four formats: dense, bitmap, sparse-compressed, or hypersparse-compressed; and in either row or column major orientation.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"warning: Default Orientation\nThe default orientation of a GBMatrix is by-row, the opposite of Julia arrays, for greater speed in certain operations. However, a GBMatrix constructed from a SparseMatrixCSC or  Matrix will be stored by-column. The orientation of a GBMatrix can be modified using gbset(A, :format, :byrow) or gbset(A, :format, :bycol).","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The matrix and vector in the graphic above can be constructed as follows:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"A = GBMatrix([1,1,2,2,3,4,4,5,6,7,7,7], [2,4,5,7,6,1,3,6,3,3,4,5], [1:12...])\n\nv = GBVector([4], [10])","category":"page"},{"location":"#GraphBLAS-Operations","page":"Introduction","title":"GraphBLAS Operations","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The complete documentation of supported operations can be found in Operations. GraphBLAS operations are, where possible, methods of existing Julia functions  listed in the third column.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"GraphBLAS Operation Julia\nmxm, mxv, vxm bf C langle M rangle = C odot AB mul[!] or *\neWiseMult bf C langle M rangle = C odot (A otimes B) emul[!] or . broadcasting\neWiseAdd bf C langle M rangle = C odot (A oplus  B) eadd[!]\nextract bf C langle M rangle = C odot A(IJ) extract[!], getindex or A[i...]\nsubassign bf C (IJ) langle M rangle = C(IJ) odot A subassign[!], setindex! or A[i...]=3.5\nassign bf C langle M rangle (IJ) = C(IJ) odot A assign[!]\napply bf C langle M rangle = C odot fbf (A) map[!] or . broadcasting\n bf C langle M rangle = C odot f(bf Ay) \n bf C langle M rangle = C odot f(xbf A) \nselect bf C langle M rangle = C odot f(bf Ak) select[!]\nreduce bf w langle m rangle = w odot oplus_j bf A(j) reduce[!]\n s = s odot oplus_ij  bf A(ij) \ntranspose bf C langle M rangle = C odot A^sf T gbtranspose[!], lazy: transpose, '\nkronecker bf C langle M rangle = C odot textkron(A B) kron[!]","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"where bf M is a GBArray mask, odot is a binary operator for accumulating into bf C, and otimes and oplus are a binary operation and commutative monoid respectively. ","category":"page"},{"location":"#GraphBLAS-Operators","page":"Introduction","title":"GraphBLAS Operators","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"A GraphBLAS operator is a unary or binary function, the commutative monoid form of a binary function, or a semiring, made up of a binary op and a commutative monoid. SuiteSparse:GraphBLAS ships with many of the common unary and binary operators as built-ins, along with monoids and semirings built commonly used in graph algorithms.  In most cases these operators can be used with familiar Julia syntax and functions, which then map to objects found in the submodules below:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"UnaryOps such as SIN, SQRT, ABS\nBinaryOps such as GE, MAX, POW, FIRSTJ\nMonoids such as PLUS_MONOID, LXOR_MONOID\nSemirings such as PLUS_TIMES (the arithmetic semiring), MAX_PLUS (a tropical semiring), PLUS_PLUS, ...","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The above objects should, in almost all cases, be used by instead passing the equivalent functions, sin for SIN, + for PLUS_MONOID etc.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"A user may choose to call a function in multiple different forms: A .+ B, eadd(A, B, +), or eadd(A, B, BinaryOps.PLUS). ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Functions which only accept monoids like reduce will automatically find the correct monoid, so a call to reduce(+, A), will lower to reduce(Monoids.PLUS_MONOID, A).","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Matrix multiplication, which accepts a semiring, can be called with either *(max, +)(A, B), mul(A, B, (max, +)), or mul(A, B, Semirings.MAX_PLUS). ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"warning: Performance of User Defined Functions\nOperators which are not already built-in are automatically constructed using function pointers when called.  Note, however, that their performance is significantly degraded compared to built-in operators, and where possible user code should avoid this capability.","category":"page"},{"location":"#Example","page":"Introduction","title":"Example","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Here is an example of two different methods of triangle counting with GraphBLAS. The methods are drawn from the LAGraph repo.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Input A must be a square, symmetric matrix with any element type. We'll test it using the matrix from the GBArray section above, which has two triangles in its undirected form.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"function cohen(A)\n  U = select(triu, A)\n  L = select(tril, A)\n  return reduce(+, mul(L, U, (+, pair); mask=A)) ÷ 2\nend\n\nfunction sandia(A)\n  L = select(tril, A)\n  return reduce(+, mul(L, L, (+, pair); mask=L))\nend\n\nM = eadd(A, A', +) #Make undirected/symmetric\ncohen(M)\nsandia(M)","category":"page"}]
}
