var documenterSearchIndex = {"docs":
[{"location":"unaryops/#Unary-Operators","page":"Unary Operators","title":"Unary Operators","text":"","category":"section"},{"location":"unaryops/","page":"Unary Operators","title":"Unary Operators","text":"UnaryOps are fairly straightforward z = f(x) and their meaning should be clear from the name in most cases. ","category":"page"},{"location":"unaryops/","page":"Unary Operators","title":"Unary Operators","text":"UnaryOps are used only in the map function, for example:","category":"page"},{"location":"unaryops/","page":"Unary Operators","title":"Unary Operators","text":"using SuiteSparseGraphBLAS\n\nx = GBVector([1.5, 0, pi])\n\ny = map(UnaryOps.SIN, x)\n\nmap(UnaryOps.ASIN, y)\n","category":"page"},{"location":"unaryops/#Built-Ins","page":"Unary Operators","title":"Built-Ins","text":"","category":"section"},{"location":"unaryops/","page":"Unary Operators","title":"Unary Operators","text":"Modules = [SuiteSparseGraphBLAS]\nPages   = [\"unaryops.jl\"]","category":"page"},{"location":"selectops/#Select-Operators","page":"Select Operators","title":"Select Operators","text":"","category":"section"},{"location":"selectops/","page":"Select Operators","title":"Select Operators","text":"A SelectOp is effectively a binary or unary operation which is able to access the location of an element as well as its value. They define predicates for use with the select function.","category":"page"},{"location":"selectops/","page":"Select Operators","title":"Select Operators","text":"Applying select with a SelectOp will always return a result with the same type and shape as its argument.","category":"page"},{"location":"selectops/#Built-Ins","page":"Select Operators","title":"Built-Ins","text":"","category":"section"},{"location":"selectops/","page":"Select Operators","title":"Select Operators","text":"Built-in SelectOps can be found in the SelectOps submodule.","category":"page"},{"location":"selectops/","page":"Select Operators","title":"Select Operators","text":"Modules = [SuiteSparseGraphBLAS]\nPages   = [\"selectops.jl\"]","category":"page"},{"location":"binaryops/#Binary-Operators","page":"Binary Operators","title":"Binary Operators","text":"","category":"section"},{"location":"binaryops/","page":"Binary Operators","title":"Binary Operators","text":"Binary operators are defined on three domains D_1 times D_2 rightarrow D_3. However, the vast majority of binary operators are defined on a single domain.","category":"page"},{"location":"binaryops/#Built-Ins","page":"Binary Operators","title":"Built-Ins","text":"","category":"section"},{"location":"binaryops/","page":"Binary Operators","title":"Binary Operators","text":"All built-in binary oeprators can be found in the BinaryOps submodule.","category":"page"},{"location":"binaryops/","page":"Binary Operators","title":"Binary Operators","text":"The documentation below uses T to refer to any of the valid primitive types listed in Supported Types, ℤ to refer to integers (signed and unsigned), F to refer to floating point types, ℝ to refer to real numbers (non-complex numbers).","category":"page"},{"location":"binaryops/","page":"Binary Operators","title":"Binary Operators","text":"Modules = [SuiteSparseGraphBLAS]\nPages   = [\"binaryops.jl\"]","category":"page"},{"location":"operators/#Basics","page":"Basics","title":"Basics","text":"","category":"section"},{"location":"operators/","page":"Basics","title":"Basics","text":"There are five operator types in SuiteSparseGraphBLAS. Four are defined for all GraphBLAS implementations: UnaryOp, BinaryOp, Monoid, and Semiring.  One is an extension to the v1.3 specification: SelectOp.","category":"page"},{"location":"operators/","page":"Basics","title":"Basics","text":"note: Operator vs Algebraic Object\nWhile we will refer to anything in the list above as an operator, semirings and monoids are technically not operators so much as algebraic objects.","category":"page"},{"location":"operators/","page":"Basics","title":"Basics","text":"danger: Note\nOperators are not callable objects like functions. They do behave like functions as arguments to higher-order functions (operations in the language of GraphBLAS). ","category":"page"},{"location":"operators/","page":"Basics","title":"Basics","text":"Typically operators are positional arguments in one of two places. For operations with a clear default operator they appear as the last positional argument:","category":"page"},{"location":"operators/","page":"Basics","title":"Basics","text":"emul(A, B, op::BinaryOp)\neadd(A, B, op::BinaryOp)\nkron(A, B, op::BinaryOp)\nmul(A, B, op::Semiring)","category":"page"},{"location":"operators/","page":"Basics","title":"Basics","text":"For other operations without a clear default operator they appear as the first argument:","category":"page"},{"location":"operators/","page":"Basics","title":"Basics","text":"map(op::UnaryOp, A) or map(op::Monoid, A, x)\nreduce(op::BinaryOp, A)\nselect(op::SelectOp, A)","category":"page"},{"location":"operators/#UnaryOps,-BinaryOps,-Monoids,-and-Semirings","page":"Basics","title":"UnaryOps, BinaryOps, Monoids, and Semirings","text":"","category":"section"},{"location":"operators/","page":"Basics","title":"Basics","text":"Each operator is defined on a specific domain. For some this is the typical primitive datatypes like booleans, floats, and signed and unsigned integers of the typical sizes. A few also accept complex numbers, while most are restricted to some subset of these types.","category":"page"},{"location":"operators/","page":"Basics","title":"Basics","text":"Each operator is represented as its own concrete type.  For instance BinaryOps.PLUS <: AbstractBinaryOp <: AbstractOp. Operators are effectively dictionaries containing the type-specific operators indexed by the DataType of their arguments. ","category":"page"},{"location":"operators/#Supported-Types","page":"Basics","title":"Supported Types","text":"","category":"section"},{"location":"operators/","page":"Basics","title":"Basics","text":"GraphBLAS supports the following types:","category":"page"},{"location":"operators/","page":"Basics","title":"Basics","text":"Booleans\nIntegers with sizes 8, 16, 32, 64\nUnsigned Integers with sizes 8, 16, 32, 64\nFloat32 and Float64\nComplexF32 and ComplexF64","category":"page"},{"location":"operators/","page":"Basics","title":"Basics","text":"The supported types can be found as in the example below:","category":"page"},{"location":"operators/","page":"Basics","title":"Basics","text":"using SuiteSparseGraphBLAS","category":"page"},{"location":"operators/","page":"Basics","title":"Basics","text":"Semirings.MAX_PLUS\nSemirings.MAX_PLUS[Float64]","category":"page"},{"location":"operators/","page":"Basics","title":"Basics","text":"Either form may be passed to all operations, the function will take care of selecting the proper typed operator. Unless you need to specifically cast the arguments to a specific type there is no need to specify the operator type.","category":"page"},{"location":"operators/","page":"Basics","title":"Basics","text":"You can determine the available types for an operator and the input and output types of a type-specific operator with the functions below:","category":"page"},{"location":"operators/","page":"Basics","title":"Basics","text":"xtype\nytype\nztype","category":"page"},{"location":"operators/#SuiteSparseGraphBLAS.xtype","page":"Basics","title":"SuiteSparseGraphBLAS.xtype","text":"xtype(op::GrBOp)::DataType\n\nDetermine type of the first argument to a typed operator.\n\n\n\n\n\n","category":"function"},{"location":"operators/#SuiteSparseGraphBLAS.ytype","page":"Basics","title":"SuiteSparseGraphBLAS.ytype","text":"ytype(op::GrBOp)::DataType\n\nDetermine type of the second argument to a typed operator.\n\n\n\n\n\n","category":"function"},{"location":"operators/#SuiteSparseGraphBLAS.ztype","page":"Basics","title":"SuiteSparseGraphBLAS.ztype","text":"ytype(op::GrBOp)::DataType\n\nDetermine type of the output of a typed operator.\n\n\n\n\n\n","category":"function"},{"location":"operators/","page":"Basics","title":"Basics","text":"validtypes","category":"page"},{"location":"operators/#SuiteSparseGraphBLAS.validtypes","page":"Basics","title":"SuiteSparseGraphBLAS.validtypes","text":"validtypes(operator::AbstractOp)::Vector{DataType}\nvalidtypes(operator::SelectOp)::Nothing\n\nDetermine the types available as a domain for a particular operator. Each operator is defined on a specific set of types, for instance the LAND_LOR     semiring is only defined for Boolean arguments.\n\nWhen applied to an AbstractSelectOp this will return nothing. When applied to certain operators like positional semirings it will return [Any].\n\n\n\n\n\n","category":"function"},{"location":"operators/","page":"Basics","title":"Basics","text":"Some examples of these functions are below.  Note the difference between ISGT which returns a result with the same type as the input, and GT which returns a Boolean.","category":"page"},{"location":"operators/","page":"Basics","title":"Basics","text":"xtype(Semirings.LOR_GT[Float64])\nztype(Semirings.LOR_GT[Float64])\nxtype(BinaryOps.ISGT[Int8])\nztype(BinaryOps.ISGT[Int8])\nztype(BinaryOps.GT[Int8])","category":"page"},{"location":"operators/#SelectOps","page":"Basics","title":"SelectOps","text":"","category":"section"},{"location":"operators/","page":"Basics","title":"Basics","text":"The SelectOp is a SuiteSparse extension to the specification, although a similar construct is likely to be found in a future specification. Unlike the other operators there are no type-specific operators, and as such you cannot index into them with types to obtain a type-specific version.","category":"page"},{"location":"semirings/#Semirings","page":"Semirings","title":"Semirings","text":"","category":"section"},{"location":"semirings/","page":"Semirings","title":"Semirings","text":"A semiring in GraphBLAS is a set of three domains D_1, D_2, and D_3, along with two binary operators and an identity element mathbb0. ","category":"page"},{"location":"semirings/","page":"Semirings","title":"Semirings","text":"The first operator, oplus or \"add\" is a commutative and associative monoid defined on D_3 times D_3 rightarrow D_3. The identity of the monoid is mathbb0. See Monoids for more information.","category":"page"},{"location":"semirings/","page":"Semirings","title":"Semirings","text":"The second, otimes or \"multiply\", is a binary operator defined on D_1 times D_2 rightarrow D_3. See Binary Operators for more information. ","category":"page"},{"location":"semirings/","page":"Semirings","title":"Semirings","text":"A semiring is denoted by a tuple (D_1 D_2 D_3 oplus otimes mathbb0). However in the vast majority of cases D_1 = D_2 = D_3 so this is often shortened to (oplus otimes).","category":"page"},{"location":"semirings/","page":"Semirings","title":"Semirings","text":"Semirings are used in a single GraphBLAS operation, mul[!].","category":"page"},{"location":"semirings/#Built-Ins","page":"Semirings","title":"Built-Ins","text":"","category":"section"},{"location":"semirings/","page":"Semirings","title":"Semirings","text":"There are over 200 built-in semirings available as constants in the Semirings submodule. These are named <ADD>_<MULTIPLY> and include many of the most commonly used semirings such as:","category":"page"},{"location":"semirings/","page":"Semirings","title":"Semirings","text":"Arithmetic semiring (+ times), available as Semirings.PLUS_TIMES and as the default operator for mul[!].\nTropical semirings (max +), available as Semirings.MAX_PLUS, and (min +), available as Semirings.MIN_PLUS).\nBoolean semiring (vee wedge) available as Semirings.LOR_LAND. \nGF2, the two-element Galois Field (textxor wedge), available as Semirings.LXOR_LAND.","category":"page"},{"location":"semirings/","page":"Semirings","title":"Semirings","text":"Below is the list of built-ins with the two binary operators as well as the domains available listed for each semiring.","category":"page"},{"location":"semirings/","page":"Semirings","title":"Semirings","text":"note: Note\nIn all cases the input and output types of the semirings are the same, except for cases where the \"add\" types and \"multiply\" output output types are boolean, such as in LAND_GE.","category":"page"},{"location":"semirings/","page":"Semirings","title":"Semirings","text":"using Pkg\nPkg.activate(\"..\")\ncd(\"..\")\nusing SuiteSparseGraphBLAS\nusing Latexify\nhead = [\"Semiring\", \"⊕\", \"⊗\", \"Types\"]\nv1 = filter((x) -> x != \"Semirings\", string.(names(Semirings)))\nv2 = []\nv3 = []\nfor rig in v1\n    rigsplit = split(rig, '_')\n    monoidname = rigsplit[1] .* \"_MONOID\"\n    push!(v2, \"[\" .* rigsplit[1] .* \"_MONOID](https://juliasparse.github.io/SuiteSparseGraphBLAS.jl/dev/monoids/#SuiteSparseGraphBLAS.Monoids.$monoidname)\")\n    push!(v3, \"[\" .* rigsplit[2] .* \"](https://juliasparse.github.io/SuiteSparseGraphBLAS.jl/dev/binaryops/#SuiteSparseGraphBLAS.BinaryOps.$(rigsplit[2]))\")\nend\n\nv4 = []\nv1 = \"`\" .* v1 .* \"`\"\nfor op in names(Semirings)\n    op == :Semirings && continue\n    op = getproperty(Semirings, op)\n    push!(v4, SuiteSparseGraphBLAS.tolist(SuiteSparseGraphBLAS.validtypes(op)))\nend\nLatexify.mdtable(hcat(v1,v2,v3,v4); head, latex=false)","category":"page"},{"location":"udfs/#User-Defined-Operators","page":"User Defined Operators","title":"User Defined Operators","text":"","category":"section"},{"location":"udfs/","page":"User Defined Operators","title":"User Defined Operators","text":"warning: Experimental\nThis is still a work in progress, and subject to change. Please open an issue if you find any problems!","category":"page"},{"location":"udfs/","page":"User Defined Operators","title":"User Defined Operators","text":"GraphBLAS supports users to supply functions as operators. Constructors exported are:","category":"page"},{"location":"udfs/","page":"User Defined Operators","title":"User Defined Operators","text":"UnaryOp(name::String, fn::Function, [type | types | ztype, xtype | ztypes, xtypes])\nBinaryOp(name::String, fn::Function, [type | types | ztype, xtype | ztypes, xtypes])\nMonoid(name::String, binop::Union{AbstractBinaryOp, GrB_BinaryOp}, id::T, terminal::T = nothing): all types must be the same.\nSemiring(name::String, add::[GrB_Monoid | AbstractMonoid], mul::[GrB_BinaryOp | AbstractBinaryOp])","category":"page"},{"location":"udfs/","page":"User Defined Operators","title":"User Defined Operators","text":"GrB_ prefixed arguments are typed operators, such as the result of UnaryOps.COS[Float64]. Type arguments may be single types or vectors of types. If no type is supplied to UnaryOp or BinaryOp they will default to constructing typed operators for all the built-in primitive types.","category":"page"},{"location":"udfs/","page":"User Defined Operators","title":"User Defined Operators","text":"The fn arguments to UnaryOp and BinaryOp must have one or two arguments respectively.","category":"page"},{"location":"udfs/","page":"User Defined Operators","title":"User Defined Operators","text":"danger: Performance\nDue to the nature of the underlying C library user-defined operators may be significantly slower than their built-in counterparts. When possible use the built-in operators, or combinations of them.","category":"page"},{"location":"udfs/","page":"User Defined Operators","title":"User Defined Operators","text":"note: Where to Find User-Defined Operators\nThe constructors for an operator add that operator to the submodule for that operator type. For instance UnaryOp(minus, -, Int64, Int64) will add UnaryOps.minus.","category":"page"},{"location":"monoids/#Monoids","page":"Monoids","title":"Monoids","text":"","category":"section"},{"location":"monoids/","page":"Monoids","title":"Monoids","text":"A monoid is made up of a set or domain T and a binary operator z = f(x y) operating on the same domain, T times T rightarrow T. This binary operator must be associative, that is f(a f(b c)) = f(f(a b) c) is always true. Associativity is important for operations like reduce and the multiplication step of mul.","category":"page"},{"location":"monoids/","page":"Monoids","title":"Monoids","text":"The operator is also be equipped with an identity such that f(x 0) = f(0 x) = x. Some monoids are equipped with a terminal or annihilator such that z = f(z x) forall x.","category":"page"},{"location":"monoids/","page":"Monoids","title":"Monoids","text":"Monoids are used primarily in the reduce(@ref) operation. Their other use is as a component of semirings in the mul operation.","category":"page"},{"location":"monoids/#Built-Ins","page":"Monoids","title":"Built-Ins","text":"","category":"section"},{"location":"monoids/","page":"Monoids","title":"Monoids","text":"All built-in monoids can be found in the Monoids submodule.","category":"page"},{"location":"monoids/","page":"Monoids","title":"Monoids","text":"The documentation below uses T to refer to any of the valid primitive types listed in Supported Types, ℤ to refer to integers (signed and unsigned), F to refer to floating point types, ℝ to refer to real numbers (non-complex numbers).","category":"page"},{"location":"monoids/","page":"Monoids","title":"Monoids","text":"note: Note\nIn the case of floating point numbers +∞ and -∞ have their typical meanings. However, for integer types they indicate typemax and typemin respectively.","category":"page"},{"location":"monoids/","page":"Monoids","title":"Monoids","text":"Modules = [SuiteSparseGraphBLAS]\nPages   = [\"monoids.jl\"]","category":"page"},{"location":"#SuiteSparseGraphBLAS.jl","page":"Introduction","title":"SuiteSparseGraphBLAS.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"SuiteSparseGraphBLAS.jl is a package for sparse linear algebra on arbitrary semirings, with a particular focus on graph computations. It aims to provide a Julian wrapper over Tim Davis' SuiteSparse reference implementation of the GraphBLAS C specification.","category":"page"},{"location":"#Roadmap","page":"Introduction","title":"Roadmap","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"note: Note\nThis library is still a WIP, if you are missing any functionality, find any incorrectly implemented functions, or need further/better documentation please open an issue, PR, or ask in the #GraphBLAS channel on the Julia Zulip (preferred) or the #graphblas channel on the Julia Slack!","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"While the core library is mostly complete, and all GraphBLAS functionality is present, there are still quite a few features being worked on for v1.0:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"ChainRules.jl integration for AD.\nComplete SparseArrays and ArrayInterface interfaces.\nFancy printing\nUser-defined types.\nAlternative syntax for GraphBLAS ops (currently must use BinaryOps.PLUS instead of +).","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Once these are completed there will be a v1.0 release, with the goal being JuliaCon 2021.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Post 1.0 goals include:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"LightGraphs integration.\nGeometricFlux or other graph machine learning framework integration.\nMore efficient import and export between Julia and GraphBLAS\nSupport for other GraphBLAS implementations in a follow-up GraphBLAS.jl","category":"page"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Install using the Julia package manager in the REPL:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"] add SuiteSparseGraphBLAS","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"or with Pkg","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using Pkg\nPkg.add(\"SuiteSparseGraphBLAS\")","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The SuiteSparse:GraphBLAS binary is installed automatically as SSGraphBLAS_jll.","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"GraphBLAS harnesses the well-understood duality between graphs and matrices. Specifically a graph can be represented by its adjacency matrix, incidence matrix, or the many variations on those formats.  With this matrix representation in hand we have a method to operate on the graph using linear algebra operations on the matrix.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Below is an example of the adjacency matrix of a directed graph, and finding the neighbors of a single vertex using basic matrix-vector multiplication on the arithemtic semiring.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"(Image: BFS and Adjacency Matrix)","category":"page"},{"location":"#GraphBLAS-Concepts","page":"Introduction","title":"GraphBLAS Concepts","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The three primary components of GraphBLAS are: matrices, operators, and operations. Operators include monoids, binary operators, and semirings. Operations include the typical linear algebraic operations like matrix multiplication as well as indexing operations.","category":"page"},{"location":"#GBArrays","page":"Introduction","title":"GBArrays","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"SuiteSparseGraphBLAS.jl provides GBVector and GBMatrix array types which are subtypes of SparseArrays.AbstractSparseVector and SparseArrays.AbstractSparseMatrix respectively. Both can be constructed with no arguments to use the maximum size.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using SuiteSparseGraphBLAS\nusing SparseArrays","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"GBVector{Float64}()\n\nGBMatrix{ComplexF64}()","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"GraphBLAS array types are opaque to the user in order to allow the library author to choose the best storage format. SuiteSparse:GraphBLAS takes advantage of this by storing matrices in one of four formats: dense, bitmap, sparse-compressed, or hypersparse-compressed; and in either row or column major orientation. SuiteSparseGraphBLAS.jl sets the default to column major to ensure fast imports and exports.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"A complete list of construction methods can be found in Construction, but the matrix and vector above can be constructed as follows:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"A = GBMatrix([1,1,2,2,3,4,4,5,6,7,7,7], [2,4,5,7,6,1,3,6,3,3,4,5], [1:12...])\n\nv = GBVector([4], [10])","category":"page"},{"location":"#GraphBLAS-Operations","page":"Introduction","title":"GraphBLAS Operations","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The complete documentation of supported operations can be found in Operations. GraphBLAS operations are, where possible, methods of existing Julia functions  listed in the third column.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"GraphBLAS Operation Julia\nmxm, mxv, vxm bf C langle M rangle = C odot AB mul[!]\neWiseMult bf C langle M rangle = C odot (A otimes B) emul[!]\neWiseAdd bf C langle M rangle = C odot (A oplus  B) eadd[!]\nextract bf C langle M rangle = C odot A(IJ) extract[!], getindex\nsubassign bf C (IJ) langle M rangle = C(IJ) odot A subassign[!], setindex!\nassign bf C langle M rangle (IJ) = C(IJ) odot A assign[!]\napply bf C langle M rangle = C odot fbf (A) map[!]\n bf C langle M rangle = C odot f(bf Ay) \n bf C langle M rangle = C odot f(xbf A) \nselect bf C langle M rangle = C odot f(bf Ak) select[!]\nreduce bf w langle m rangle = w odot oplus_j bf A(j) reduce[!]\n s = s odot oplus_ij  bf A(ij) \ntranspose bf C langle M rangle = C odot A^sf T gbtranspose[!], lazy: transpose, '\nkronecker bf C langle M rangle = C odot textkron(A B) kron[!]","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"where bf M is a GBArray mask, odot is a binary operator for accumulating into bf C, and otimes and oplus are a binary operation and commutative monoid respectively. ","category":"page"},{"location":"#GraphBLAS-Operators","page":"Introduction","title":"GraphBLAS Operators","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"GraphBLAS operators are one of the following:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"UnaryOps such as SIN, SQRT, ABS, ...\nBinaryOps such as GE, MAX, POW, FIRSTJ, ...\nMonoids such as PLUS_MONOID, LXOR_MONOID, ...\nSemirings such as PLUS_TIMES (the arithmetic semiring), MAX_PLUS (a tropical semiring), PLUS_PLUS, ...","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Built-in operators can be found in exported submodules:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> BinaryOps.\\TAB\n\nANY       BSET       DIV        FIRSTJ1    ISGE       LDEXP      MIN        RDIV       SECONDJ\nATAN2     BSHIFT     EQ         FMOD       ISGT       LE         MINUS      REMAINDER  SECONDJ1\nBAND      BXNOR      FIRST      GE         ISLE       LOR        NE         RMINUS     TIMES\nBCLR      BXOR       FIRSTI     GT         ISLT       LT         PAIR       SECOND\nBGET      CMPLX      FIRSTI1    HYPOT      ISNE       LXOR       PLUS       SECONDI\nBOR       COPYSIGN   FIRSTJ     ISEQ       LAND       MAX        POW        SECONDI1","category":"page"},{"location":"#Example","page":"Introduction","title":"Example","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Here is an example of two different methods of triangle counting with GraphBLAS. The methods are drawn from the LAGraph repo.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Input A must be a square, symmetric matrix with any element type. We'll test it using the matrix from the GBArray section above, which has two triangles in its undirected form.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"function cohen(A)\n  U = select(TRIU, A)\n  L = select(TRIL, A)\n  return reduce(Monoids.PLUS_MONOID[Int64], mul(L, U, Semirings.PLUS_PAIR; mask=A)) ÷ 2\nend\n\nfunction sandia(A)\n  L = select(TRIL, A)\n  return reduce(Monoids.PLUS_MONOID[Int64], mul(L, L, Semirings.PLUS_PAIR; mask=L))\nend\n\nM = eadd(A, A', BinaryOps.PLUS) #Make undirected/symmetric\ncohen(M)\nsandia(M)","category":"page"},{"location":"arrays/#GBArrays","page":"Arrays","title":"GBArrays","text":"","category":"section"},{"location":"arrays/","page":"Arrays","title":"Arrays","text":"There are two datastructures in in SuiteSparseGraphBLAS.jl: the GBVector and GBMatrix.","category":"page"},{"location":"arrays/","page":"Arrays","title":"Arrays","text":"Both types currently implement most of the AbstractArray interface and part of the SparseArrays interface.  The goal is to cover the entirety of both (applicable) interfaces as well as ArrayInterface.jl with the v1.0 release. ","category":"page"},{"location":"arrays/","page":"Arrays","title":"Arrays","text":"Most functions accept either type, which is represented by the union  GBArray = {GBVector, GBMatrix, Transpose{<:Any, <:GBMatrix}}. ","category":"page"},{"location":"arrays/#Matrix-Construction","page":"Arrays","title":"Matrix Construction","text":"","category":"section"},{"location":"arrays/","page":"Arrays","title":"Arrays","text":"using SuiteSparseGraphBLAS\nusing SparseArrays","category":"page"},{"location":"arrays/","page":"Arrays","title":"Arrays","text":"x = GBMatrix{Bool}(20_000_000, 50_000)\nx = GBMatrix([[1,2] [3,4]])\nx = GBMatrix(sprand(100, 100, 0.5))\nx = GBMatrix(rand(1:50_000, 5000), rand(1:500_000, 5000), 1; ncols = 500_000, nrows = 500_000)","category":"page"},{"location":"arrays/","page":"Arrays","title":"Arrays","text":"GBMatrix\nSuiteSparseGraphBLAS.GBMatrix(::Matrix)\nSuiteSparseGraphBLAS.GBMatrix(::SparseMatrixCSC)","category":"page"},{"location":"arrays/#SuiteSparseGraphBLAS.GBMatrix","page":"Arrays","title":"SuiteSparseGraphBLAS.GBMatrix","text":"GBMatrix{T} <: AbstractSparseArray{T, UInt64, 2}\n\nTWo-dimensional GraphBLAS array with elements of type T. Internal representation is specified as opaque, but in this implementation is stored as one of the following in either row or column orientation:\n\n1. Dense\n2. Bitmap\n3. Sparse Compressed\n4. Hypersparse\n\nThe storage type is automatically determined by the library.\n\n\n\n\n\n","category":"type"},{"location":"arrays/#SuiteSparseGraphBLAS.GBMatrix-Tuple{Matrix{T} where T}","page":"Arrays","title":"SuiteSparseGraphBLAS.GBMatrix","text":"GBMatrix{T}(nrows = libgb.GxB_INDEX_MAX, ncols = libgb.GxB_INDEX_MAX)\n\nCreate a GBMatrix with the max size.\n\n\n\n\n\nGBMatrix(I, J, X; dup = BinaryOps.PLUS, nrows = maximum(I), ncols = maximum(J))\n\nCreate an nrows x ncols GBMatrix M such that M[I[k], J[k]] = X[k]. The dup function defaults to | for booleans and + for nonbooleans.\n\n\n\n\n\nGBMatrix(I, J, x; nrows = maximum(I), ncols = maximum(J))\n\nCreate an nrows x ncols GBMatrix M such that M[I[k], J[k]] = x. The resulting matrix is \"iso-valued\" such that it only stores x once rather than once for each index.\n\n\n\n\n\nGBMatrix(M::Matrix)\n\nCreate a GBMatrix from a Julia dense matrix.\n\n\n\n\n\n","category":"method"},{"location":"arrays/#SuiteSparseGraphBLAS.GBMatrix-Tuple{SparseMatrixCSC}","page":"Arrays","title":"SuiteSparseGraphBLAS.GBMatrix","text":"GBMatrix(S::SparseMatrixCSC)\n\nCreate a GBMatrix from SparseArrays sparse matrix S.\n\n\n\n\n\n","category":"method"},{"location":"arrays/","page":"Arrays","title":"Arrays","text":"Conversion back to matrices, sparse or dense, is also supported.","category":"page"},{"location":"arrays/#Vector-Construction","page":"Arrays","title":"Vector Construction","text":"","category":"section"},{"location":"arrays/","page":"Arrays","title":"Arrays","text":"v = GBVector{ComplexF32}(100)\nv = GBMatrix(rand(ComplexF64, 3))\nv = GBVector(sprand(Bool, 100_000_000, 0.001))","category":"page"},{"location":"arrays/","page":"Arrays","title":"Arrays","text":"GBVector\nSuiteSparseGraphBLAS.GBVector{T}()\nSuiteSparseGraphBLAS.GBVector(::Vector, ::Vector)\nSuiteSparseGraphBLAS.GBVector(::SparseVector)","category":"page"},{"location":"arrays/#SuiteSparseGraphBLAS.GBVector","page":"Arrays","title":"SuiteSparseGraphBLAS.GBVector","text":"GBVector{T} <: AbstractSparseArray{T, UInt64, 1}\n\nOne-dimensional GraphBLAS array with elements of type T. Internal representation is specified as opaque, but may be either a dense array, bitmap array, or compressed sparse vector.\n\nSee also: GBMatrix.\n\n\n\n\n\n","category":"type"},{"location":"arrays/#SuiteSparseGraphBLAS.GBVector-Union{Tuple{}, Tuple{T}} where T","page":"Arrays","title":"SuiteSparseGraphBLAS.GBVector","text":"GBVector{T}(n = libgb.GxB_INDEX_MAX)\n\n\n\n\n\n","category":"method"},{"location":"arrays/#SuiteSparseGraphBLAS.GBVector-Tuple{Vector{T} where T, Vector{T} where T}","page":"Arrays","title":"SuiteSparseGraphBLAS.GBVector","text":"GBVector(I::Vector, X::Vector{T})\n\nCreate a GBVector from a vector of indices I and a vector of values X.\n\n\n\n\n\nGBVector(I, x; nrows = maximum(I))\n\nCreate an n length GBVector v such that M[I[k]] = x. The resulting vector is \"iso-valued\" such that it only stores x once rather than once for each index.\n\n\n\n\n\n","category":"method"},{"location":"arrays/#SuiteSparseGraphBLAS.GBVector-Tuple{SparseVector}","page":"Arrays","title":"SuiteSparseGraphBLAS.GBVector","text":"GBVector(v::SparseVector)\n\nCreate a GBVector from SparseArrays sparse vector v.\n\n\n\n\n\n","category":"method"},{"location":"arrays/#Indexing","page":"Arrays","title":"Indexing","text":"","category":"section"},{"location":"arrays/","page":"Arrays","title":"Arrays","text":"The usual AbstractArray and SparseArray indexing should work here. Including indexing by scalars, vectors, and ranges.","category":"page"},{"location":"arrays/","page":"Arrays","title":"Arrays","text":"danger: Indexing Structural Zeros\nWhen you index a SparseMatrixCSC from SparseArrays and hit a structural zero (a value within the dimensions of the matrix but not stored) you can expect a zero(T).When you index a GBArray you will get nothing when you hit a structural zero. This is because the zero in GraphBLAS depends not just on the domain of the elements but also on what you are doing with them. For instance with an element type of Float64 you could want the zero to be 0.0, -∞ or +∞.","category":"page"},{"location":"arrays/","page":"Arrays","title":"Arrays","text":"We'll use the small matrix from the Introduction to illustrate the indexing capabilities. We will also use SparseArrays.SparseMatrixCSC for the pretty printing functionality, which should be available in this package in v1.0.","category":"page"},{"location":"arrays/","page":"Arrays","title":"Arrays","text":"A = GBMatrix([1,1,2,2,3,4,4,5,6,7,7,7], [2,4,5,7,6,1,3,6,3,3,4,5], [1:12...])\nSparseMatrixCSC(A)\nA[4]\nA[1,2]\nA[[1,3,5,7], :]\nA[1:2:7, :]\nA[:,:]\nA[:, 5]\nSparseMatrixCSC(A[:,:, desc=T0]) #Transpose the first argument","category":"page"},{"location":"arrays/","page":"Arrays","title":"Arrays","text":"All of this same functionality exists for vectors in 1-dimension.","category":"page"},{"location":"arrays/#Transpose","page":"Arrays","title":"Transpose","text":"","category":"section"},{"location":"arrays/","page":"Arrays","title":"Arrays","text":"The typical lazy Julia transpose is available as usual, and the adjoint operator ' is also overloaded to be equivalent.","category":"page"},{"location":"arrays/","page":"Arrays","title":"Arrays","text":"x = A' will create a Transpose wrapper. When an operation uses this argument it will cause the desc to set INP<0|1> = T_<0|1>. ","category":"page"},{"location":"arrays/","page":"Arrays","title":"Arrays","text":"warning: Warning\nVectors do not support transposition at this time. A matrix with the column or row size set to 1 may be a solution.","category":"page"},{"location":"arrays/#Utilities","page":"Arrays","title":"Utilities","text":"","category":"section"},{"location":"arrays/","page":"Arrays","title":"Arrays","text":"clear!","category":"page"},{"location":"arrays/#SuiteSparseGraphBLAS.clear!","page":"Arrays","title":"SuiteSparseGraphBLAS.clear!","text":"clear!(v::GBVector)\nclear!(A::GBMatrix)\n\nClear all the entries from the GBArray. Does not modify the type or dimensions.\n\n\n\n\n\n","category":"function"},{"location":"operations/#Operations","page":"Operations","title":"Operations","text":"","category":"section"},{"location":"operations/","page":"Operations","title":"Operations","text":"GraphBLAS operations cover most of the typical linear algebra operations on arrays in Julia.","category":"page"},{"location":"operations/#Correspondence-of-GraphBLAS-C-functions-and-Julia-functions","page":"Operations","title":"Correspondence of GraphBLAS C functions and Julia functions","text":"","category":"section"},{"location":"operations/","page":"Operations","title":"Operations","text":"GraphBLAS Operation Julia\nmxm, mxv, vxm bf C langle M rangle = C odot AB mul[!]\neWiseMult bf C langle M rangle = C odot (A otimes B) emul[!]\neWiseAdd bf C langle M rangle = C odot (A oplus  B) eadd[!]\nextract bf C langle M rangle = C odot A(IJ) extract[!], getindex\nsubassign bf C (IJ) langle M rangle = C(IJ) odot A subassign[!], setindex!\nassign bf C langle M rangle (IJ) = C(IJ) odot A assign[!]\napply bf C langle M rangle = C odot fbf (A) map[!]\n bf C langle M rangle = C odot f(bf Ay) \n bf C langle M rangle = C odot f(xbf A) \nselect bf C langle M rangle = C odot f(bf Ak) select[!]\nreduce bf w langle m rangle = w odot oplus_j bf A(j) reduce[!]\n s = s odot oplus_ij  bf A(ij) \ntranspose bf C langle M rangle = C odot A^sf T gbtranspose[!], lazy: transpose, '\nkronecker bf C langle M rangle = C odot textkron(A B) kron[!]","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"where bf M is a GBArray mask, odot is a binary operator for accumulating into bf C, and otimes and oplus are a binary operation and commutative monoid respectively. ","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"note: assign vs subassign\nsubassign is equivalent to assign except that the mask in subassign has the dimensions of bf C(IJ) vs the dimensions of C for assign, and elements outside of the mask will never be modified by subassign. See the GraphBLAS User Guide for more details.","category":"page"},{"location":"operations/#Common-arguments","page":"Operations","title":"Common arguments","text":"","category":"section"},{"location":"operations/","page":"Operations","title":"Operations","text":"The operations above have often accept most or all of the following arguments.","category":"page"},{"location":"operations/#op-UnaryOp,-BinaryOp,-Monoid,-Semiring,-or-SelectOp:","page":"Operations","title":"op - UnaryOp, BinaryOp, Monoid, Semiring, or SelectOp:","text":"","category":"section"},{"location":"operations/","page":"Operations","title":"Operations","text":"This is the most important argument for most of the GraphBLAS operations. It determines oplus, otimes, or f in the table above as well as the semiring used in mul. Most operations are restricted to one type of operator.","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"tip: Built-Ins\nThe built-in operators can be found in the submodules: UnaryOps, BinaryOps, Monoids, and Semirings.","category":"page"},{"location":"operations/#desc-Descriptor:","page":"Operations","title":"desc - Descriptor:","text":"","category":"section"},{"location":"operations/","page":"Operations","title":"Operations","text":"The descriptor argument allows the user to modify the operation in some fashion. The most common options are:","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"desc.[input1 | input2] == [DEFAULT | TRANSPOSE] \nTransposes the inputs and can be found in [T0 | T1 | T0T1].    Typically you should use Julia's built-in transpose functionality.\ndesc.mask == [DEFAULT | STRUCTURE | COMPLEMENT | STRUCT_COMP] \nIf STRUCTURE is set the operation will use the presence of a value rather than the value itself to determine whether the index is masked.    If COMPLEMENT is set the presence/truth value is complemented (ie. if no value is present or the value is false that index is masked).\ndesc.output == [DEFAULT | REPLACE]\nIf REPLACE is set the operation will replace all values in the output matrix after the accumulation step.    If an index is found in the output matrix, but not in the results of the operation it will be set to nothing. ","category":"page"},{"location":"operations/#accum-BinaryOp:","page":"Operations","title":"accum - BinaryOp:","text":"","category":"section"},{"location":"operations/","page":"Operations","title":"Operations","text":"The accum keyword argument provides a binary operation to accumulate results into the result array.  The accumulation step is performed before masking.","category":"page"},{"location":"operations/#mask-GBArray:","page":"Operations","title":"mask - GBArray:","text":"","category":"section"},{"location":"operations/","page":"Operations","title":"Operations","text":"The mask keyword argument determines whether each index from the result of an operation appears in the output.  The mask may be structural, where the presence of a value indicates the mask is true, or valued where the value of the mask indicates its truth value.  The mask may also be complemented. These options are controlled by the desc argument.","category":"page"},{"location":"operations/#Order-of-Operations","page":"Operations","title":"Order of Operations","text":"","category":"section"},{"location":"operations/","page":"Operations","title":"Operations","text":"A GraphBLAS operation occurs in the following order (steps are skipped when possible):","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"Calculate T = <operation>(args...)\nElementwise accumulate Z[i,j] = accum(C[i,j], T[i,j])\nOptionally masked assignment C[i,j] = mask[i,j] ? Z[i,j] : [nothing | C[i,j]]","category":"page"},{"location":"operations/","page":"Operations","title":"Operations","text":"If REPLACE is set the option in step 3. is nothing, otherwise it is C[i,j].","category":"page"},{"location":"operations/#Operation-Documentation","page":"Operations","title":"Operation Documentation","text":"","category":"section"},{"location":"operations/","page":"Operations","title":"Operations","text":"All non-mutating operations below support a mutating form by adding an output array as the first argument as well as the ! function suffix. ","category":"page"},{"location":"operations/#mul","page":"Operations","title":"mul","text":"","category":"section"},{"location":"operations/","page":"Operations","title":"Operations","text":"mul","category":"page"},{"location":"operations/#SuiteSparseGraphBLAS.mul","page":"Operations","title":"SuiteSparseGraphBLAS.mul","text":"mul(A::GBArray, B::GBArray; kwargs...)::GBArray\n\nMultiply two GBArrays A and B using a semiring provided in the op keyword argument. If either A or B is a GBMatrix it may be transposed either using the descriptor or by using transpose(A) or A'.\n\nThe default semiring is the +.* semiring.\n\nArguments\n\nA::GBArray: GBVector or optionally transposed GBMatrix.\nB::GBArray: GBVector or optionally transposed GBMatrix.\n\nKeywords\n\nmask::Union{Nothing, GBMatrix} = nothing: optional mask which determines the output   pattern.\naccum::Union{Nothing, AbstractBinaryOp} = nothing: optional binary accumulator   operation where C[i,j] = accum(C[i,j], T[i,j]) where T is the result of this function before accum is applied.\ndesc = nothing\n\nReturns\n\nGBArray: The output matrix whose eltype is determined by A and B or the semiring   if a type specific semiring is provided.\n\n\n\n\n\n","category":"function"},{"location":"operations/","page":"Operations","title":"Operations","text":"emul\neadd\nextract\nsubassign!\nassign!\nBase.map\nselect\nBase.reduce\ngbtranspose\nLinearAlgebra.kron","category":"page"},{"location":"operations/#SuiteSparseGraphBLAS.emul","page":"Operations","title":"SuiteSparseGraphBLAS.emul","text":"emul(A::GBArray, B::GBArray, op = BinaryOps.TIMES; kwargs...)::GBMatrix\n\nApply the binary operator op elementwise on the set intersection of A and B. Store or accumulate the result into C. When op = BinaryOps.TIMES this is equivalent to A .* B, however any binary operation may be substituted.\n\nAs mentioned the pattern of the result is the set intersection of A and B. For a set union equivalent see eadd.\n\nArguments\n\nA::GBArray: GBVector or optionally transposed GBMatrix.\nB::GBArray: GBVector or optionally transposed GBMatrix.\nop::MonoidBinaryOrRig = BinaryOps.TIMES: the binary operation which is applied such that   C[i,j] = op(A[i,j], B[i,j]) for all i,j present in both A and B.\n\nKeywords\n\nmask::Union{Nothing, GBMatrix} = nothing: optional mask.\naccum::Union{Nothing, AbstractBinaryOp} = nothing: binary accumulator operation   where C[i,j] = accum(C[i,j], T[i,j]) where T is the result of this function before accum is applied.\ndesc = nothing\n\nReturns\n\nGBArray: Output GBVector or GBMatrix whose eltype is determined by the eltype of   A and B or the binary operation if a type specific operation is provided.\n\n\n\n\n\n","category":"function"},{"location":"operations/#SuiteSparseGraphBLAS.eadd","page":"Operations","title":"SuiteSparseGraphBLAS.eadd","text":"eadd(A::GBArray, B::GBArray, op = BinaryOps.PLUS; kwargs...)::GBArray\n\nApply the binary operator op elementwise on the set union of A and B. Store or accumulate the result into C. When op = BinaryOps.TIMES this is equivalent to A .* B, however any binary operation may be substituted.\n\nAs mentioned the pattern of the result is the set union of A and B. For a set intersection equivalent see emul.\n\nArguments\n\nA::GBArray: GBVector or optionally transposed GBMatrix.\nB::GBArray: GBVector or optionally transposed GBMatrix.\nop::MonoidBinaryOrRig = BinaryOps.PLUS: the binary operation which is applied such that   C[i,j] = op(A[i,j], B[i,j]) for all i,j present in either A or B.\n\nKeywords\n\nmask::Union{Nothing, GBMatrix} = nothing: optional mask.\naccum::Union{Nothing, AbstractBinaryOp} = nothing: binary accumulator operation   where C[i,j] = accum(C[i,j], T[i,j]) where T is the result of this function before accum is applied.\ndesc = nothing\n\nReturns\n\nGBArray: Output GBVector or GBMatrix whose eltype is determined by the eltype of   A and B or the binary operation if a type specific operation is provided.\n\n\n\n\n\n","category":"function"},{"location":"operations/#SuiteSparseGraphBLAS.extract","page":"Operations","title":"SuiteSparseGraphBLAS.extract","text":"extract(u::GBVector, I; kwargs...)::GBVector\n\nExtract a subvector from u and return it. Equivalent to the matrix definition.\n\n\n\n\n\nextract(A::GBMatrix, I, J; kwargs...)::GBMatrix\n\nExtract a submatrix from A.\n\nArguments\n\nA::GBMatrix: the array being indexed.\nI and J: A colon, scalar, vector, or range indexing A.\n\nKeywords\n\nmask::Union{Ptr{Nothing}, GBMatrix} = C_NULL: mask where   size(M) == (max(I), max(J)).\naccum::Union{Ptr{Nothing}, AbstractBinaryOp} = C_NULL: binary accumulator operation   where C[i,j] = accum(C[i,j], T[i,j]) where T is the result of this function before accum is applied. C is, however, empty.\ndesc::Descriptor = DEFAULTDESC\n\nReturns\n\nGBMatrix: the submatrix A[I, J].\n\nThrows\n\nGrB_DIMENSION_MISMATCH: If (max(I), max(J)) != size(mask).\n\n\n\n\n\n","category":"function"},{"location":"operations/#SuiteSparseGraphBLAS.subassign!","page":"Operations","title":"SuiteSparseGraphBLAS.subassign!","text":"subassign(w::GBVector, u::GBVector, I; kwargs...)::GBVector\n\nAssign a subvector of w to u. Return u. Equivalent to the matrix definition.\n\n\n\n\n\nsubassign!(C::GBMatrix, A::GBMatrix, I, J; kwargs...)::GBMatrix\n\nAssign a submatrix of C to A. Equivalent to assign! except that size(mask) == size(A), whereas size(mask) == size(C) in assign!.\n\nArguments\n\nC::GBMatrix: the matrix being subassigned to where C[I,J] = A.\nA::GBMatrix: the matrix being assigned to a submatrix of C.\nI and J: A colon, scalar, vector, or range indexing C.\n\nKeywords\n\nmask::Union{Ptr{Nothing}, GBMatrix} = C_NULL: mask where   size(M) == size(A).\naccum::Union{Ptr{Nothing}, AbstractBinaryOp} = C_NULL: binary accumulator operation   where C[i,j] = accum(C[i,j], T[i,j]) where T is the result of this function before accum is applied.\ndesc::Descriptor = DEFAULTDESC\n\nReturns\n\nGBMatrix: The input matrix A.\n\nThrows\n\nGrB_DIMENSION_MISMATCH: If size(A) != (max(I), max(J)) or size(A) != size(mask).\n\n\n\n\n\n","category":"function"},{"location":"operations/#SuiteSparseGraphBLAS.assign!","page":"Operations","title":"SuiteSparseGraphBLAS.assign!","text":"assign(w::GBVector, u::GBVector, I; kwargs...)::GBVector\n\nAssign a subvector of w to u. Return u. Equivalent to the matrix definition.\n\n\n\n\n\nassign!(C::GBMatrix, A::GBMatrix, I, J; kwargs...)::GBMatrix\n\nAssign a submatrix of C to A. Equivalent to subassign! except that size(mask) == size(C), whereas size(mask) == size(A) insubassign!`.\n\nArguments\n\nC::GBMatrix: the matrix being subassigned to where C[I,J] = A.\nA::GBMatrix: the matrix being assigned to a submatrix of C.\nI and J: A colon, scalar, vector, or range indexing C.\n\nKeywords\n\nmask::Union{Ptr{Nothing}, GBMatrix} = C_NULL: mask where   size(M) == size(C).\naccum::Union{Ptr{Nothing}, AbstractBinaryOp} = C_NULL: binary accumulator operation   where C[i,j] = accum(C[i,j], T[i,j]) where T is the result of this function before accum is applied.\ndesc::Descriptor = DEFAULTDESC\n\nReturns\n\nGBMatrix: The input matrix A.\n\nThrows\n\nGrB_DIMENSION_MISMATCH: If size(A) != (max(I), max(J)) or size(C) != size(mask).\n\n\n\n\n\n","category":"function"},{"location":"operations/#Base.map","page":"Operations","title":"Base.map","text":"map(op::UnaryOp, A::GBArray; kwargs...)::GBArray\nmap(op::BinaryOp, A::GBArray, x; kwargs...)::GBArray\nmap(op::BinaryOp, x, A::GBArray, kwargs...)::GBArray\n\nTransform a GBArray by applying op to each element.\n\nUnaryOps apply elementwise in the usual fashion. BinaryOps require the additional argument x which is substituted as the first or second argument of op depending on its position.\n\nArguments\n\nop::MonoidBinaryOrRig = BinaryOps.PLUS: the binary operation which is applied such that   C[i,j] = op(A[i,j], B[i,j]) for all i,j present in either A and/or B.\nA::GBArray: GBVector or optionally transposed GBMatrix.\nx: Position dependent argument to binary operators.\n\nKeywords\n\nmask::Union{Nothing, GBMatrix} = nothing: optional mask.\naccum::Union{Nothing, AbstractBinaryOp} = nothing: binary accumulator operation   where C[i,j] = accum(C[i,j], T[i,j]) where T is the result of this function before accum is applied.\ndesc = nothing\n\n\n\n\n\n","category":"function"},{"location":"operations/#SuiteSparseGraphBLAS.select","page":"Operations","title":"SuiteSparseGraphBLAS.select","text":"select(op::SelectUnion, A::GBArray; kwargs...)::GBArray\nselect(op::SelectUnion, A::GBArray, thunk; kwargs...)::GBArray\n\nReturn a GBArray whose elements satisfy the predicate defined by op. Some SelectOps may require an additional argument thunk, for use in comparison operations such as C[i,j] = A[i,j] >= thunk ? A[i,j] : nothing, which maps to select(GT, A, thunk).\n\nArguments\n\nop::SelectUnion: A select operator from the SelectOps submodule.\nA::GBArray: GBVector or optionally transposed GBMatrix.\nthunk::Union{GBScalar, nothing, valid_union}: Optional value used to evaluate op.\n\nKeywords\n\nmask::Union{Nothing, GBMatrix} = nothing: optional mask which determines the output   pattern.\naccum::Union{Nothing, AbstractBinaryOp} = nothing: optional binary accumulator   operation where C[i,j] = accum(C[i,j], T[i,j]) where T is the result of this function before accum is applied.\ndesc = nothing\n\nReturns\n\nGBArray: The output matrix whose eltype is determined by A.\n\n\n\n\n\n","category":"function"},{"location":"operations/#Base.reduce","page":"Operations","title":"Base.reduce","text":"reduce(op::Monoid, A::GBMatrix, dims=:; kwargs...)\nreduce(op::Monoid, v::GBVector; kwargs...)\n\nReduce A along dimensions of A with monoid op.\n\nArguments\n\nop::MonoidUnion: the monoid reducer. This may not be a BinaryOp.\nA::GBArray: GBVector or optionally transposed GBMatrix.\ndims = :: Optional dimensions for GBMatrix, may be 1, 2, or :.\n\nKeywords\n\ntypeout: Optional output type specification. Defaults to eltype(A).\ninit: Optional initial value.\nmask::Union{Nothing, GBMatrix} = nothing: optional mask.\naccum::Union{Nothing, AbstractBinaryOp} = nothing: binary accumulator operation   where C[i,j] = accum(C[i,j], T[i,j]) where T is the result of this function before accum is applied.\ndesc = nothing\n\n\n\n\n\n","category":"function"},{"location":"operations/#SuiteSparseGraphBLAS.gbtranspose","page":"Operations","title":"SuiteSparseGraphBLAS.gbtranspose","text":"gbtranspose(A::GBMatrix; kwargs...)::GBMatrix\n\nEagerly evaluated matrix transpose which returns the transposed matrix.\n\nKeywords\n\nmask::Union{Ptr{Nothing}, GBMatrix} = C_NULL: optional mask.\naccum::Union{Ptr{Nothing}, AbstractBinaryOp} = C_NULL: binary accumulator operation   where C[i,j] = accum(C[i,j], T[i,j]) where T is the result of this function before accum is applied.\ndesc::Descriptor = DEFAULTDESC\n\nReturns\n\nC::GBMatrix: output matrix.\n\n\n\n\n\n","category":"function"},{"location":"operations/#Base.kron","page":"Operations","title":"Base.kron","text":"kron(A::GBMatrix, B::GBMatrix, op = BinaryOps.TIMES; kwargs...)::GBMatrix\n\nKronecker product of two matrices using op as the multiplication operator. Does not support GBVectors at this time.\n\nArguments\n\nA::GBMatrix: optionally transposed.\nB::GBMatrix: optionally transposed.\nop::MonoidBinaryOrRig = BinaryOps.TIMES: the binary operation which replaces the arithmetic   multiplication operation from the usual kron function.\n\nKeywords\n\nmask::Union{Nothing, GBMatrix} = nothing: optional mask.\naccum::Union{Nothing, AbstractBinaryOp} = nothing: binary accumulator operation   where C[i,j] = accum(C[i,j], T[i,j]) where T is the result of this function before accum is applied.\ndesc = nothing\n\n\n\n\n\n","category":"function"}]
}
