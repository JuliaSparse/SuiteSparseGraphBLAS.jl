<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Operations · SuiteSparseGraphBLAS</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>SuiteSparseGraphBLAS</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../context_methods/">Context methods</a></li><li><a class="toctext" href="../matrix_and_vector_methods/">Basic matrix &amp; vector methods</a></li><li><a class="toctext" href="../algebra_methods/">Operators &amp; algebraic structures</a></li><li><a class="toctext" href="../desc_methods/">Descriptors</a></li><li><a class="toctext" href="../free_methods/">Freeing objects</a></li><li><a class="toctext" href="../seq_ter/">Sequence termination</a></li><li class="current"><a class="toctext" href>Operations</a><ul class="internal"><li><a class="toctext" href="#GraphBLAS-operations-1">GraphBLAS operations</a></li><li><a class="toctext" href="#Multiplication-1">Multiplication</a></li><li><a class="toctext" href="#Element-wise-multiplication-1">Element-wise multiplication</a></li><li><a class="toctext" href="#Element-wise-addition-1">Element-wise addition</a></li><li><a class="toctext" href="#Extract-1">Extract</a></li><li><a class="toctext" href="#Assign-1">Assign</a></li><li><a class="toctext" href="#Apply-1">Apply</a></li><li><a class="toctext" href="#Reduce-1">Reduce</a></li><li><a class="toctext" href="#Transpose-1">Transpose</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Operations</a></li></ul><a class="edit-page" href="https://github.com/abhinavmehndiratta/SuiteSparseGraphBLAS.jl/blob/master/docs/src/operations.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Operations</span><a class="fa fa-bars" href="#"></a></div></header><h2><a class="nav-anchor" id="GraphBLAS-operations-1" href="#GraphBLAS-operations-1">GraphBLAS operations</a></h2><h2><a class="nav-anchor" id="Multiplication-1" href="#Multiplication-1">Multiplication</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SuiteSparseGraphBLAS.GrB_mxm" href="#SuiteSparseGraphBLAS.GrB_mxm"><code>SuiteSparseGraphBLAS.GrB_mxm</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">GrB_mxm(C, Mask, accum, semiring, A, B, desc)</code></pre><p>Multiplies a matrix with another matrix on a semiring. The result is a matrix.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using SuiteSparseGraphBLAS

julia&gt; GrB_init(GrB_NONBLOCKING)
GrB_SUCCESS::GrB_Info = 0

julia&gt; A = GrB_Matrix{Int64}()
GrB_Matrix{Int64}

julia&gt; GrB_Matrix_new(A, GrB_INT64, 2, 2)
GrB_SUCCESS::GrB_Info = 0

julia&gt; I1 = [0, 1]; J1 = [0, 1]; X1 = [10, 20]; n1 = 2;

julia&gt; GrB_Matrix_build(A, I1, J1, X1, n1, GrB_FIRST_INT64)
GrB_SUCCESS::GrB_Info = 0

julia&gt; B = GrB_Matrix{Int64}()
GrB_Matrix{Int64}

julia&gt; GrB_Matrix_new(B, GrB_INT64, 2, 2)
GrB_SUCCESS::GrB_Info = 0

julia&gt; I2 = [0, 1]; J2 = [0, 1]; X2 = [5, 15]; n2 = 2;

julia&gt; GrB_Matrix_build(B, I2, J2, X2, n2, GrB_FIRST_INT64)
GrB_SUCCESS::GrB_Info = 0

julia&gt; C = GrB_Matrix{Int64}()
GrB_Matrix{Int64}

julia&gt; GrB_Matrix_new(C, GrB_INT64, 2, 2)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_mxm(C, GrB_NULL, GrB_NULL, GxB_PLUS_TIMES_INT64, A, B, GrB_NULL)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_Matrix_extractTuples(C)
([0, 1], [0, 1], [50, 300])</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/abhinavmehndiratta/SuiteSparseGraphBLAS.jl/blob/529c975b2d6a9e2ec2869f225cc8146acac59edb/src/Operations/Multiplication.jl#L1-L47">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SuiteSparseGraphBLAS.GrB_vxm" href="#SuiteSparseGraphBLAS.GrB_vxm"><code>SuiteSparseGraphBLAS.GrB_vxm</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">GrB_vxm(w, mask, accum, semiring, u, A, desc)</code></pre><p>Multiplies a (row) vector with a matrix on an semiring. The result is a vector.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using SuiteSparseGraphBLAS

julia&gt; GrB_init(GrB_NONBLOCKING)
GrB_SUCCESS::GrB_Info = 0

julia&gt; A = GrB_Matrix{Int64}()
GrB_Matrix{Int64}

julia&gt; GrB_Matrix_new(A, GrB_INT64, 2, 2)
GrB_SUCCESS::GrB_Info = 0

julia&gt; I1 = [0, 1]; J1 = [0, 1]; X1 = [10, 20]; n1 = 2;

julia&gt; GrB_Matrix_build(A, I1, J1, X1, n1, GrB_FIRST_INT64)
GrB_SUCCESS::GrB_Info = 0

julia&gt; u = GrB_Vector{Int64}()
GrB_Vector{Int64}

julia&gt; GrB_Vector_new(u, GrB_INT64, 2)
GrB_SUCCESS::GrB_Info = 0

julia&gt; I2 = [0, 1]; X2 = [5, 6]; n2 = 2;

julia&gt; GrB_Vector_build(u, I2, X2, n2, GrB_FIRST_INT64)
GrB_SUCCESS::GrB_Info = 0

julia&gt; w = GrB_Vector{Int64}()
GrB_Vector{Int64}

julia&gt; GrB_Vector_new(w, GrB_INT64, 2)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_vxm(w, GrB_NULL, GrB_NULL, GxB_PLUS_TIMES_INT64, u, A, GrB_NULL)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_Vector_extractTuples(w)
([0, 1], [50, 120])</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/abhinavmehndiratta/SuiteSparseGraphBLAS.jl/blob/529c975b2d6a9e2ec2869f225cc8146acac59edb/src/Operations/Multiplication.jl#L68-L114">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SuiteSparseGraphBLAS.GrB_mxv" href="#SuiteSparseGraphBLAS.GrB_mxv"><code>SuiteSparseGraphBLAS.GrB_mxv</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">GrB_mxv(w, mask, accum, semiring, A, u, desc)</code></pre><p>Multiplies a matrix by a vector on a semiring. The result is a vector.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using SuiteSparseGraphBLAS

julia&gt; GrB_init(GrB_NONBLOCKING)
GrB_SUCCESS::GrB_Info = 0

julia&gt; A = GrB_Matrix{Int64}()
GrB_Matrix{Int64}

julia&gt; GrB_Matrix_new(A, GrB_INT64, 2, 2)
GrB_SUCCESS::GrB_Info = 0

julia&gt; I1 = [0, 0, 1]; J1 = [0, 1, 1]; X1 = [10, 20, 30]; n1 = 3;

julia&gt; GrB_Matrix_build(A, I1, J1, X1, n1, GrB_FIRST_INT64)
GrB_SUCCESS::GrB_Info = 0

julia&gt; u = GrB_Vector{Int64}()
GrB_Vector{Int64}

julia&gt; GrB_Vector_new(u, GrB_INT64, 2)
GrB_SUCCESS::GrB_Info = 0

julia&gt; I2 = [0, 1]; X2 = [5, 6]; n2 = 2;

julia&gt; GrB_Vector_build(u, I2, X2, n2, GrB_FIRST_INT64)
GrB_SUCCESS::GrB_Info = 0

julia&gt; w = GrB_Vector{Int64}()
GrB_Vector{Int64}

julia&gt; GrB_Vector_new(w, GrB_INT64, 2)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_mxv(w, GrB_NULL, GrB_NULL, GxB_PLUS_TIMES_INT64, A, u, GrB_NULL)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_Vector_extractTuples(w)
([0, 1], [170, 180])</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/abhinavmehndiratta/SuiteSparseGraphBLAS.jl/blob/529c975b2d6a9e2ec2869f225cc8146acac59edb/src/Operations/Multiplication.jl#L135-L181">source</a></section><h2><a class="nav-anchor" id="Element-wise-multiplication-1" href="#Element-wise-multiplication-1">Element-wise multiplication</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SuiteSparseGraphBLAS.GrB_eWiseMult" href="#SuiteSparseGraphBLAS.GrB_eWiseMult"><code>SuiteSparseGraphBLAS.GrB_eWiseMult</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">GrB_eWiseMult(C, mask, accum, op, A, B, desc)</code></pre><p>Generic method for element-wise matrix and vector operations: using set intersection.</p><p><code>GrB_eWiseMult</code> computes <code>C&lt;Mask&gt; = accum (C, A .* B)</code>, where pairs of elements in two matrices (or vectors) are pairwise &quot;multiplied&quot; with C(i, j) = mult (A(i, j), B(i, j)). The &quot;multiplication&quot; operator can be any binary operator. The pattern of the result T = A .* B is the set intersection (not union) of A and B. Entries outside of the intersection  are not computed. This is primary difference with <code>GrB_eWiseAdd</code>. The input matrices A and/or B may be transposed first,  via the descriptor. For a semiring, the mult operator is the semiring&#39;s multiply operator; this differs from the  eWiseAdd methods which use the semiring&#39;s add operator instead.</p></div></div><a class="source-link" target="_blank" href="https://github.com/abhinavmehndiratta/SuiteSparseGraphBLAS.jl/blob/529c975b2d6a9e2ec2869f225cc8146acac59edb/src/Operations/Element_wise_multiplication.jl#L1-L12">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SuiteSparseGraphBLAS.GrB_eWiseMult_Vector_Semiring" href="#SuiteSparseGraphBLAS.GrB_eWiseMult_Vector_Semiring"><code>SuiteSparseGraphBLAS.GrB_eWiseMult_Vector_Semiring</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">GrB_eWiseMult_Vector_Semiring(w, mask, accum, semiring, u, v, desc)</code></pre><p>Compute element-wise vector multiplication using semiring. Semiring&#39;s multiply operator is used. <code>w&lt;mask&gt; = accum (w, u .* v)</code></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using SuiteSparseGraphBLAS

julia&gt; GrB_init(GrB_NONBLOCKING)
GrB_SUCCESS::GrB_Info = 0

julia&gt; u = GrB_Vector{Int64}()
GrB_Vector{Int64}

julia&gt; GrB_Vector_new(u, GrB_INT64, 5)
GrB_SUCCESS::GrB_Info = 0

julia&gt; I1 = [0, 2, 4]; X1 = [10, 20, 3]; n1 = 3;

julia&gt; GrB_Vector_build(u, I1, X1, n1, GrB_FIRST_INT64)
GrB_SUCCESS::GrB_Info = 0

julia&gt; v = GrB_Vector{Float64}()
GrB_Vector{Float64}

julia&gt; GrB_Vector_new(v, GrB_FP64, 5)
GrB_SUCCESS::GrB_Info = 0

julia&gt; I2 = [0, 1, 4]; X2 = [1.1, 2.2, 3.3]; n2 = 3;

julia&gt; GrB_Vector_build(v, I2, X2, n2, GrB_FIRST_FP64)
GrB_SUCCESS::GrB_Info = 0

julia&gt; w = GrB_Vector{Float64}()
GrB_Vector{Float64}

julia&gt; GrB_Vector_new(w, GrB_FP64, 5)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_eWiseMult_Vector_Semiring(w, GrB_NULL, GrB_NULL, GxB_PLUS_TIMES_FP64, u, v, GrB_NULL)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_Vector_extractTuples(w)
([0, 4], [11.0, 9.9])</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/abhinavmehndiratta/SuiteSparseGraphBLAS.jl/blob/529c975b2d6a9e2ec2869f225cc8146acac59edb/src/Operations/Element_wise_multiplication.jl#L32-L79">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SuiteSparseGraphBLAS.GrB_eWiseMult_Vector_Monoid" href="#SuiteSparseGraphBLAS.GrB_eWiseMult_Vector_Monoid"><code>SuiteSparseGraphBLAS.GrB_eWiseMult_Vector_Monoid</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">GrB_eWiseMult_Vector_Monoid(w, mask, accum, monoid, u, v, desc)</code></pre><p>Compute element-wise vector multiplication using monoid. <code>w&lt;mask&gt; = accum (w, u .* v)</code></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using SuiteSparseGraphBLAS

julia&gt; GrB_init(GrB_NONBLOCKING)
GrB_SUCCESS::GrB_Info = 0

julia&gt; u = GrB_Vector{Int64}()
GrB_Vector{Int64}

julia&gt; GrB_Vector_new(u, GrB_INT64, 5)
GrB_SUCCESS::GrB_Info = 0

julia&gt; I1 = [0, 2, 4]; X1 = [10, 20, 3]; n1 = 3;

julia&gt; GrB_Vector_build(u, I1, X1, n1, GrB_FIRST_INT64)
GrB_SUCCESS::GrB_Info = 0

julia&gt; v = GrB_Vector{Float64}()
GrB_Vector{Float64}

julia&gt; GrB_Vector_new(v, GrB_FP64, 5)
GrB_SUCCESS::GrB_Info = 0

julia&gt; I2 = [0, 1, 4]; X2 = [1.1, 2.2, 3.3]; n2 = 3;

julia&gt; GrB_Vector_build(v, I2, X2, n2, GrB_FIRST_FP64)
GrB_SUCCESS::GrB_Info = 0

julia&gt; w = GrB_Vector{Float64}()
GrB_Vector{Float64}

julia&gt; GrB_Vector_new(w, GrB_FP64, 5)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_eWiseMult_Vector_Monoid(w, GrB_NULL, GrB_NULL, GxB_MAX_FP64_MONOID, u, v, GrB_NULL)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_Vector_extractTuples(w)
([0, 4], [10.0, 3.3])</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/abhinavmehndiratta/SuiteSparseGraphBLAS.jl/blob/529c975b2d6a9e2ec2869f225cc8146acac59edb/src/Operations/Element_wise_multiplication.jl#L100-L147">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SuiteSparseGraphBLAS.GrB_eWiseMult_Vector_BinaryOp" href="#SuiteSparseGraphBLAS.GrB_eWiseMult_Vector_BinaryOp"><code>SuiteSparseGraphBLAS.GrB_eWiseMult_Vector_BinaryOp</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">GrB_eWiseMult_Vector_BinaryOp(w, mask, accum, mult, u, v, desc)</code></pre><p>Compute element-wise vector multiplication using binary operator. <code>w&lt;mask&gt; = accum (w, u .* v)</code></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using SuiteSparseGraphBLAS

julia&gt; GrB_init(GrB_NONBLOCKING)
GrB_SUCCESS::GrB_Info = 0

julia&gt; u = GrB_Vector{Int64}()
GrB_Vector{Int64}

julia&gt; GrB_Vector_new(u, GrB_INT64, 5)
GrB_SUCCESS::GrB_Info = 0

julia&gt; I1 = [0, 2, 4]; X1 = [10, 20, 30]; n1 = 3;

julia&gt; GrB_Vector_build(u, I1, X1, n1, GrB_FIRST_INT64)
GrB_SUCCESS::GrB_Info = 0

julia&gt; v = GrB_Vector{Float64}()
GrB_Vector{Float64}

julia&gt; GrB_Vector_new(v, GrB_FP64, 5)
GrB_SUCCESS::GrB_Info = 0

julia&gt; I2 = [0, 1, 4]; X2 = [1.1, 2.2, 3.3]; n2 = 3;

julia&gt; GrB_Vector_build(v, I2, X2, n2, GrB_FIRST_FP64)
GrB_SUCCESS::GrB_Info = 0

julia&gt; w = GrB_Vector{Float64}()
GrB_Vector{Float64}

julia&gt; GrB_Vector_new(w, GrB_FP64, 5)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_eWiseMult_Vector_BinaryOp(w, GrB_NULL, GrB_NULL, GrB_TIMES_FP64, u, v, GrB_NULL)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_Vector_extractTuples(w)
([0, 4], [11.0, 99.0])</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/abhinavmehndiratta/SuiteSparseGraphBLAS.jl/blob/529c975b2d6a9e2ec2869f225cc8146acac59edb/src/Operations/Element_wise_multiplication.jl#L168-L215">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SuiteSparseGraphBLAS.GrB_eWiseMult_Matrix_Semiring" href="#SuiteSparseGraphBLAS.GrB_eWiseMult_Matrix_Semiring"><code>SuiteSparseGraphBLAS.GrB_eWiseMult_Matrix_Semiring</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">GrB_eWiseMult_Matrix_Semiring(C, Mask, accum, semiring, A, B, desc)</code></pre><p>Compute element-wise matrix multiplication using semiring. Semiring&#39;s multiply operator is used. <code>C&lt;Mask&gt; = accum (C, A .* B)</code></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using SuiteSparseGraphBLAS

julia&gt; GrB_init(GrB_NONBLOCKING)
GrB_SUCCESS::GrB_Info = 0

julia&gt; A = GrB_Matrix{Int64}()
GrB_Matrix{Int64}

julia&gt; GrB_Matrix_new(A, GrB_INT64, 4, 4)
GrB_SUCCESS::GrB_Info = 0

julia&gt; I1 = [0, 0, 2, 2]; J1 = [1, 2, 0, 2]; X1 = [10, 20, 30, 40]; n1 = 4;

julia&gt; GrB_Matrix_build(A, I1, J1, X1, n1, GrB_FIRST_INT64)
GrB_SUCCESS::GrB_Info = 0

julia&gt; B = GrB_Matrix{Int64}()
GrB_Matrix{Int64}

julia&gt; GrB_Matrix_new(B, GrB_INT64, 4, 4)
GrB_SUCCESS::GrB_Info = 0

julia&gt; I2 = [0, 0, 2]; J2 = [3, 2, 0]; X2 = [15, 16, 17]; n2 = 3;

julia&gt; GrB_Matrix_build(B, I2, J2, X2, n2, GrB_FIRST_INT64)
GrB_SUCCESS::GrB_Info = 0

julia&gt; C = GrB_Matrix{Int64}()
GrB_Matrix{Int64}

julia&gt; GrB_Matrix_new(C, GrB_INT64, 4, 4)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_eWiseMult_Matrix_Semiring(C, GrB_NULL, GrB_NULL, GxB_PLUS_TIMES_INT64, A, B, GrB_NULL)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_Matrix_extractTuples(C)
([0, 2], [2, 0], [320, 510])</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/abhinavmehndiratta/SuiteSparseGraphBLAS.jl/blob/529c975b2d6a9e2ec2869f225cc8146acac59edb/src/Operations/Element_wise_multiplication.jl#L236-L283">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SuiteSparseGraphBLAS.GrB_eWiseMult_Matrix_Monoid" href="#SuiteSparseGraphBLAS.GrB_eWiseMult_Matrix_Monoid"><code>SuiteSparseGraphBLAS.GrB_eWiseMult_Matrix_Monoid</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">GrB_eWiseMult_Matrix_Monoid(C, Mask, accum, monoid, A, B, desc)</code></pre><p>Compute element-wise matrix multiplication using monoid. <code>C&lt;Mask&gt; = accum (C, A .* B)</code></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using SuiteSparseGraphBLAS

julia&gt; GrB_init(GrB_NONBLOCKING)
GrB_SUCCESS::GrB_Info = 0

julia&gt; A = GrB_Matrix{Int64}()
GrB_Matrix{Int64}

julia&gt; GrB_Matrix_new(A, GrB_INT64, 4, 4)
GrB_SUCCESS::GrB_Info = 0

julia&gt; I1 = [0, 0, 2, 2]; J1 = [1, 2, 0, 2]; X1 = [10, 20, 30, 40]; n1 = 4;

julia&gt; GrB_Matrix_build(A, I1, J1, X1, n1, GrB_FIRST_INT64)
GrB_SUCCESS::GrB_Info = 0

julia&gt; B = GrB_Matrix{Int64}()
GrB_Matrix{Int64}

julia&gt; GrB_Matrix_new(B, GrB_INT64, 4, 4)
GrB_SUCCESS::GrB_Info = 0

julia&gt; I2 = [0, 0, 2]; J2 = [3, 2, 0]; X2 = [15, 16, 17]; n2 = 3;

julia&gt; GrB_Matrix_build(B, I2, J2, X2, n2, GrB_FIRST_INT64)
GrB_SUCCESS::GrB_Info = 0

julia&gt; C = GrB_Matrix{Int64}()
GrB_Matrix{Int64}

julia&gt; GrB_Matrix_new(C, GrB_INT64, 4, 4)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_eWiseMult_Matrix_Monoid(C, GrB_NULL, GrB_NULL, GxB_PLUS_INT64_MONOID, A, B, GrB_NULL)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_Matrix_extractTuples(C)
([0, 2], [2, 0], [36, 47])</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/abhinavmehndiratta/SuiteSparseGraphBLAS.jl/blob/529c975b2d6a9e2ec2869f225cc8146acac59edb/src/Operations/Element_wise_multiplication.jl#L304-L351">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SuiteSparseGraphBLAS.GrB_eWiseMult_Matrix_BinaryOp" href="#SuiteSparseGraphBLAS.GrB_eWiseMult_Matrix_BinaryOp"><code>SuiteSparseGraphBLAS.GrB_eWiseMult_Matrix_BinaryOp</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">GrB_eWiseMult_Matrix_BinaryOp(C, Mask, accum, mult, A, B, desc)</code></pre><p>Compute element-wise matrix multiplication using binary operator. <code>C&lt;Mask&gt; = accum (C, A .* B)</code></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using SuiteSparseGraphBLAS

julia&gt; GrB_init(GrB_NONBLOCKING)
GrB_SUCCESS::GrB_Info = 0

julia&gt; A = GrB_Matrix{Int64}()
GrB_Matrix{Int64}

julia&gt; GrB_Matrix_new(A, GrB_INT64, 4, 4)
GrB_SUCCESS::GrB_Info = 0

julia&gt; I1 = [0, 0, 2, 2]; J1 = [1, 2, 0, 2]; X1 = [10, 20, 30, 40]; n1 = 4;

julia&gt; GrB_Matrix_build(A, I1, J1, X1, n1, GrB_FIRST_INT64)
GrB_SUCCESS::GrB_Info = 0

julia&gt; B = GrB_Matrix{Int64}()
GrB_Matrix{Int64}

julia&gt; GrB_Matrix_new(B, GrB_INT64, 4, 4)
GrB_SUCCESS::GrB_Info = 0

julia&gt; I2 = [0, 0, 2]; J2 = [3, 2, 0]; X2 = [15, 16, 17]; n2 = 3;

julia&gt; GrB_Matrix_build(B, I2, J2, X2, n2, GrB_FIRST_INT64)
GrB_SUCCESS::GrB_Info = 0

julia&gt; C = GrB_Matrix{Int64}()
GrB_Matrix{Int64}

julia&gt; GrB_Matrix_new(C, GrB_INT64, 4, 4)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_eWiseMult_Matrix_BinaryOp(C, GrB_NULL, GrB_NULL, GrB_PLUS_INT64, A, B, GrB_NULL)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_Matrix_extractTuples(C)
([0, 2], [2, 0], [36, 47])</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/abhinavmehndiratta/SuiteSparseGraphBLAS.jl/blob/529c975b2d6a9e2ec2869f225cc8146acac59edb/src/Operations/Element_wise_multiplication.jl#L372-L419">source</a></section><h2><a class="nav-anchor" id="Element-wise-addition-1" href="#Element-wise-addition-1">Element-wise addition</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SuiteSparseGraphBLAS.GrB_eWiseAdd" href="#SuiteSparseGraphBLAS.GrB_eWiseAdd"><code>SuiteSparseGraphBLAS.GrB_eWiseAdd</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">GrB_eWiseAdd(C, mask, accum, op, A, B, desc)</code></pre><p>Generic method for element-wise matrix and vector operations: using set union.</p><p><code>GrB_eWiseAdd</code> computes <code>C&lt;Mask&gt; = accum (C, A + B)</code>, where pairs of elements in two matrices (or two vectors) are pairwise &quot;added&quot;. The &quot;add&quot; operator can be any binary operator. With the plus operator, this is the same matrix addition in conventional linear algebra. The pattern of the result T = A + B is the set union of A and B. Entries outside of the union are not computed. That is, if both A(i, j) and B(i, j) are present in the pattern of A and B, then T(i, j) = A(i, j) &quot;+&quot; B(i, j). If only A(i, j) is present then T(i, j) = A (i, j) and the &quot;+&quot; operator is not used. Likewise, if only B(i, j) is in the pattern of B but A(i, j) is not in the pattern of A, then T(i, j) = B(i, j). For a semiring, the mult operator is the semiring&#39;s add operator.</p></div></div><a class="source-link" target="_blank" href="https://github.com/abhinavmehndiratta/SuiteSparseGraphBLAS.jl/blob/529c975b2d6a9e2ec2869f225cc8146acac59edb/src/Operations/Element_wise_addition.jl#L1-L14">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SuiteSparseGraphBLAS.GrB_eWiseAdd_Vector_Semiring" href="#SuiteSparseGraphBLAS.GrB_eWiseAdd_Vector_Semiring"><code>SuiteSparseGraphBLAS.GrB_eWiseAdd_Vector_Semiring</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">GrB_eWiseAdd_Vector_Semiring(w, mask, accum, semiring, u, v, desc)</code></pre><p>Compute element-wise vector addition using semiring. Semiring&#39;s add operator is used. <code>w&lt;mask&gt; = accum (w, u + v)</code></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using SuiteSparseGraphBLAS

julia&gt; GrB_init(GrB_NONBLOCKING)
GrB_SUCCESS::GrB_Info = 0

julia&gt; u = GrB_Vector{Int64}()
GrB_Vector{Int64}

julia&gt; GrB_Vector_new(u, GrB_INT64, 5)
GrB_SUCCESS::GrB_Info = 0

julia&gt; I1 = [0, 2, 4]; X1 = [10, 20, 3]; n1 = 3;

julia&gt; GrB_Vector_build(u, I1, X1, n1, GrB_FIRST_INT64)
GrB_SUCCESS::GrB_Info = 0

julia&gt; v = GrB_Vector{Float64}()
GrB_Vector{Float64}

julia&gt; GrB_Vector_new(v, GrB_FP64, 5)
GrB_SUCCESS::GrB_Info = 0

julia&gt; I2 = [0, 1, 4]; X2 = [1.1, 2.2, 3.3]; n2 = 3;

julia&gt; GrB_Vector_build(v, I2, X2, n2, GrB_FIRST_FP64)
GrB_SUCCESS::GrB_Info = 0

julia&gt; w = GrB_Vector{Float64}()
GrB_Vector{Float64}

julia&gt; GrB_Vector_new(w, GrB_FP64, 5)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_eWiseAdd_Vector_Semiring(w, GrB_NULL, GrB_NULL, GxB_PLUS_TIMES_FP64, u, v, GrB_NULL)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_Vector_extractTuples(w)
([0, 1, 2, 4], [11.1, 2.2, 20.0, 6.3])</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/abhinavmehndiratta/SuiteSparseGraphBLAS.jl/blob/529c975b2d6a9e2ec2869f225cc8146acac59edb/src/Operations/Element_wise_addition.jl#L34-L81">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SuiteSparseGraphBLAS.GrB_eWiseAdd_Vector_Monoid" href="#SuiteSparseGraphBLAS.GrB_eWiseAdd_Vector_Monoid"><code>SuiteSparseGraphBLAS.GrB_eWiseAdd_Vector_Monoid</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">GrB_eWiseAdd_Vector_Monoid(w, mask, accum, monoid, u, v, desc)</code></pre><p>Compute element-wise vector addition using monoid. <code>w&lt;mask&gt; = accum (w, u + v)</code></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using SuiteSparseGraphBLAS

julia&gt; GrB_init(GrB_NONBLOCKING)
GrB_SUCCESS::GrB_Info = 0

julia&gt; u = GrB_Vector{Int64}()
GrB_Vector{Int64}

julia&gt; GrB_Vector_new(u, GrB_INT64, 5)
GrB_SUCCESS::GrB_Info = 0

julia&gt; I1 = [0, 2, 4]; X1 = [10, 20, 3]; n1 = 3;

julia&gt; GrB_Vector_build(u, I1, X1, n1, GrB_FIRST_INT64)
GrB_SUCCESS::GrB_Info = 0

julia&gt; v = GrB_Vector{Float64}()
GrB_Vector{Float64}

julia&gt; GrB_Vector_new(v, GrB_FP64, 5)
GrB_SUCCESS::GrB_Info = 0

julia&gt; I2 = [0, 1, 4]; X2 = [1.1, 2.2, 3.3]; n2 = 3;

julia&gt; GrB_Vector_build(v, I2, X2, n2, GrB_FIRST_FP64)
GrB_SUCCESS::GrB_Info = 0

julia&gt; w = GrB_Vector{Float64}()
GrB_Vector{Float64}

julia&gt; GrB_Vector_new(w, GrB_FP64, 5)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_eWiseAdd_Vector_Monoid(w, GrB_NULL, GrB_NULL, GxB_MAX_FP64_MONOID, u, v, GrB_NULL)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_Vector_extractTuples(w)
([0, 1, 2, 4], [10.0, 2.2, 20.0, 3.3])</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/abhinavmehndiratta/SuiteSparseGraphBLAS.jl/blob/529c975b2d6a9e2ec2869f225cc8146acac59edb/src/Operations/Element_wise_addition.jl#L102-L149">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SuiteSparseGraphBLAS.GrB_eWiseAdd_Vector_BinaryOp" href="#SuiteSparseGraphBLAS.GrB_eWiseAdd_Vector_BinaryOp"><code>SuiteSparseGraphBLAS.GrB_eWiseAdd_Vector_BinaryOp</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">GrB_eWiseAdd_Vector_BinaryOp(w, mask, accum, add, u, v, desc)</code></pre><p>Compute element-wise vector addition using binary operator. <code>w&lt;mask&gt; = accum (w, u + v)</code></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using SuiteSparseGraphBLAS

julia&gt; GrB_init(GrB_NONBLOCKING)
GrB_SUCCESS::GrB_Info = 0

julia&gt; u = GrB_Vector{Int64}()
GrB_Vector{Int64}

julia&gt; GrB_Vector_new(u, GrB_INT64, 5)
GrB_SUCCESS::GrB_Info = 0

julia&gt; I1 = [0, 2, 4]; X1 = [10, 20, 3]; n1 = 3;

julia&gt; GrB_Vector_build(u, I1, X1, n1, GrB_FIRST_INT64)
GrB_SUCCESS::GrB_Info = 0

julia&gt; v = GrB_Vector{Float64}()
GrB_Vector{Float64}

julia&gt; GrB_Vector_new(v, GrB_FP64, 5)
GrB_SUCCESS::GrB_Info = 0

julia&gt; I2 = [0, 1, 4]; X2 = [1.1, 2.2, 3.3]; n2 = 3;

julia&gt; GrB_Vector_build(v, I2, X2, n2, GrB_FIRST_FP64)
GrB_SUCCESS::GrB_Info = 0

julia&gt; w = GrB_Vector{Float64}()
GrB_Vector{Float64}

julia&gt; GrB_Vector_new(w, GrB_FP64, 5)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_eWiseAdd_Vector_BinaryOp(w, GrB_NULL, GrB_NULL, GrB_PLUS_FP64, u, v, GrB_NULL)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_Vector_extractTuples(w)
([0, 1, 2, 4], [11.1, 2.2, 20.0, 6.3])</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/abhinavmehndiratta/SuiteSparseGraphBLAS.jl/blob/529c975b2d6a9e2ec2869f225cc8146acac59edb/src/Operations/Element_wise_addition.jl#L170-L217">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SuiteSparseGraphBLAS.GrB_eWiseAdd_Matrix_Semiring" href="#SuiteSparseGraphBLAS.GrB_eWiseAdd_Matrix_Semiring"><code>SuiteSparseGraphBLAS.GrB_eWiseAdd_Matrix_Semiring</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">GrB_eWiseAdd_Matrix_Semiring(C, Mask, accum, semiring, A, B, desc)</code></pre><p>Compute element-wise matrix addition using semiring. Semiring&#39;s add operator is used. <code>C&lt;Mask&gt; = accum (C, A + B)</code></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using SuiteSparseGraphBLAS

julia&gt; GrB_init(GrB_NONBLOCKING)
GrB_SUCCESS::GrB_Info = 0

julia&gt; A = GrB_Matrix{Int64}()
GrB_Matrix{Int64}

julia&gt; GrB_Matrix_new(A, GrB_INT64, 4, 4)
GrB_SUCCESS::GrB_Info = 0

julia&gt; I1 = [0, 0, 2, 2]; J1 = [1, 2, 0, 2]; X1 = [10, 20, 30, 40]; n1 = 4;

julia&gt; GrB_Matrix_build(A, I1, J1, X1, n1, GrB_FIRST_INT64)
GrB_SUCCESS::GrB_Info = 0

julia&gt; B = GrB_Matrix{Int64}()
GrB_Matrix{Int64}

julia&gt; GrB_Matrix_new(B, GrB_INT64, 4, 4)
GrB_SUCCESS::GrB_Info = 0

julia&gt; I2 = [0, 0, 2]; J2 = [3, 2, 0]; X2 = [15, 16, 17]; n2 = 3;

julia&gt; GrB_Matrix_build(B, I2, J2, X2, n2, GrB_FIRST_INT64)
GrB_SUCCESS::GrB_Info = 0

julia&gt; C = GrB_Matrix{Int64}()
GrB_Matrix{Int64}

julia&gt; GrB_Matrix_new(C, GrB_INT64, 4, 4)
GrB_SUCCESS::GrB_Info = 0

julia&gt; mask = GrB_Matrix{Bool}()
GrB_Matrix{Bool}

julia&gt; GrB_Matrix_new(mask, GrB_BOOL, 4, 4)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_Matrix_build(mask, [0, 0], [1, 2], [true, true], 2, GrB_FIRST_BOOL)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_eWiseAdd_Matrix_Monoid(C, mask, GrB_NULL, GxB_PLUS_INT64_MONOID, A, B, GrB_NULL)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_Matrix_extractTuples(C)
([0, 0], [1, 2], [10, 36])</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/abhinavmehndiratta/SuiteSparseGraphBLAS.jl/blob/529c975b2d6a9e2ec2869f225cc8146acac59edb/src/Operations/Element_wise_addition.jl#L238-L294">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SuiteSparseGraphBLAS.GrB_eWiseAdd_Matrix_Monoid" href="#SuiteSparseGraphBLAS.GrB_eWiseAdd_Matrix_Monoid"><code>SuiteSparseGraphBLAS.GrB_eWiseAdd_Matrix_Monoid</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">GrB_eWiseAdd_Matrix_Monoid(C, Mask, accum, monoid, A, B, desc)</code></pre><p>Compute element-wise matrix addition using monoid. <code>C&lt;Mask&gt; = accum (C, A + B)</code></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using SuiteSparseGraphBLAS

julia&gt; GrB_init(GrB_NONBLOCKING)
GrB_SUCCESS::GrB_Info = 0

julia&gt; A = GrB_Matrix{Int64}()
GrB_Matrix{Int64}

julia&gt; GrB_Matrix_new(A, GrB_INT64, 4, 4)
GrB_SUCCESS::GrB_Info = 0

julia&gt; I1 = [0, 0, 2, 2]; J1 = [1, 2, 0, 2]; X1 = [10, 20, 30, 40]; n1 = 4;

julia&gt; GrB_Matrix_build(A, I1, J1, X1, n1, GrB_FIRST_INT64)
GrB_SUCCESS::GrB_Info = 0

julia&gt; B = GrB_Matrix{Int64}()
GrB_Matrix{Int64}

julia&gt; GrB_Matrix_new(B, GrB_INT64, 4, 4)
GrB_SUCCESS::GrB_Info = 0

julia&gt; I2 = [0, 0, 2]; J2 = [3, 2, 0]; X2 = [15, 16, 17]; n2 = 3;

julia&gt; GrB_Matrix_build(B, I2, J2, X2, n2, GrB_FIRST_INT64)
GrB_SUCCESS::GrB_Info = 0

julia&gt; C = GrB_Matrix{Int64}()
GrB_Matrix{Int64}

julia&gt; GrB_Matrix_new(C, GrB_INT64, 4, 4)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_eWiseAdd_Matrix_Monoid(C, GrB_NULL, GrB_NULL, GxB_PLUS_INT64_MONOID, A, B, GrB_NULL)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_Matrix_extractTuples(C)
([0, 0, 0, 2, 2], [1, 2, 3, 0, 2], [10, 36, 15, 47, 40])</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/abhinavmehndiratta/SuiteSparseGraphBLAS.jl/blob/529c975b2d6a9e2ec2869f225cc8146acac59edb/src/Operations/Element_wise_addition.jl#L315-L362">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SuiteSparseGraphBLAS.GrB_eWiseAdd_Matrix_BinaryOp" href="#SuiteSparseGraphBLAS.GrB_eWiseAdd_Matrix_BinaryOp"><code>SuiteSparseGraphBLAS.GrB_eWiseAdd_Matrix_BinaryOp</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">GrB_eWiseAdd_Matrix_BinaryOp(C, Mask, accum, add, A, B, desc)</code></pre><p>Compute element-wise matrix addition using binary operator. <code>C&lt;Mask&gt; = accum (C, A + B)</code></p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using SuiteSparseGraphBLAS

julia&gt; GrB_init(GrB_NONBLOCKING)
GrB_SUCCESS::GrB_Info = 0

julia&gt; A = GrB_Matrix{Int64}()
GrB_Matrix{Int64}

julia&gt; GrB_Matrix_new(A, GrB_INT64, 4, 4)
GrB_SUCCESS::GrB_Info = 0

julia&gt; I1 = [0, 0, 2, 2]; J1 = [1, 2, 0, 2]; X1 = [10, 20, 30, 40]; n1 = 4;

julia&gt; GrB_Matrix_build(A, I1, J1, X1, n1, GrB_FIRST_INT64)
GrB_SUCCESS::GrB_Info = 0

julia&gt; B = GrB_Matrix{Int64}()
GrB_Matrix{Int64}

julia&gt; GrB_Matrix_new(B, GrB_INT64, 4, 4)
GrB_SUCCESS::GrB_Info = 0

julia&gt; I2 = [0, 0, 2]; J2 = [3, 2, 0]; X2 = [15, 16, 17]; n2 = 3;

julia&gt; GrB_Matrix_build(B, I2, J2, X2, n2, GrB_FIRST_INT64)
GrB_SUCCESS::GrB_Info = 0

julia&gt; C = GrB_Matrix{Int64}()
GrB_Matrix{Int64}

julia&gt; GrB_Matrix_new(C, GrB_INT64, 4, 4)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_eWiseAdd_Matrix_BinaryOp(C, GrB_NULL, GrB_NULL, GrB_PLUS_INT64, A, B, GrB_NULL)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_Matrix_extractTuples(C)
([0, 0, 0, 2, 2], [1, 2, 3, 0, 2], [10, 36, 15, 47, 40])</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/abhinavmehndiratta/SuiteSparseGraphBLAS.jl/blob/529c975b2d6a9e2ec2869f225cc8146acac59edb/src/Operations/Element_wise_addition.jl#L383-L430">source</a></section><h2><a class="nav-anchor" id="Extract-1" href="#Extract-1">Extract</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SuiteSparseGraphBLAS.GrB_extract" href="#SuiteSparseGraphBLAS.GrB_extract"><code>SuiteSparseGraphBLAS.GrB_extract</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">GrB_extract(arg1, Mask, accum, arg4, ...)</code></pre><p>Generic matrix/vector extraction.</p></div></div><a class="source-link" target="_blank" href="https://github.com/abhinavmehndiratta/SuiteSparseGraphBLAS.jl/blob/529c975b2d6a9e2ec2869f225cc8146acac59edb/src/Operations/Extract.jl#L1-L5">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SuiteSparseGraphBLAS.GrB_Vector_extract" href="#SuiteSparseGraphBLAS.GrB_Vector_extract"><code>SuiteSparseGraphBLAS.GrB_Vector_extract</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">GrB_Vector_extract(w, mask, accum, u, I, ni, desc)</code></pre><p>Extract a sub-vector from a larger vector as specified by a set of indices. The result is a vector whose size is equal to the number of indices.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using SuiteSparseGraphBLAS

julia&gt; GrB_init(GrB_NONBLOCKING)
GrB_SUCCESS::GrB_Info = 0

julia&gt; V = GrB_Vector{Int64}()
GrB_Vector{Int64}

julia&gt; GrB_Vector_new(V, GrB_INT64, 5)
GrB_SUCCESS::GrB_Info = 0

julia&gt; I = [1, 2, 4]; X = [15, 32, 84]; n = 3;

julia&gt; GrB_Vector_build(V, I, X, n, GrB_FIRST_INT64)
GrB_SUCCESS::GrB_Info = 0

julia&gt; @GxB_Vector_fprint(V, GxB_COMPLETE)

GraphBLAS vector: V
nrows: 5 ncols: 1 max # entries: 3
format: standard CSC vlen: 5 nvec_nonempty: 1 nvec: 1 plen: 1 vdim: 1
hyper_ratio 0.0625
GraphBLAS type:  int64_t size: 8
number of entries: 3
column: 0 : 3 entries [0:2]
    row 1: int64 15
    row 2: int64 32
    row 4: int64 84


julia&gt; W = GrB_Vector{Int64}()
GrB_Vector{Int64}

julia&gt; GrB_Vector_new(W, GrB_INT64, 2)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_Vector_extract(W, GrB_NULL, GrB_NULL, V, [1, 4], 2, GrB_NULL)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_Vector_extractTuples(W)[2]
2-element Array{Int64,1}:
 15
 84</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/abhinavmehndiratta/SuiteSparseGraphBLAS.jl/blob/529c975b2d6a9e2ec2869f225cc8146acac59edb/src/Operations/Extract.jl#L18-L70">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SuiteSparseGraphBLAS.GrB_Matrix_extract" href="#SuiteSparseGraphBLAS.GrB_Matrix_extract"><code>SuiteSparseGraphBLAS.GrB_Matrix_extract</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">GrB_Matrix_extract(C, Mask, accum, A, I, ni, J, nj, desc)</code></pre><p>Extract a sub-matrix from a larger matrix as specified by a set of row indices and a set of column indices. The result is a matrix whose size is equal to size of the sets of indices.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using SuiteSparseGraphBLAS

julia&gt; GrB_init(GrB_NONBLOCKING)
GrB_SUCCESS::GrB_Info = 0

julia&gt; MAT = GrB_Matrix{Int8}()
GrB_Matrix{Int8}

julia&gt; GrB_Matrix_new(MAT, GrB_INT8, 4, 4)
GrB_SUCCESS::GrB_Info = 0

julia&gt; I = [1, 2, 2, 2, 3]; J = [1, 2, 1, 3, 3]; X = Int8[2, 3, 4, 5, 6]; n = 5;


julia&gt; GrB_Matrix_build(MAT, I, J, X, n, GrB_FIRST_INT8)
GrB_SUCCESS::GrB_Info = 0

julia&gt; @GxB_Matrix_fprint(MAT, GxB_COMPLETE)

GraphBLAS matrix: MAT 
nrows: 4 ncols: 4 max # entries: 5
format: standard CSR vlen: 4 nvec_nonempty: 3 nvec: 4 plen: 4 vdim: 4
hyper_ratio 0.0625
GraphBLAS type:  int8_t size: 1
number of entries: 5 
row: 1 : 1 entries [0:0]
    column 1: int8 2
row: 2 : 3 entries [1:3]
    column 1: int8 4
    column 2: int8 3
    column 3: int8 5
row: 3 : 1 entries [4:4]
    column 3: int8 6


julia&gt; OUT = GrB_Matrix{Int8}()
GrB_Matrix{Int8}

julia&gt; GrB_Matrix_new(OUT, GrB_INT8, 2, 2)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_Matrix_extract(OUT, GrB_NULL, GrB_NULL, MAT, [1, 3], 2, [1, 3], 2, GrB_NULL)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_Matrix_extractTuples(OUT)[3]
2-element Array{Int8,1}:
 2
 6</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/abhinavmehndiratta/SuiteSparseGraphBLAS.jl/blob/529c975b2d6a9e2ec2869f225cc8146acac59edb/src/Operations/Extract.jl#L91-L148">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SuiteSparseGraphBLAS.GrB_Col_extract" href="#SuiteSparseGraphBLAS.GrB_Col_extract"><code>SuiteSparseGraphBLAS.GrB_Col_extract</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">GrB_Col_extract(w, mask, accum, A, I, ni, j, desc)</code></pre><p>Extract from one column of a matrix into a vector. With the transpose descriptor for the source matrix,  elements of an arbitrary row of the matrix can be extracted with this function as well.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using SuiteSparseGraphBLAS

julia&gt; GrB_init(GrB_NONBLOCKING)
GrB_SUCCESS::GrB_Info = 0

julia&gt; MAT = GrB_Matrix{Int8}()
GrB_Matrix{Int8}

julia&gt; GrB_Matrix_new(MAT, GrB_INT8, 4, 4)
GrB_SUCCESS::GrB_Info = 0

julia&gt; I = [1, 2, 2, 2, 3]; J = [1, 2, 1, 3, 3]; X = Int8[23, 34, 43, 57, 61]; n = 5;

julia&gt; GrB_Matrix_build(MAT, I, J, X, n, GrB_FIRST_INT8)
GrB_SUCCESS::GrB_Info = 0

julia&gt; @GxB_Matrix_fprint(MAT, GxB_COMPLETE)

GraphBLAS matrix: MAT 
nrows: 4 ncols: 4 max # entries: 5
format: standard CSR vlen: 4 nvec_nonempty: 3 nvec: 4 plen: 4 vdim: 4
hyper_ratio 0.0625
GraphBLAS type:  int8_t size: 1
number of entries: 5 
row: 1 : 1 entries [0:0]
    column 1: int8 23
row: 2 : 3 entries [1:3]
    column 1: int8 43
    column 2: int8 34
    column 3: int8 57
row: 3 : 1 entries [4:4]
    column 3: int8 61


julia&gt; desc = GrB_Descriptor()
GrB_Descriptor

julia&gt; GrB_Descriptor_new(desc)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_Descriptor_set(desc, GrB_INP0, GrB_TRAN) # descriptor to transpose first input
GrB_SUCCESS::GrB_Info = 0

julia&gt; out = GrB_Vector{Int8}()
GrB_Vector{Int8}

julia&gt; GrB_Vector_new(out, GrB_INT8, 3)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_Col_extract(out, GrB_NULL, GrB_NULL, MAT, [1, 2, 3], 3, 2, desc) # extract elements of row 2
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_Vector_extractTuples(out)[2]
3-element Array{Int8,1}:
 43
 34
 57</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/abhinavmehndiratta/SuiteSparseGraphBLAS.jl/blob/529c975b2d6a9e2ec2869f225cc8146acac59edb/src/Operations/Extract.jl#L171-L237">source</a></section><h2><a class="nav-anchor" id="Assign-1" href="#Assign-1">Assign</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SuiteSparseGraphBLAS.GrB_assign" href="#SuiteSparseGraphBLAS.GrB_assign"><code>SuiteSparseGraphBLAS.GrB_assign</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">GrB_assign(arg1, Mask, accum, arg4, arg5, ...)</code></pre><p>Generic method for submatrix/subvector assignment.</p></div></div><a class="source-link" target="_blank" href="https://github.com/abhinavmehndiratta/SuiteSparseGraphBLAS.jl/blob/529c975b2d6a9e2ec2869f225cc8146acac59edb/src/Operations/Assign.jl#L1-L5">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SuiteSparseGraphBLAS.GrB_Vector_assign" href="#SuiteSparseGraphBLAS.GrB_Vector_assign"><code>SuiteSparseGraphBLAS.GrB_Vector_assign</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">GrB_Vector_assign(w, mask, accum, u, I, ni, desc)</code></pre><p>Assign values from one GraphBLAS vector to a subset of a vector as specified by a set of  indices. The size of the input vector is the same size as the index array provided.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using SuiteSparseGraphBLAS

julia&gt; GrB_init(GrB_NONBLOCKING)
GrB_SUCCESS::GrB_Info = 0

julia&gt; w = GrB_Vector{Int64}()
GrB_Vector{Int64}

julia&gt; GrB_Vector_new(w, GrB_INT64, 5)
GrB_SUCCESS::GrB_Info = 0

julia&gt; u = GrB_Vector{Int64}()
GrB_Vector{Int64}

julia&gt; GrB_Vector_new(u, GrB_INT64, 2)
GrB_SUCCESS::GrB_Info = 0

julia&gt; I = [0, 1]; X = [10, 20]; n = 2;

julia&gt; GrB_Vector_build(u, I, X, n, GrB_FIRST_INT64)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_Vector_assign(w, GrB_NULL, GrB_NULL, u, [2, 4], 2, GrB_NULL)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_Vector_extractTuples(w)
([2, 4], [10, 20])</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/abhinavmehndiratta/SuiteSparseGraphBLAS.jl/blob/529c975b2d6a9e2ec2869f225cc8146acac59edb/src/Operations/Assign.jl#L28-L64">source</a><div><div><pre><code class="language-none">GrB_Vector_assign(w, mask, accum, x, I, ni, desc)</code></pre><p>Assign the same value to a specified subset of vector elements. With the use of <code>GrB_ALL</code>, the entire destination vector can be filled with the constant.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using SuiteSparseGraphBLAS

julia&gt; GrB_init(GrB_NONBLOCKING)
GrB_SUCCESS::GrB_Info = 0

julia&gt; w = GrB_Vector{Float64}()
GrB_Vector{Float64}

julia&gt; GrB_Vector_new(w, GrB_FP64, 4)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_Vector_assign(w, GrB_NULL, GrB_NULL, 2.3, [0, 3], 2, GrB_NULL)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_Vector_extractTuples(w)
([0, 3], [2.3, 2.3])</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/abhinavmehndiratta/SuiteSparseGraphBLAS.jl/blob/529c975b2d6a9e2ec2869f225cc8146acac59edb/src/Operations/Assign.jl#L272-L297">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SuiteSparseGraphBLAS.GrB_Matrix_assign" href="#SuiteSparseGraphBLAS.GrB_Matrix_assign"><code>SuiteSparseGraphBLAS.GrB_Matrix_assign</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">GrB_Matrix_assign(C, Mask, accum, A, I, ni, J, nj, desc)</code></pre><p>Assign values from one GraphBLAS matrix to a subset of a matrix as specified by a set of  indices.  The dimensions of the input matrix are the same size as the row and column index arrays provided.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using SuiteSparseGraphBLAS

julia&gt; GrB_init(GrB_NONBLOCKING)
GrB_SUCCESS::GrB_Info = 0

julia&gt; A = GrB_Matrix{Int64}()
GrB_Matrix{Int64}

julia&gt; GrB_Matrix_new(A, GrB_INT64, 4, 4)
GrB_SUCCESS::GrB_Info = 0

julia&gt; I = [0, 0, 2, 2]; J = [1, 2, 0, 2]; X = [10, 20, 30, 40]; n = 4;

julia&gt; GrB_Matrix_build(A, I, J, X, n, GrB_FIRST_INT64)
GrB_SUCCESS::GrB_Info = 0

julia&gt; C = GrB_Matrix{Int64}()
GrB_Matrix{Int64}

julia&gt; GrB_Matrix_new(C, GrB_INT64, 4, 4)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_Matrix_assign(C, GrB_NULL, GrB_NULL, A, GrB_ALL, 4, GrB_ALL, 4, GrB_NULL)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_Matrix_extractTuples(C)
([0, 0, 2, 2], [1, 2, 0, 2], [10, 20, 30, 40])</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/abhinavmehndiratta/SuiteSparseGraphBLAS.jl/blob/529c975b2d6a9e2ec2869f225cc8146acac59edb/src/Operations/Assign.jl#L85-L121">source</a><div><div><pre><code class="language-none">GrB_Matrix_assign(C, Mask, accum, x, I, ni, J, nj, desc)</code></pre><p>Assign the same value to a specified subset of matrix elements. With the use of <code>GrB_ALL</code>, the entire destination matrix can be filled with the constant.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using SuiteSparseGraphBLAS

julia&gt; GrB_init(GrB_NONBLOCKING)
GrB_SUCCESS::GrB_Info = 0

julia&gt; A = GrB_Matrix{Bool}()
GrB_Matrix{Bool}

julia&gt; GrB_Matrix_new(A, GrB_BOOL, 4, 4)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_Matrix_assign(A, GrB_NULL, GrB_NULL, true, [0, 1], 2, [0, 1], 2, GrB_NULL)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_Matrix_extractTuples(A)
([0, 0, 1, 1], [0, 1, 0, 1], Bool[true, true, true, true])</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/abhinavmehndiratta/SuiteSparseGraphBLAS.jl/blob/529c975b2d6a9e2ec2869f225cc8146acac59edb/src/Operations/Assign.jl#L360-L385">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SuiteSparseGraphBLAS.GrB_Col_assign" href="#SuiteSparseGraphBLAS.GrB_Col_assign"><code>SuiteSparseGraphBLAS.GrB_Col_assign</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">GrB_Col_assign(C, Mask, accum, u, I, ni, j, desc)</code></pre><p>Assign the contents a vector to a subset of elements in one column of a matrix. Note that since the output cannot be transposed, a different variant of assign is provided  to assign to a row of matrix.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using SuiteSparseGraphBLAS

julia&gt; GrB_init(GrB_NONBLOCKING)
GrB_SUCCESS::GrB_Info = 0

julia&gt; A = GrB_Matrix{Int64}()
GrB_Matrix{Int64}

julia&gt; GrB_Matrix_new(A, GrB_INT64, 4, 4)
GrB_SUCCESS::GrB_Info = 0

julia&gt; I = [0, 0, 2, 2]; J = [1, 2, 0, 2]; X = [10, 20, 30, 40]; n = 4;

julia&gt; GrB_Matrix_build(A, I, J, X, n, GrB_FIRST_INT64)
GrB_SUCCESS::GrB_Info = 0

julia&gt; u = GrB_Vector{Int64}()
GrB_Vector{Int64}

julia&gt; GrB_Vector_new(u, GrB_INT64, 2)
GrB_SUCCESS::GrB_Info = 0

julia&gt; I2 = [0, 1]; X2 = [5, 6]; n2 = 2;

julia&gt; GrB_Vector_build(u, I2, X2, n2, GrB_FIRST_INT64)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_Col_assign(A, GrB_NULL, GrB_NULL, u, [1, 2], 2, 0, GrB_NULL)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_Matrix_extractTuples(A)
([0, 0, 1, 2, 2], [1, 2, 0, 0, 2], [10, 20, 5, 6, 40])</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/abhinavmehndiratta/SuiteSparseGraphBLAS.jl/blob/529c975b2d6a9e2ec2869f225cc8146acac59edb/src/Operations/Assign.jl#L144-L186">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SuiteSparseGraphBLAS.GrB_Row_assign" href="#SuiteSparseGraphBLAS.GrB_Row_assign"><code>SuiteSparseGraphBLAS.GrB_Row_assign</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">GrB_Row_assign(C, mask, accum, u, i, J, nj, desc)</code></pre><p>Assign the contents a vector to a subset of elements in one row of a matrix. Note that since the output cannot be transposed, a different variant of assign is provided  to assign to a column of a matrix.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using SuiteSparseGraphBLAS

julia&gt; GrB_init(GrB_NONBLOCKING)
GrB_SUCCESS::GrB_Info = 0

julia&gt; A = GrB_Matrix{Int64}()
GrB_Matrix{Int64}

julia&gt; GrB_Matrix_new(A, GrB_INT64, 4, 4)
GrB_SUCCESS::GrB_Info = 0

julia&gt; I = [0, 0, 2, 2]; J = [1, 2, 0, 2]; X = [10, 20, 30, 40]; n = 4;

julia&gt; GrB_Matrix_build(A, I, J, X, n, GrB_FIRST_INT64)
GrB_SUCCESS::GrB_Info = 0

julia&gt; u = GrB_Vector{Int64}()
GrB_Vector{Int64}

julia&gt; GrB_Vector_new(u, GrB_INT64, 2)
GrB_SUCCESS::GrB_Info = 0

julia&gt; I2 = [0, 1]; X2 = [5, 6]; n2 = 2;

julia&gt; GrB_Vector_build(u, I2, X2, n2, GrB_FIRST_INT64)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_Row_assign(A, GrB_NULL, GrB_NULL, u, 0, [1, 3], 2, GrB_NULL)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_Matrix_extractTuples(A)
([0, 0, 0, 2, 2], [1, 2, 3, 0, 2], [5, 20, 6, 30, 40])</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/abhinavmehndiratta/SuiteSparseGraphBLAS.jl/blob/529c975b2d6a9e2ec2869f225cc8146acac59edb/src/Operations/Assign.jl#L208-L250">source</a></section><h2><a class="nav-anchor" id="Apply-1" href="#Apply-1">Apply</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SuiteSparseGraphBLAS.GrB_apply" href="#SuiteSparseGraphBLAS.GrB_apply"><code>SuiteSparseGraphBLAS.GrB_apply</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">GrB_apply(C, Mask, accum, op, A, desc)</code></pre><p>Generic matrix/vector apply.</p></div></div><a class="source-link" target="_blank" href="https://github.com/abhinavmehndiratta/SuiteSparseGraphBLAS.jl/blob/529c975b2d6a9e2ec2869f225cc8146acac59edb/src/Operations/Apply.jl#L1-L5">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SuiteSparseGraphBLAS.GrB_Vector_apply" href="#SuiteSparseGraphBLAS.GrB_Vector_apply"><code>SuiteSparseGraphBLAS.GrB_Vector_apply</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">GrB_Vector_apply(w, mask, accum, op, u, desc)</code></pre><p>Compute the transformation of the values of the elements of a vector using a unary function.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using SuiteSparseGraphBLAS

julia&gt; GrB_init(GrB_NONBLOCKING)
GrB_SUCCESS::GrB_Info = 0

julia&gt; u = GrB_Vector{Int64}()
GrB_Vector{Int64}

julia&gt; GrB_Vector_new(u, GrB_INT64, 3)
GrB_SUCCESS::GrB_Info = 0

julia&gt; I = [0, 2]; X = [10, 20]; n = 2;

julia&gt; GrB_Vector_build(u, I, X, n, GrB_FIRST_INT64)
GrB_SUCCESS::GrB_Info = 0

julia&gt; w = GrB_Vector{Int64}()
GrB_Vector{Int64}

julia&gt; GrB_Vector_new(w, GrB_INT64, 3)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_Vector_apply(w, GrB_NULL, GrB_NULL, GrB_AINV_INT64, u, GrB_NULL)
GrB_SUCCESS::GrB_Info = 0

julia&gt; @GxB_fprint(w, GxB_COMPLETE)

GraphBLAS vector: w 
nrows: 3 ncols: 1 max # entries: 2
format: standard CSC vlen: 3 nvec_nonempty: 1 nvec: 1 plen: 1 vdim: 1
hyper_ratio 0.0625
GraphBLAS type:  int64_t size: 8
number of entries: 2 
column: 0 : 2 entries [0:1]
    row 0: int64 -10
    row 2: int64 -20
</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/abhinavmehndiratta/SuiteSparseGraphBLAS.jl/blob/529c975b2d6a9e2ec2869f225cc8146acac59edb/src/Operations/Apply.jl#L27-L72">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SuiteSparseGraphBLAS.GrB_Matrix_apply" href="#SuiteSparseGraphBLAS.GrB_Matrix_apply"><code>SuiteSparseGraphBLAS.GrB_Matrix_apply</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">GrB_Matrix_apply(C, Mask, accum, op, A, desc)</code></pre><p>Compute the transformation of the values of the elements of a matrix using a unary function.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using SuiteSparseGraphBLAS

julia&gt; GrB_init(GrB_NONBLOCKING)
GrB_SUCCESS::GrB_Info = 0

julia&gt; A = GrB_Matrix{Int64}()
GrB_Matrix{Int64}

julia&gt; GrB_Matrix_new(A, GrB_INT64, 2, 2)
GrB_SUCCESS::GrB_Info = 0

julia&gt; I = [0, 0, 1]; J = [0, 1, 1]; X = [10, 20, 30]; n = 3;

julia&gt; GrB_Matrix_build(A, I, J, X, n, GrB_FIRST_INT64)
GrB_SUCCESS::GrB_Info = 0

julia&gt; B = GrB_Matrix{Int64}()
GrB_Matrix{Int64}

julia&gt; GrB_Matrix_new(B, GrB_INT64, 2, 2)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_Matrix_apply(B, GrB_NULL, GrB_NULL, GrB_AINV_INT64, A, GrB_NULL)
GrB_SUCCESS::GrB_Info = 0

julia&gt; @GxB_fprint(B, GxB_COMPLETE)

GraphBLAS matrix: B
nrows: 2 ncols: 2 max # entries: 3
format: standard CSR vlen: 2 nvec_nonempty: 2 nvec: 2 plen: 2 vdim: 2
hyper_ratio 0.0625
GraphBLAS type:  int64_t size: 8
number of entries: 3
row: 0 : 2 entries [0:1]
    column 0: int64 -10
    column 1: int64 -20
row: 1 : 1 entries [2:2]
    column 1: int64 -30
</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/abhinavmehndiratta/SuiteSparseGraphBLAS.jl/blob/529c975b2d6a9e2ec2869f225cc8146acac59edb/src/Operations/Apply.jl#L92-L139">source</a></section><h2><a class="nav-anchor" id="Reduce-1" href="#Reduce-1">Reduce</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SuiteSparseGraphBLAS.GrB_reduce" href="#SuiteSparseGraphBLAS.GrB_reduce"><code>SuiteSparseGraphBLAS.GrB_reduce</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">GrB_reduce(arg1, arg2, arg3, arg4, ...)</code></pre><p>Generic method for matrix/vector reduction to a vector or scalar.</p></div></div><a class="source-link" target="_blank" href="https://github.com/abhinavmehndiratta/SuiteSparseGraphBLAS.jl/blob/529c975b2d6a9e2ec2869f225cc8146acac59edb/src/Operations/Reduce.jl#L1-L5">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SuiteSparseGraphBLAS.GrB_Matrix_reduce_Monoid" href="#SuiteSparseGraphBLAS.GrB_Matrix_reduce_Monoid"><code>SuiteSparseGraphBLAS.GrB_Matrix_reduce_Monoid</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">GrB_Matrix_reduce_Monoid(w, mask, accum, monoid, A, desc)</code></pre><p>Reduce the entries in a matrix to a vector. By default these methods compute a column vector w such that w(i) = sum(A(i,:)), where &quot;sum&quot; is a commutative and associative monoid with an identity value. A can be transposed, which reduces down the columns instead of the rows.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using SuiteSparseGraphBLAS

julia&gt; GrB_init(GrB_NONBLOCKING)
GrB_SUCCESS::GrB_Info = 0

julia&gt; A = GrB_Matrix{Int64}()
GrB_Matrix{Int64}

julia&gt; GrB_Matrix_new(A, GrB_INT64, 4, 4)
GrB_SUCCESS::GrB_Info = 0

julia&gt; I = [0, 0, 2, 2]; J = [1, 2, 0, 2]; X = [10, 20, 30, 40]; n = 4;

julia&gt; GrB_Matrix_build(A, I, J, X, n, GrB_FIRST_INT64)
GrB_SUCCESS::GrB_Info = 0

julia&gt; w = GrB_Vector{Int64}()
GrB_Vector{Int64}

julia&gt; GrB_Vector_new(w, GrB_INT64, 4)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_Matrix_reduce_Monoid(w, GrB_NULL, GrB_NULL, GxB_PLUS_INT64_MONOID, A, GrB_NULL)
GrB_SUCCESS::GrB_Info = 0

julia&gt; @GxB_fprint(w, GxB_COMPLETE)

GraphBLAS vector: w
nrows: 4 ncols: 1 max # entries: 2
format: standard CSC vlen: 4 nvec_nonempty: 1 nvec: 1 plen: 1 vdim: 1
hyper_ratio 0.0625
GraphBLAS type:  int64_t size: 8
number of entries: 2
column: 0 : 2 entries [0:1]
    row 0: int64 30
    row 2: int64 70
</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/abhinavmehndiratta/SuiteSparseGraphBLAS.jl/blob/529c975b2d6a9e2ec2869f225cc8146acac59edb/src/Operations/Reduce.jl#L22-L69">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SuiteSparseGraphBLAS.GrB_Matrix_reduce_BinaryOp" href="#SuiteSparseGraphBLAS.GrB_Matrix_reduce_BinaryOp"><code>SuiteSparseGraphBLAS.GrB_Matrix_reduce_BinaryOp</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">GrB_Matrix_reduce_BinaryOp(w, mask, accum, op, A, desc)</code></pre><p>Reduce the entries in a matrix to a vector. By default these methods compute a column vector w such that w(i) = sum(A(i,:)), where &quot;sum&quot; is a commutative and associative binary operator. A can be transposed, which reduces down the columns instead of the rows.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using SuiteSparseGraphBLAS

julia&gt; GrB_init(GrB_NONBLOCKING)
GrB_SUCCESS::GrB_Info = 0

julia&gt; A = GrB_Matrix{Int64}()
GrB_Matrix{Int64}

julia&gt; GrB_Matrix_new(A, GrB_INT64, 4, 4)
GrB_SUCCESS::GrB_Info = 0

julia&gt; I = [0, 0, 2, 2]; J = [1, 2, 0, 2]; X = [10, 20, 30, 40]; n = 4;

julia&gt; GrB_Matrix_build(A, I, J, X, n, GrB_FIRST_INT64)
GrB_SUCCESS::GrB_Info = 0

julia&gt; w = GrB_Vector{Int64}()
GrB_Vector{Int64}

julia&gt; GrB_Vector_new(w, GrB_INT64, 4)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_Matrix_reduce_BinaryOp(w, GrB_NULL, GrB_NULL, GrB_TIMES_INT64, A, GrB_NULL)
GrB_SUCCESS::GrB_Info = 0

julia&gt; @GxB_fprint(w, GxB_COMPLETE)

GraphBLAS vector: w
nrows: 4 ncols: 1 max # entries: 2
format: standard CSC vlen: 4 nvec_nonempty: 1 nvec: 1 plen: 1 vdim: 1
hyper_ratio 0.0625
GraphBLAS type:  int64_t size: 8
number of entries: 2
column: 0 : 2 entries [0:1]
    row 0: int64 200
    row 2: int64 1200
</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/abhinavmehndiratta/SuiteSparseGraphBLAS.jl/blob/529c975b2d6a9e2ec2869f225cc8146acac59edb/src/Operations/Reduce.jl#L89-L136">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SuiteSparseGraphBLAS.GrB_Vector_reduce" href="#SuiteSparseGraphBLAS.GrB_Vector_reduce"><code>SuiteSparseGraphBLAS.GrB_Vector_reduce</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">GrB_Vector_reduce(accum, monoid, u, desc)</code></pre><p>Reduce entries in a vector to a scalar. All entries in the vector are &quot;summed&quot; using the reduce monoid, which must be associative (otherwise the results are undefined). If the vector has no entries, the result is the identity value of the monoid.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using SuiteSparseGraphBLAS

julia&gt; GrB_init(GrB_NONBLOCKING)
GrB_SUCCESS::GrB_Info = 0

julia&gt; u = GrB_Vector{Int64}()
GrB_Vector{Int64}

julia&gt; GrB_Vector_new(u, GrB_INT64, 5)
GrB_SUCCESS::GrB_Info = 0

julia&gt; I = [0, 2, 4]; X = [10, 20, 30]; n = 3;

julia&gt; GrB_Vector_build(u, I, X, n, GrB_FIRST_INT64)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_Vector_reduce(GrB_NULL, GxB_MAX_INT64_MONOID, u, GrB_NULL)
30</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/abhinavmehndiratta/SuiteSparseGraphBLAS.jl/blob/529c975b2d6a9e2ec2869f225cc8146acac59edb/src/Operations/Reduce.jl#L156-L184">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SuiteSparseGraphBLAS.GrB_Matrix_reduce" href="#SuiteSparseGraphBLAS.GrB_Matrix_reduce"><code>SuiteSparseGraphBLAS.GrB_Matrix_reduce</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">GrB_Matrix_reduce(accum, monoid, A, desc)</code></pre><p>Reduce entries in a matrix to a scalar. All entries in the matrix are &quot;summed&quot; using the reduce monoid, which must be associative (otherwise the results are undefined). If the matrix has no entries, the result is the identity value of the monoid.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using SuiteSparseGraphBLAS

julia&gt; GrB_init(GrB_NONBLOCKING)
GrB_SUCCESS::GrB_Info = 0

julia&gt; A = GrB_Matrix{Int64}()
GrB_Matrix{Int64}

julia&gt; GrB_Matrix_new(A, GrB_INT64, 4, 4)
GrB_SUCCESS::GrB_Info = 0

julia&gt; I = [0, 0, 2, 2]; J = [1, 2, 0, 2]; X = [10, 20, 30, 40]; n = 4;

julia&gt; GrB_Matrix_build(A, I, J, X, n, GrB_FIRST_INT64)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_Matrix_reduce(GrB_NULL, GxB_MIN_INT64_MONOID, A, GrB_NULL)
10</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/abhinavmehndiratta/SuiteSparseGraphBLAS.jl/blob/529c975b2d6a9e2ec2869f225cc8146acac59edb/src/Operations/Reduce.jl#L208-L236">source</a></section><h2><a class="nav-anchor" id="Transpose-1" href="#Transpose-1">Transpose</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="SuiteSparseGraphBLAS.GrB_transpose" href="#SuiteSparseGraphBLAS.GrB_transpose"><code>SuiteSparseGraphBLAS.GrB_transpose</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">GrB_transpose(C, Mask, accum, A, desc)</code></pre><p>Compute a new matrix that is the transpose of the source matrix.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; using SuiteSparseGraphBLAS

julia&gt; GrB_init(GrB_NONBLOCKING)
GrB_SUCCESS::GrB_Info = 0

julia&gt; M = GrB_Matrix{Int64}()
GrB_Matrix{Int64}

julia&gt; GrB_Matrix_new(M, GrB_INT64, 4, 4)
GrB_SUCCESS::GrB_Info = 0

julia&gt; I = [0, 0]; J = [1, 2]; X = [10, 20]; n = 2;

julia&gt; GrB_Matrix_build(M, I, J, X, n, GrB_FIRST_INT64)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_Matrix_extractTuples(M)
([0, 0], [1, 2], [10, 20])

julia&gt; M_TRAN = GrB_Matrix{Int64}()
GrB_Matrix{Int64}

julia&gt; GrB_Matrix_new(M_TRAN, GrB_INT64, 4, 4)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_transpose(M_TRAN, GrB_NULL, GrB_NULL, M, GrB_NULL)
GrB_SUCCESS::GrB_Info = 0

julia&gt; GrB_Matrix_extractTuples(M_TRAN)
([1, 2], [0, 0], [10, 20])</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/abhinavmehndiratta/SuiteSparseGraphBLAS.jl/blob/529c975b2d6a9e2ec2869f225cc8146acac59edb/src/Operations/Transpose.jl#L1-L39">source</a></section><footer><hr/><a class="previous" href="../seq_ter/"><span class="direction">Previous</span><span class="title">Sequence termination</span></a></footer></article></body></html>
